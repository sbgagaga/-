---- C:\Users\Administrator\Desktop\project\K13-01\code\main.c ----------------------------------------------------------------------
1:                #include "K13-01.h"
2:                
3:                void main()
4:                {
5:                    SystemInit();
  076F    275E    CALL	0x75E
6:                    while (1)
7:                    {
8:                        Apply();
  0770    264B    CALL	0x64B
  0771    0064    CLRWDT
  0772    2F70    JP	0x770
9:                        asm("clrwdt");
10:                   }
11:               }
12:               
---- C:\Users\Administrator\Desktop\project\K13-01\code\K13-01.c ----------------------------------------------------------------------
1:                #include "K13-01.h"
2:                
3:                bit SystemONFlag=0;
4:                uint8 VarPowerUpCount=0;
5:                
6:                uint8 BatPercent=0;
7:                
8:                uint8 WorkMin=0;
9:                
10:               uint8 LockNumb=0;
11:               
12:               TYPE_UNION_LockSta LockSta;
13:               
14:               bit OnOffFlag=0;
15:               bit WorkFlag=0;
16:               bit IovFlag=0;
17:               bit LowBatFlag=0;
18:               bit USBFlag=0;
19:               bit LEDWorkFlag=0;
20:               
21:               uint8 Sec1sCnt=0;
22:               uint8 BatAddTime=240;
23:               uint8 BatDecTime=210;
24:               
25:               void Apply()
26:               {
27:                   if(time2ms)
  064B    1D71    SNZB	0x71,2
  064C    2E51    JP	0x651
28:                   {
29:                       time2ms=0;
  064D    1171    CLRB	0x71,2
30:                       if(SystemONFlag)
  064E    1FF1    SNZB	0x71,7
  064F    2E51    JP	0x651
31:                       {
32:                           KeyScan();
  0650    202C    CALL	0x2C
33:                       }
34:                   }
35:                   if(time10ms)
  0651    1CF1    SNZB	0x71,1
  0652    0008    RET
36:                   {
37:                       time10ms=0;
  0653    10F1    CLRB	0x71,1
38:                       if(SystemONFlag==0&&VarPowerUpCount<100)
  0654    1BF1    SZB	0x71,7
  0655    2E5C    JP	0x65C
  0656    266D    CALL	0x66D
  0657    1803    SZB	0x3,0
  0658    2E5C    JP	0x65C
39:                       {
40:                           VarPowerUpCount++;
  0659    0ABC    INCR	0x3C
41:                           ADCPro();
  065A    2481    CALL	0x481
42:                       }
  065B    2E61    JP	0x661
43:                       else if(VarPowerUpCount>=100)
  065C    266D    CALL	0x66D
  065D    1C03    SNZB	0x3,0
  065E    2E61    JP	0x661
44:                       {
45:                           SystemONFlag=1;
  065F    17F1    SETB	0x71,7
46:                           VarPowerUpCount=0;
  0660    01BC    CLR	0x3C
47:                       }
48:                       /*上电完成*/
49:                       if(SystemONFlag)
  0661    1FF1    SNZB	0x71,7
  0662    2E66    JP	0x666
50:                       {
51:                           ADCPro();
  0663    2481    CALL	0x481
52:                           Motor();
  0664    242B    CALL	0x42B
53:                           DisplayPro(); 
  0665    2753    CALL	0x753
  0666    3064    LDIA	0x64
54:                           #ifndef DEBUGFlag
55:                           SystemSleep(); 
56:                           #endif
57:                       }
58:                       Sec1sCnt++;
  0667    0ABA    INCR	0x3A
59:                       if(Sec1sCnt>=100)
  0668    023A    SUBA	0x3A
  0669    1C03    SNZB	0x3,0
  066A    0008    RET
60:                       {
61:                           Sec1sCnt=0;
  066B    01BA    CLR	0x3A
62:                           Sec1sPro();
  066C    2918    JP	0x118
63:                       }
64:                   }
65:               }
66:               
67:               void SystemSleep()
68:               {
69:                   static uint16 SleepCnt=0;
70:                   if(WorkFlag||OnOffFlag||LowBatFlag||USBFlag||IovFlag||KeyPress||LockSta.LockStart)
71:                   {
72:                       SleepCnt=0;
73:                   }
74:                   else
75:                   {
76:                       SleepCnt++;
77:                       if(SleepCnt>=1000)
78:                       {
79:                           LEDWorkFlag=0;
80:                           SleepCnt=0;
81:                           asm("clrwdt");
82:                           INTCON=0;
83:                           PIE1 = 0;
84:                           PIE2 = 0;	
85:                           PIR1 = 0;
86:                           ADCON0	= 0;
87:               
88:                           TRISA =0X00;
89:               	        TRISB =0X00;
90:                           TRISC =0x00;
91:                           WPUA = 0xFF;
92:                           WPUB = 0xFF;
93:                           WPUC = 0xFF;
94:                           PORTA =	0;			//初始端口配置为输出低；
95:                           PORTB = 0;
96:                           PORTC = 0;
97:                           PIN_BAT=H;
98:                           PIN_IOV=H;
99:                           PIN_GND=H;
100:                          PIN_EN =L;
101:                          Pin_KEY_CFG(1,1);
102:                          Pin_USB_CFG(1,1);
103:              
104:                          WDT_OFF();
105:                          RBIE=1;
106:                          IOCB=0xC0;
107:                          OSCCON=0X01;
108:                          RBIF = 0;
109:                          PORTB;
110:                          asm("sleep");
111:              		    asm("nop");
112:                          SystemInit();
113:                      }
114:                  }
115:              }
116:              
117:              void SystemInit()
  075E    0000    NOP
  075F    0064    CLRWDT
118:              {
119:                  asm("nop");
120:              	asm("clrwdt");
121:                  GPIOInit();
  0760    2623    CALL	0x623
122:                  TimerInit();
  0761    2737    CALL	0x737
123:                  WDT_ON();
  0762    3001    LDIA	0x1
  0763    1283    CLRB	0x3,5
  0764    1703    SETB	0x3,6
  0765    0085    LD	0x5,A
  0766    0008    RET
124:              }
125:              
126:              void GPIOInit()
127:              {
128:                  RBPU=0;
  0623    1683    SETB	0x3,5
  0624    1303    CLRB	0x3,6
  0625    1381    CLRB	0x1,7
129:              	/*全配置成输出*/
130:              	TRISA =0X00;
  0626    0185    CLR	0x5
131:              	TRISB =0X00;
  0627    0186    CLR	0x6
132:              	TRISC =0X00;
  0628    0187    CLR	0x7
133:              	//TRISE =0X00; 
134:              
135:                  /*全部设置上拉，输出会自动断开上拉*/
136:              	WPUA  =0XFF;
  0629    30FF    LDIA	0xFF
  062A    1703    SETB	0x3,6
  062B    008E    LD	0xE,A
137:              	WPUB  =0XFF;
  062C    1303    CLRB	0x3,6
  062D    0095    LD	0x15,A
138:              	WPUC  =0XFF;
  062E    1703    SETB	0x3,6
  062F    008F    LD	0xF,A
139:              	//WPUE  =0XFF;
140:              
141:                  /*默认输出0*/
142:              	PORTA =	0X80;
  0630    3080    LDIA	0x80
  0631    1283    CLRB	0x3,5
  0632    1303    CLRB	0x3,6
  0633    0085    LD	0x5,A
143:              	PORTB = 0X80;
  0634    0086    LD	0x6,A
144:              	PORTC = 0;
  0635    0187    CLR	0x7
145:              	//PORTE = 0;
146:              
147:              	PIN_EN =true;
  0636    1685    SETB	0x5,5
148:                  RBPU=0;
  0637    1683    SETB	0x3,5
  0638    1381    CLRB	0x1,7
149:                  Pin_KEY_CFG(IN,1);
  0639    1705    SETB	0x5,6
  063A    1703    SETB	0x3,6
  063B    170E    SETB	0xE,6
150:                  Pin_USB_CFG(IN,1);
  063C    1303    CLRB	0x3,6
  063D    1785    SETB	0x5,7
  063E    1703    SETB	0x3,6
  063F    178E    SETB	0xE,7
151:              	
152:              	Pin_BAT_CFG(1,0); ANS1=1; //AN1配置为模拟输入；
  0640    1303    CLRB	0x3,6
  0641    1485    SETB	0x5,1
  0642    1703    SETB	0x3,6
  0643    108E    CLRB	0xE,1
  0644    1488    SETB	0x8,1
153:              	Pin_IOV_CFG(1,0); ANS2=1; //AN2配置为模拟输入；
  0645    1303    CLRB	0x3,6
  0646    1505    SETB	0x5,2
  0647    1703    SETB	0x3,6
  0648    110E    CLRB	0xE,2
  0649    1508    SETB	0x8,2
  064A    0008    RET
154:                  //Pin_Vin_CFG(1,0); ANS9=1;//AN9配置为模拟输入；
155:              }
156:              
157:              void TimerInit()
158:              {
159:                  // OSCCON=0X71;		//晶振配置为8M,内部
160:              	// INTCON=0B11000000;	//使能全局中断，外设中断
161:              	// PIE1=0B00000001;	//TIMER1溢出中断
162:                  // TMR1IF = 0;
163:              	// TMR1IE = 1;	
164:                  // TMR1H=0xFC;
165:                  // TMR1L=0x18;         //设置定时器1计时1ms
166:                  // T1CON = 0X01; //预分配4倍,使能定时器1
167:              
168:              	OSCCON=0X61;		//晶振配置为4M,内部
  0737    3061    LDIA	0x61
  0738    1303    CLRB	0x3,6
  0739    008F    LD	0xF,A
169:              	INTCON=0B11000000;	//使能全局中断，外设中断
  073A    30C0    LDIA	0xC0
  073B    008B    LD	0xB,A
170:              	PIE1=0B00000010;	//TIMER2匹配中断
  073C    3002    LDIA	0x2
  073D    008C    LD	0xC,A
171:              	T2CON=0B00000100;	//使能TIMER2
  073E    3004    LDIA	0x4
  073F    1283    CLRB	0x3,5
  0740    0092    LD	0x12,A
172:              	PR2	= 200;			//TIMER时钟为Fosc/4; 200us进一次中断
  0741    30C8    LDIA	0xC8
  0742    1683    SETB	0x3,5
  0743    0092    LD	0x12,A
  0744    0008    RET
173:              }
---- C:\Users\Administrator\Desktop\project\K13-01\code\ADC.c ----------------------------------------------------------------------
1:                #include "ADC.h"
2:                
3:                uint8 ADCState=0;
4:                uint16 ADCVal[3]={0};//bg、current、Vbat
5:                uint32 ADsum=0;
6:                uint8 ADcnt=0;
7:                
8:                uint8 CurrentCnt=0;
9:                
10:               void ADCPro()
11:               {
12:                   switch (ADCState)
  0481    2C91    JP	0x491
13:                   {
14:                       case 0://内部参考电压采样
15:                       ADCRead(AD_BG,ADCVal);
  0482    3044    LDIA	0x44
  0483    00DF    LD	0x5F,A
  0484    300F    LDIA	0xF
  0485    21E9    CALL	0x1E9
16:                       break;
  0486    2C99    JP	0x499
17:               
18:                       case 1://过流采样
19:                       ADCRead(AD_AN2,ADCVal+1);
  0487    3046    LDIA	0x46
  0488    00DF    LD	0x5F,A
  0489    3002    LDIA	0x2
  048A    21E9    CALL	0x1E9
20:                       break;
  048B    2C99    JP	0x499
21:               
22:                       case 2://电池电压采样
23:                       ADCRead(AD_AN1,ADCVal+2);
  048C    3048    LDIA	0x48
  048D    00DF    LD	0x5F,A
  048E    3001    LDIA	0x1
  048F    21E9    CALL	0x1E9
24:                       break;
  0490    2C99    JP	0x499
  0491    22B1    CALL	0x2B1
  0492    1803    SZB	0x3,0
  0493    2C99    JP	0x499
  0494    3000    LDIA	0x0
  0495    008A    LD	0xA,A
  0496    3001    LDIA	0x1
  0497    0704    ADDA	0x4
  0498    0082    LD	0x2,A
25:                   }
26:                   if(SystemONFlag==0)
  0499    1BF1    SZB	0x71,7
  049A    2CB0    JP	0x4B0
27:                   {
28:                       if(ADCVal[2]<BAT_3V2) 
  049B    3001    LDIA	0x1
  049C    0249    SUBA	0x49
  049D    300B    LDIA	0xB
  049E    1903    SZB	0x3,2
  049F    0248    SUBA	0x48
  04A0    1803    SZB	0x3,0
  04A1    2CA4    JP	0x4A4
29:                       {
30:                           BatPercent=0; 
  04A2    01C3    CLR	0x43
31:                       }
  04A3    2CB0    JP	0x4B0
32:                       else if(ADCVal[2]>BAT_4V2)
  04A4    3001    LDIA	0x1
  04A5    0249    SUBA	0x49
  04A6    305F    LDIA	0x5F
  04A7    1903    SZB	0x3,2
  04A8    0248    SUBA	0x48
  04A9    1C03    SNZB	0x3,0
  04AA    2CAD    JP	0x4AD
33:                       {
34:                           BatPercent=99; 
  04AB    3063    LDIA	0x63
  04AC    2CAF    JP	0x4AF
35:                       }
36:                       else
37:                       {
38:                           BatPercent=ADCVal[2]-BAT_3V0;
  04AD    0848    LD	A,0x48
  04AE    3E06    ADDIA	0x6
  04AF    00C3    LD	0x43,A
39:                       }
40:                   }
41:                   if(ADCVal[2]<BAT_3V0)
  04B0    3000    LDIA	0x0
  04B1    0249    SUBA	0x49
  04B2    30FA    LDIA	0xFA
  04B3    1903    SZB	0x3,2
  04B4    0248    SUBA	0x48
  04B5    1803    SZB	0x3,0
  04B6    2CB9    JP	0x4B9
42:                   {
43:                       LowBatFlag=1;
  04B7    1771    SETB	0x71,6
44:                   }
  04B8    2CBA    JP	0x4BA
45:                   else
46:                   {
47:                       LowBatFlag=0;
  04B9    1371    CLRB	0x71,6
48:                   }
49:                   if(ADCVal[1]>VOLTAGE07V)
  04BA    3000    LDIA	0x0
  04BB    0247    SUBA	0x47
  04BC    303B    LDIA	0x3B
  04BD    1903    SZB	0x3,2
  04BE    0246    SUBA	0x46
  04BF    1C03    SNZB	0x3,0
  04C0    2CCA    JP	0x4CA
  04C1    30C8    LDIA	0xC8
50:                   {
51:                       CurrentCnt++;
  04C2    0AC0    INCR	0x40
52:                       if(CurrentCnt>=200)
  04C3    0240    SUBA	0x40
  04C4    1C03    SNZB	0x3,0
  04C5    0008    RET
53:                       {
54:                           CurrentCnt=200;
  04C6    30C8    LDIA	0xC8
  04C7    00C0    LD	0x40,A
55:                           IovFlag=1;
  04C8    16F1    SETB	0x71,5
  04C9    0008    RET
56:                       }
57:                   }
58:                   else
59:                   {
60:                       CurrentCnt=0;
  04CA    01C0    CLR	0x40
61:                       IovFlag=0;
  04CB    12F1    CLRB	0x71,5
  04CC    0008    RET
62:                   }
63:               }
64:               
65:               void Sec1sPro()
66:               {
67:                   static uint8 ActualPercent=0;
68:                   uint8 PercentErr=0;
69:                   uint16 TempPercent=0;
  0118    01D0    CLR	0x50
  0119    01D1    CLR	0x51
70:               
71:                   /*充电数字增加时间*/
72:                   if(USBFlag)
  011A    1E71    SNZB	0x71,4
  011B    2977    JP	0x177
73:                   {
74:                       if(ADCVal[2]<BAT_3V3) 
  011C    3001    LDIA	0x1
  011D    0249    SUBA	0x49
  011E    3013    LDIA	0x13
  011F    1903    SZB	0x3,2
  0120    0248    SUBA	0x48
  0121    1803    SZB	0x3,0
  0122    2925    JP	0x125
75:                       {
76:                           TempPercent=0; 
  0123    01D0    CLR	0x50
  0124    292E    JP	0x12E
77:                       }
78:                       else if(ADCVal[2]>BAT_4V2)
  0125    3001    LDIA	0x1
  0126    0249    SUBA	0x49
  0127    305F    LDIA	0x5F
  0128    1903    SZB	0x3,2
  0129    0248    SUBA	0x48
  012A    1C03    SNZB	0x3,0
  012B    2930    JP	0x130
79:                       {
80:                           TempPercent=99; 
  012C    3063    LDIA	0x63
  012D    00D0    LD	0x50,A
  012E    01D1    CLR	0x51
81:                       }
  012F    294C    JP	0x14C
82:                       else
83:                       {
84:                           TempPercent=ADCVal[2]-BAT_3V3;
  0130    0849    LD	A,0x49
  0131    00D1    LD	0x51,A
  0132    0848    LD	A,0x48
  0133    00D0    LD	0x50,A
  0134    30ED    LDIA	0xED
  0135    21E3    CALL	0x1E3
85:                           TempPercent=TempPercent*4/3;
  0136    3003    LDIA	0x3
  0137    00F5    LD	0x75,A
  0138    01F6    CLR	0x76
  0139    0851    LD	A,0x51
  013A    00CE    LD	0x4E,A
  013B    0850    LD	A,0x50
  013C    00CD    LD	0x4D,A
  013D    1003    CLRB	0x3,0
  013E    0DCD    RLCR	0x4D
  013F    0DCE    RLCR	0x4E
  0140    1003    CLRB	0x3,0
  0141    0DCD    RLCR	0x4D
  0142    0DCE    RLCR	0x4E
  0143    084D    LD	A,0x4D
  0144    00F7    LD	0x77,A
  0145    084E    LD	A,0x4E
  0146    00F8    LD	0x78,A
  0147    25F9    CALL	0x5F9
  0148    0876    LD	A,0x76
  0149    00D1    LD	0x51,A
  014A    0875    LD	A,0x75
  014B    00D0    LD	0x50,A
86:                       }
87:                       if(ActualPercent>TempPercent)
88:                       {
89:                           if(ActualPercent)
  014C    21D8    CALL	0x1D8
  014D    1803    SZB	0x3,0
  014E    2953    JP	0x153
  014F    1903    SZB	0x3,2
  0150    2962    JP	0x162
90:                           {
91:                               ActualPercent--;
  0151    03BF    DECR	0x3F
  0152    2962    JP	0x162
92:                           }
93:                       }
94:                       else if(ActualPercent<TempPercent)
  0153    00CD    LD	0x4D,A
  0154    01CE    CLR	0x4E
  0155    0851    LD	A,0x51
  0156    024E    SUBA	0x4E
  0157    1D03    SNZB	0x3,2
  0158    295B    JP	0x15B
  0159    0850    LD	A,0x50
  015A    024D    SUBA	0x4D
  015B    1803    SZB	0x3,0
  015C    2962    JP	0x162
95:                       {
96:                           if(ActualPercent<99)
  015D    3063    LDIA	0x63
  015E    023F    SUBA	0x3F
  015F    1803    SZB	0x3,0
  0160    2962    JP	0x162
97:                           {
98:                               ActualPercent++;
  0161    0ABF    INCR	0x3F
99:                           }
100:                      }
101:                      if(ActualPercent>BatPercent)
  0162    083F    LD	A,0x3F
  0163    0243    SUBA	0x43
  0164    1803    SZB	0x3,0
  0165    2975    JP	0x175
102:                      {
103:                          PercentErr=ActualPercent-BatPercent;
  0166    0843    LD	A,0x43
  0167    023F    SUBA	0x3F
  0168    00CF    LD	0x4F,A
104:                          if(PercentErr<5)
  0169    3005    LDIA	0x5
  016A    024F    SUBA	0x4F
  016B    1803    SZB	0x3,0
  016C    2973    JP	0x173
105:                          {
106:                              BatAddTime=90-15*PercentErr;
  016D    30F1    LDIA	0xF1
  016E    00F5    LD	0x75,A
  016F    084F    LD	A,0x4F
  0170    2745    CALL	0x745
  0171    3E5A    ADDIA	0x5A
  0172    2976    JP	0x176
107:                          }
108:                          else
109:                          {
110:                              BatAddTime=15;
  0173    300F    LDIA	0xF
  0174    2976    JP	0x176
111:                          }
112:                      }
113:                      else
114:                      {
115:                          BatAddTime=240;
  0175    30F0    LDIA	0xF0
  0176    00EA    LD	0x6A,A
116:                      }
117:                  }
118:              
119:                  /*工作数字减少时间*/
120:                  if(WorkFlag)
  0177    1DF1    SNZB	0x71,3
  0178    29D5    JP	0x1D5
121:                  {
122:                      if(ADCVal[2]<BAT_3V2) 
  0179    3001    LDIA	0x1
  017A    0249    SUBA	0x49
  017B    300B    LDIA	0xB
  017C    1903    SZB	0x3,2
  017D    0248    SUBA	0x48
  017E    1803    SZB	0x3,0
  017F    2982    JP	0x182
123:                      {
124:                          TempPercent=0; 
  0180    01D0    CLR	0x50
  0181    298B    JP	0x18B
125:                      }
126:                      else if(ADCVal[2]>BAT_4V0)
  0182    3001    LDIA	0x1
  0183    0249    SUBA	0x49
  0184    304E    LDIA	0x4E
  0185    1903    SZB	0x3,2
  0186    0248    SUBA	0x48
  0187    1C03    SNZB	0x3,0
  0188    298D    JP	0x18D
127:                      {
128:                          TempPercent=99; 
  0189    3063    LDIA	0x63
  018A    00D0    LD	0x50,A
  018B    01D1    CLR	0x51
129:                      }
  018C    2993    JP	0x193
130:                      else
131:                      {
132:                          TempPercent=ADCVal[2]-BAT_3V2;
  018D    0849    LD	A,0x49
  018E    00D1    LD	0x51,A
  018F    0848    LD	A,0x48
  0190    00D0    LD	0x50,A
  0191    30F5    LDIA	0xF5
  0192    21E3    CALL	0x1E3
133:                      }
134:                      if(TempPercent>=33)
  0193    3000    LDIA	0x0
  0194    0251    SUBA	0x51
  0195    3021    LDIA	0x21
  0196    1903    SZB	0x3,2
  0197    0250    SUBA	0x50
  0198    1C03    SNZB	0x3,0
  0199    29A7    JP	0x1A7
135:                      {
136:                          TempPercent=33+(ADCVal[2]-BAT_3V6)*2; 
  019A    0849    LD	A,0x49
  019B    00D1    LD	0x51,A
  019C    0848    LD	A,0x48
  019D    00D0    LD	0x50,A
  019E    30C9    LDIA	0xC9
  019F    1003    CLRB	0x3,0
  01A0    0DD0    RLCR	0x50
  01A1    0DD1    RLCR	0x51
  01A2    07D0    ADDR	0x50
  01A3    1803    SZB	0x3,0
  01A4    0AD1    INCR	0x51
  01A5    30FD    LDIA	0xFD
  01A6    07D1    ADDR	0x51
137:                      }
138:                      if(ActualPercent>TempPercent)
139:                      {
140:                          if(ActualPercent)
  01A7    21D8    CALL	0x1D8
  01A8    1803    SZB	0x3,0
  01A9    29AE    JP	0x1AE
  01AA    1903    SZB	0x3,2
  01AB    29BD    JP	0x1BD
141:                          {
142:                              ActualPercent--;
  01AC    03BF    DECR	0x3F
  01AD    29BD    JP	0x1BD
143:                          }
144:                      }
145:                      else if(ActualPercent<TempPercent)
  01AE    00CD    LD	0x4D,A
  01AF    01CE    CLR	0x4E
  01B0    0851    LD	A,0x51
  01B1    024E    SUBA	0x4E
  01B2    1D03    SNZB	0x3,2
  01B3    29B6    JP	0x1B6
  01B4    0850    LD	A,0x50
  01B5    024D    SUBA	0x4D
  01B6    1803    SZB	0x3,0
  01B7    29BD    JP	0x1BD
146:                      {
147:                          if(ActualPercent<99)
  01B8    3063    LDIA	0x63
  01B9    023F    SUBA	0x3F
  01BA    1803    SZB	0x3,0
  01BB    29BD    JP	0x1BD
148:                          {
149:                              ActualPercent++;
  01BC    0ABF    INCR	0x3F
150:                          }
151:                      }
152:                      if(ActualPercent<BatPercent)
  01BD    0843    LD	A,0x43
  01BE    023F    SUBA	0x3F
  01BF    1803    SZB	0x3,0
  01C0    29D5    JP	0x1D5
153:                      {
154:                          PercentErr=BatPercent-ActualPercent;
  01C1    083F    LD	A,0x3F
  01C2    0243    SUBA	0x43
  01C3    00CF    LD	0x4F,A
155:                          if(PercentErr<5&&ActualPercent)
  01C4    3005    LDIA	0x5
  01C5    024F    SUBA	0x4F
  01C6    1803    SZB	0x3,0
  01C7    29D2    JP	0x1D2
  01C8    083F    LD	A,0x3F
  01C9    1903    SZB	0x3,2
  01CA    29D2    JP	0x1D2
156:                          {
157:                              BatDecTime=75-15*PercentErr;
  01CB    30F1    LDIA	0xF1
  01CC    00F5    LD	0x75,A
  01CD    084F    LD	A,0x4F
  01CE    2745    CALL	0x745
  01CF    3E4B    ADDIA	0x4B
  01D0    00E9    LD	0x69,A
158:                          }
  01D1    0008    RET
159:                          else
160:                          {
161:                              BatDecTime=8;
  01D2    3008    LDIA	0x8
  01D3    00E9    LD	0x69,A
  01D4    0008    RET
162:                          }
163:                      }
164:                      else
165:                      {
166:                          BatDecTime=210;
  01D5    30D2    LDIA	0xD2
  01D6    00E9    LD	0x69,A
  01D7    0008    RET
167:                      }
168:                  }
169:                  else
170:                  {
171:                      BatDecTime=210;
172:                  }
173:              }
174:              
175:              void ADCRead(uint8 ch,uint16 *Val)
  01E9    1683    SETB	0x3,5
  01EA    00D3    LD	0x53,A
176:              {
177:              	uint16 ad_temp,AD_H,AD_L;
178:              
179:              	if(ADSample(ch))
  01EB    26DD    CALL	0x6DD
  01EC    3A00    XORIA	0x0
  01ED    1903    SZB	0x3,2
  01EE    0008    RET
180:              	{
181:                      AD_H=ADRESH;
  01EF    081E    LD	A,0x1E
  01F0    1683    SETB	0x3,5
  01F1    00D4    LD	0x54,A
  01F2    01D5    CLR	0x55
182:                      AD_L=ADRESL;
  01F3    081E    LD	A,0x1E
  01F4    00D6    LD	0x56,A
  01F5    01D7    CLR	0x57
183:              		ad_temp=(AD_H<<4)|(AD_L>>4);  //12位ad
  01F6    0855    LD	A,0x55
  01F7    1283    CLRB	0x3,5
  01F8    00E1    LD	0x61,A
  01F9    1683    SETB	0x3,5
  01FA    0854    LD	A,0x54
  01FB    1283    CLRB	0x3,5
  01FC    00E0    LD	0x60,A
  01FD    30F0    LDIA	0xF0
  01FE    0EE0    SWAPR	0x60
  01FF    0EE1    SWAPR	0x61
  0200    05E1    ANDR	0x61
  0201    0860    LD	A,0x60
  0202    390F    ANDIA	0xF
  0203    04E1    ORR	0x61
  0204    30F0    LDIA	0xF0
  0205    05E0    ANDR	0x60
  0206    0860    LD	A,0x60
  0207    1683    SETB	0x3,5
  0208    00D8    LD	0x58,A
  0209    1283    CLRB	0x3,5
  020A    0861    LD	A,0x61
  020B    1683    SETB	0x3,5
  020C    00D9    LD	0x59,A
  020D    0857    LD	A,0x57
  020E    1283    CLRB	0x3,5
  020F    00E1    LD	0x61,A
  0210    1683    SETB	0x3,5
  0211    0856    LD	A,0x56
  0212    1283    CLRB	0x3,5
  0213    00E0    LD	0x60,A
  0214    3004    LDIA	0x4
  0215    1003    CLRB	0x3,0
  0216    0CE1    RRCR	0x61
  0217    0CE0    RRCR	0x60
  0218    3EFF    ADDIA	0xFF
  0219    1D03    SNZB	0x3,2
  021A    2A15    JP	0x215
  021B    0860    LD	A,0x60
  021C    1683    SETB	0x3,5
  021D    04D8    ORR	0x58
  021E    1283    CLRB	0x3,5
  021F    0861    LD	A,0x61
  0220    1683    SETB	0x3,5
  0221    04D9    ORR	0x59
184:              		ADsum += ad_temp;
  0222    0858    LD	A,0x58
  0223    1283    CLRB	0x3,5
  0224    00E0    LD	0x60,A
  0225    1683    SETB	0x3,5
  0226    0859    LD	A,0x59
  0227    1283    CLRB	0x3,5
  0228    00E1    LD	0x61,A
  0229    01E2    CLR	0x62
  022A    01E3    CLR	0x63
  022B    0860    LD	A,0x60
  022C    07A0    ADDR	0x20
  022D    0861    LD	A,0x61
  022E    1103    CLRB	0x3,2
  022F    1803    SZB	0x3,0
  0230    3E01    ADDIA	0x1
  0231    1D03    SNZB	0x3,2
  0232    07A1    ADDR	0x21
  0233    0862    LD	A,0x62
  0234    1103    CLRB	0x3,2
  0235    1803    SZB	0x3,0
  0236    3E01    ADDIA	0x1
  0237    1D03    SNZB	0x3,2
  0238    07A2    ADDR	0x22
  0239    0863    LD	A,0x63
  023A    1103    CLRB	0x3,2
  023B    1803    SZB	0x3,0
  023C    3E01    ADDIA	0x1
  023D    1D03    SNZB	0x3,2
  023E    07A3    ADDR	0x23
  023F    300A    LDIA	0xA
185:              		ADcnt++;
  0240    0AC1    INCR	0x41
186:              		if(ADcnt >= 10)
  0241    0241    SUBA	0x41
  0242    1C03    SNZB	0x3,0
  0243    0008    RET
  0244    300A    LDIA	0xA
187:              		{
188:                          ADcnt = 0;	
  0245    01C1    CLR	0x41
189:              			ADsum /=10;
  0246    00D2    LD	0x52,A
  0247    01D3    CLR	0x53
  0248    01D4    CLR	0x54
  0249    01D5    CLR	0x55
  024A    0823    LD	A,0x23
  024B    00D9    LD	0x59,A
  024C    0822    LD	A,0x22
  024D    00D8    LD	0x58,A
  024E    0821    LD	A,0x21
  024F    00D7    LD	0x57,A
  0250    0820    LD	A,0x20
  0251    00D6    LD	0x56,A
  0252    24CD    CALL	0x4CD
  0253    0855    LD	A,0x55
  0254    00A3    LD	0x23,A
  0255    0854    LD	A,0x54
  0256    00A2    LD	0x22,A
  0257    0853    LD	A,0x53
  0258    00A1    LD	0x21,A
  0259    0852    LD	A,0x52
  025A    00A0    LD	0x20,A
190:                          switch (ADCState)
  025B    2A89    JP	0x289
191:                          {
192:                              case 0:
193:                              *Val=ADsum;//内部参考电压
  025C    085F    LD	A,0x5F
  025D    0084    LD	0x4,A
  025E    0820    LD	A,0x20
  025F    1383    CLRB	0x3,7
  0260    0080    LD	0x0,A
  0261    0A84    INCR	0x4
  0262    0821    LD	A,0x21
  0263    2A87    JP	0x287
194:                              break;
195:              
196:                              case 1:
197:                              *Val=ADsum*1000/(*(Val-1));//电流
  0264    085F    LD	A,0x5F
  0265    3EFE    ADDIA	0xFE
  0266    229B    CALL	0x29B
  0267    3003    LDIA	0x3
  0268    01D1    CLR	0x51
  0269    01D0    CLR	0x50
  026A    00CF    LD	0x4F,A
  026B    30E8    LDIA	0xE8
  026C    00CE    LD	0x4E,A
  026D    2A76    JP	0x276
198:                              break;
199:              
200:                              case 2:
201:                              *Val=ADsum*100/(*(Val-2));//电池电压
  026E    085F    LD	A,0x5F
  026F    3EFC    ADDIA	0xFC
  0270    229B    CALL	0x29B
  0271    3064    LDIA	0x64
  0272    00CE    LD	0x4E,A
  0273    01CF    CLR	0x4F
  0274    01D0    CLR	0x50
  0275    01D1    CLR	0x51
  0276    25C6    CALL	0x5C6
  0277    084D    LD	A,0x4D
  0278    00D9    LD	0x59,A
  0279    084C    LD	A,0x4C
  027A    00D8    LD	0x58,A
  027B    084B    LD	A,0x4B
  027C    00D7    LD	0x57,A
  027D    084A    LD	A,0x4A
  027E    00D6    LD	0x56,A
  027F    24CD    CALL	0x4CD
  0280    085F    LD	A,0x5F
  0281    0084    LD	0x4,A
  0282    0852    LD	A,0x52
  0283    1383    CLRB	0x3,7
  0284    0080    LD	0x0,A
  0285    0A84    INCR	0x4
  0286    0853    LD	A,0x53
  0287    0080    LD	0x0,A
202:                              break;
  0288    2A91    JP	0x291
  0289    22B1    CALL	0x2B1
  028A    1803    SZB	0x3,0
  028B    2A91    JP	0x291
  028C    3006    LDIA	0x6
  028D    008A    LD	0xA,A
  028E    30FB    LDIA	0xFB
  028F    0704    ADDA	0x4
  0290    0082    LD	0x2,A
  0291    3003    LDIA	0x3
203:                          }
204:              			ADsum = 0;
  0292    01A0    CLR	0x20
  0293    01A1    CLR	0x21
  0294    01A2    CLR	0x22
  0295    01A3    CLR	0x23
205:                          ADCState++;
  0296    0AC2    INCR	0x42
206:                          if(ADCState>=3)
  0297    0242    SUBA	0x42
  0298    1803    SZB	0x3,0
207:                          {
208:                              ADCState=0;
  0299    01C2    CLR	0x42
  029A    0008    RET
209:                          }
210:              		}
211:              	}
212:              }
213:              
214:              /************************************************************
215:              函数名称：ADSample()
216:              函数功能：AD采样函数
217:              入口参数：ADCH,AD通道
218:              出口参数：ADRESH,ADRESL
219:              备    注：采样成功返回1，超时返回0
220:              ************************************************************/
221:              uint8 ADSample(uint8 ch)
  06DD    00F6    LD	0x76,A
222:              {
223:              	ADCON1 = 0x00;					//左对齐
  06DE    019F    CLR	0x1F
224:              	ADCON0 = 0X41 | ( ch << 2);	//16分频
  06DF    00F5    LD	0x75,A
  06E0    3001    LDIA	0x1
  06E1    1003    CLRB	0x3,0
  06E2    0DF5    RLCR	0x75
  06E3    3EFF    ADDIA	0xFF
  06E4    1003    CLRB	0x3,0
  06E5    1D03    SNZB	0x3,2
  06E6    2EE2    JP	0x6E2
  06E7    0D75    RLCA	0x75
  06E8    3841    ORIA	0x41
  06E9    1283    CLRB	0x3,5
  06EA    009F    LD	0x1F,A
  06EB    0000    NOP
  06EC    0000    NOP
225:              	asm("nop");
226:              	asm("nop");
227:              	GODONE = 1;						//开始转换
  06ED    1283    CLRB	0x3,5
  06EE    1303    CLRB	0x3,6
  06EF    149F    SETB	0x1F,1
228:              	volatile unsigned char i = 0;
  06F0    01F7    CLR	0x77
229:              	while(GODONE)
  06F1    1C9F    SNZB	0x1F,1
  06F2    3401    RET	0x1
230:              	{
231:              		if(0 == (--i))				//ad等待限时，防止拔插电后出现死循环
  06F3    0BF7    SZDECR	0x77
  06F4    2EF1    JP	0x6F1
232:              			return 0;
  06F5    3400    RET	0x0
233:              	}
234:              	return 1;
235:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  05F9    01CB    CLR	0x4B
  05FA    01CC    CLR	0x4C
  05FB    0875    LD	A,0x75
  05FC    0476    ORA	0x76
  05FD    1903    SZB	0x3,2
  05FE    2E1E    JP	0x61E
  05FF    01CA    CLR	0x4A
  0600    0ACA    INCR	0x4A
  0601    1BF6    SZB	0x76,7
  0602    2E07    JP	0x607
  0603    1003    CLRB	0x3,0
  0604    0DF5    RLCR	0x75
  0605    0DF6    RLCR	0x76
  0606    2E00    JP	0x600
  0607    1003    CLRB	0x3,0
  0608    0DCB    RLCR	0x4B
  0609    0DCC    RLCR	0x4C
  060A    0876    LD	A,0x76
  060B    0278    SUBA	0x78
  060C    1D03    SNZB	0x3,2
  060D    2E10    JP	0x610
  060E    0875    LD	A,0x75
  060F    0277    SUBA	0x77
  0610    1C03    SNZB	0x3,0
  0611    2E1A    JP	0x61A
  0612    0875    LD	A,0x75
  0613    02F7    SUBR	0x77
  0614    0876    LD	A,0x76
  0615    1C03    SNZB	0x3,0
  0616    03F8    DECR	0x78
  0617    02F8    SUBR	0x78
  0618    144B    SETB	0x4B,0
  0619    1003    CLRB	0x3,0
  061A    0CF6    RRCR	0x76
  061B    0CF5    RRCR	0x75
  061C    0BCA    SZDECR	0x4A
  061D    2E07    JP	0x607
  061E    084C    LD	A,0x4C
  061F    00F6    LD	0x76,A
  0620    084B    LD	A,0x4B
  0621    00F5    LD	0x75,A
  0622    0008    RET
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\Motor.c ----------------------------------------------------------------------
1:                #include "Motor.h"
2:                
3:                uint16 WorkCnt=0;
4:                uint16 TimeDecCnt=0;
5:                uint16 TimeAddCnt=0;
6:                
7:                void Motor()
8:                {
9:                    if(!WorkFlag)
  042B    19F1    SZB	0x71,3
  042C    2C33    JP	0x433
10:                   {
11:                       MotorOff();
  042D    1185    CLRB	0x5,3
12:                       WorkCnt=0;
  042E    01A8    CLR	0x28
  042F    01A9    CLR	0x29
13:                       TimeDecCnt=0;
  0430    01A6    CLR	0x26
  0431    01A7    CLR	0x27
14:                   }
  0432    2C5A    JP	0x45A
15:                   else if(WorkFlag&&!LockSta.LockFlag)
  0433    19F1    SZB	0x71,3
  0434    1B2E    SZB	0x2E,6
  0435    2C5A    JP	0x45A
16:                   {
17:                       MotorOn();
  0436    1585    SETB	0x5,3
18:                       TimeDecCnt++;
  0437    0AA6    INCR	0x26
  0438    1903    SZB	0x3,2
  0439    0AA7    INCR	0x27
19:                       if(TimeDecCnt>=BatDecTime*100)
  043A    0869    LD	A,0x69
  043B    247B    CALL	0x47B
  043C    26C4    CALL	0x6C4
  043D    0876    LD	A,0x76
  043E    0227    SUBA	0x27
  043F    1D03    SNZB	0x3,2
  0440    2C43    JP	0x443
  0441    0875    LD	A,0x75
  0442    0226    SUBA	0x26
  0443    1C03    SNZB	0x3,0
  0444    2C4A    JP	0x44A
20:                       {
21:                           TimeDecCnt=0;
  0445    01A6    CLR	0x26
  0446    01A7    CLR	0x27
22:                           if(BatPercent)
  0447    0843    LD	A,0x43
  0448    1D03    SNZB	0x3,2
23:                           {
24:                               BatPercent--;
  0449    03C3    DECR	0x43
25:                           }
26:                       }
27:                       WorkCnt++;
  044A    0AA8    INCR	0x28
  044B    1903    SZB	0x3,2
  044C    0AA9    INCR	0x29
28:                       if(WorkCnt>=6000)
  044D    3017    LDIA	0x17
  044E    0229    SUBA	0x29
  044F    3070    LDIA	0x70
  0450    1903    SZB	0x3,2
  0451    0228    SUBA	0x28
  0452    1C03    SNZB	0x3,0
  0453    2C5A    JP	0x45A
  0454    3063    LDIA	0x63
29:                       {
30:                           WorkCnt=0;
  0455    01A8    CLR	0x28
  0456    01A9    CLR	0x29
31:                           if(WorkMin<99)
  0457    027A    SUBA	0x7A
  0458    1C03    SNZB	0x3,0
32:                           {
33:                               WorkMin++;
  0459    0AFA    INCR	0x7A
34:                           }
35:                       }
36:                   }
37:                   if(USBFlag)
  045A    1E71    SNZB	0x71,4
  045B    2C78    JP	0x478
38:                   {
39:                       TimeAddCnt++;
  045C    0AA4    INCR	0x24
  045D    1903    SZB	0x3,2
  045E    0AA5    INCR	0x25
40:                       if(TimeAddCnt>BatAddTime*100)
  045F    086A    LD	A,0x6A
  0460    247B    CALL	0x47B
  0461    26C4    CALL	0x6C4
  0462    0825    LD	A,0x25
  0463    0276    SUBA	0x76
  0464    1D03    SNZB	0x3,2
  0465    2C68    JP	0x468
  0466    0824    LD	A,0x24
  0467    0275    SUBA	0x75
  0468    1803    SZB	0x3,0
  0469    2C70    JP	0x470
  046A    3063    LDIA	0x63
41:                       {
42:                           TimeAddCnt=0;
  046B    01A4    CLR	0x24
  046C    01A5    CLR	0x25
43:                           if(BatPercent<99)
  046D    0243    SUBA	0x43
  046E    1C03    SNZB	0x3,0
44:                           {
45:                               BatPercent++;
  046F    0AC3    INCR	0x43
46:                           }
47:                       }
48:                       if(BatPercent<=BAT_3V0)
  0470    30FB    LDIA	0xFB
  0471    0243    SUBA	0x43
  0472    1803    SZB	0x3,0
  0473    2C76    JP	0x476
49:                       {
50:                           PIN_EN =false;
  0474    1285    CLRB	0x5,5
51:                       }
  0475    0008    RET
52:                       else
53:                       {
54:                           PIN_EN =true;
  0476    1685    SETB	0x5,5
  0477    0008    RET
55:                       }
56:                   }
57:                   else
58:                   {
59:                       TimeAddCnt=0;
  0478    01A4    CLR	0x24
  0479    01A5    CLR	0x25
  047A    2C76    JP	0x476
60:                       PIN_EN =true;
61:                   }
62:               }
63:               
64:               
65:               
66:               
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul16.c ----------------------------------------------------------------------
1:                // 16 x 16 bit multiplication with 16 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned int
15:               __wmul(unsigned int multiplier, unsigned int multiplicand)
  06C4    01CA    CLR	0x4A
  06C5    01CB    CLR	0x4B
  06C6    1C75    SNZB	0x75,0
  06C7    2ECE    JP	0x6CE
  06C8    0877    LD	A,0x77
  06C9    07CA    ADDR	0x4A
  06CA    1803    SZB	0x3,0
  06CB    0ACB    INCR	0x4B
  06CC    0878    LD	A,0x78
  06CD    07CB    ADDR	0x4B
  06CE    1003    CLRB	0x3,0
  06CF    0DF7    RLCR	0x77
  06D0    0DF8    RLCR	0x78
  06D1    1003    CLRB	0x3,0
  06D2    0CF6    RRCR	0x76
  06D3    0CF5    RRCR	0x75
  06D4    0875    LD	A,0x75
  06D5    0476    ORA	0x76
  06D6    1D03    SNZB	0x3,2
  06D7    2EC6    JP	0x6C6
  06D8    084B    LD	A,0x4B
  06D9    00F6    LD	0x76,A
  06DA    084A    LD	A,0x4A
  06DB    00F5    LD	0x75,A
  06DC    0008    RET
16:               {
17:                       unsigned int product;
18:               
19:               #if _Has_hardware_multiply || _Has_large_call_stack
20:               
21:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:               
24:               	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:               /*
26:               a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                      a  b
28:               *      c  d
29:               -----------
30:                    |   bd
31:                    |ad  0
32:                    |bc  0
33:               +  ac| 0  0 (we ignore this intermediate product
34:                            because it does not affect the low 16 bits of the result)
35:               ===========
36:                */
37:                       product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                       product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                       product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:               
41:               #else
42:               
43:               	product = 0;
44:               	do {
45:               		if(multiplier & 1)
46:               			product += multiplicand;
47:               		multiplicand <<= 1;
48:               		multiplier >>= 1;
49:               	} while(multiplier != 0);
50:               
51:               #endif
52:                       return product;
53:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\Key.c ----------------------------------------------------------------------
1:                #include "Key.h"
2:                
3:                bit KeyInBuf=0;
4:                bit KeyPress=0;
5:                uint16 KeyCnt=0;
6:                
7:                bit USBLink=0;
8:                
9:                void KeyScan()
10:               {
11:               	if(!PIN_KEY)
  002C    1283    CLRB	0x3,5
  002D    1303    CLRB	0x3,6
  002E    1B05    SZB	0x5,6
  002F    2832    JP	0x32
12:               	{
13:               		KeyPress=1;
  0030    1471    SETB	0x71,0
14:               	}
  0031    2833    JP	0x33
15:               	else
16:               	{
17:               		KeyPress=0;
  0032    1071    CLRB	0x71,0
18:               	}
19:               	/*按键判断*/
20:               	if(KeyPress&&KeyCnt<10&&KeyInBuf==KeyPress&&(!LowBatFlag||USBFlag)&&!LockSta.LockFlag)//非低电压、非锁定、充电
  0033    1C71    SNZB	0x71,0
  0034    2866    JP	0x66
  0035    3000    LDIA	0x0
  0036    022D    SUBA	0x2D
  0037    300A    LDIA	0xA
  0038    1903    SZB	0x3,2
  0039    022C    SUBA	0x2C
  003A    1803    SZB	0x3,0
  003B    2866    JP	0x66
  003C    1C71    SNZB	0x71,0
  003D    2840    JP	0x40
  003E    3001    LDIA	0x1
  003F    2841    JP	0x41
  0040    3000    LDIA	0x0
  0041    00F5    LD	0x75,A
  0042    1EF0    SNZB	0x70,5
  0043    2846    JP	0x46
  0044    3001    LDIA	0x1
  0045    2847    JP	0x47
  0046    3000    LDIA	0x0
  0047    0675    XORA	0x75
  0048    1D03    SNZB	0x3,2
  0049    2866    JP	0x66
  004A    1F71    SNZB	0x71,6
  004B    284E    JP	0x4E
  004C    1E71    SNZB	0x71,4
  004D    2866    JP	0x66
  004E    1B2E    SZB	0x2E,6
  004F    2866    JP	0x66
21:               	{
22:               		KeyCnt++;
23:               		if(KeyCnt>=10)
  0050    2112    CALL	0x112
  0051    300A    LDIA	0xA
  0052    1903    SZB	0x3,2
  0053    022C    SUBA	0x2C
  0054    1C03    SNZB	0x3,0
  0055    28FF    JP	0xFF
24:               		{
25:               			WorkFlag=~WorkFlag; 
  0056    3008    LDIA	0x8
  0057    06F1    XORR	0x71
26:               			if(WorkFlag)
  0058    1DF1    SNZB	0x71,3
  0059    285B    JP	0x5B
27:               			{
28:               				LEDWorkFlag=1;
  005A    1770    SETB	0x70,6
29:               			}
30:               			if(!WorkFlag&&WorkMin!=0&&!USBFlag)
  005B    19F1    SZB	0x71,3
  005C    2863    JP	0x63
  005D    087A    LD	A,0x7A
  005E    1D03    SNZB	0x3,2
  005F    1A71    SZB	0x71,4
  0060    2863    JP	0x63
31:               			{
32:               				OnOffFlag=1;
  0061    17F0    SETB	0x70,7
33:               			}
  0062    28FF    JP	0xFF
34:               			else
35:               			{
36:               				OnOffFlag=0;
  0063    13F0    CLRB	0x70,7
37:               				WorkMin=0;
  0064    01FA    CLR	0x7A
  0065    28FF    JP	0xFF
38:               			}
39:               		}
40:               	}
41:               	else if(KeyPress&&(KeyCnt>=10||LockSta.LockFlag)&&KeyCnt<250&&KeyInBuf==KeyPress&&!USBFlag)
  0066    1C71    SNZB	0x71,0
  0067    28A4    JP	0xA4
  0068    3000    LDIA	0x0
  0069    022D    SUBA	0x2D
  006A    300A    LDIA	0xA
  006B    1903    SZB	0x3,2
  006C    022C    SUBA	0x2C
  006D    1803    SZB	0x3,0
  006E    2871    JP	0x71
  006F    1F2E    SNZB	0x2E,6
  0070    28A4    JP	0xA4
  0071    3000    LDIA	0x0
  0072    022D    SUBA	0x2D
  0073    30FA    LDIA	0xFA
  0074    1903    SZB	0x3,2
  0075    022C    SUBA	0x2C
  0076    1803    SZB	0x3,0
  0077    28A4    JP	0xA4
  0078    1C71    SNZB	0x71,0
  0079    287C    JP	0x7C
  007A    3001    LDIA	0x1
  007B    287D    JP	0x7D
  007C    3000    LDIA	0x0
  007D    00F5    LD	0x75,A
  007E    1EF0    SNZB	0x70,5
  007F    2882    JP	0x82
  0080    3001    LDIA	0x1
  0081    2883    JP	0x83
  0082    3000    LDIA	0x0
  0083    0675    XORA	0x75
  0084    1903    SZB	0x3,2
  0085    1A71    SZB	0x71,4
  0086    28A4    JP	0xA4
42:               	{
43:               		KeyCnt++;
44:               		if(KeyCnt>=250||(LockSta.LockFlag&&KeyCnt>=10))
  0087    2112    CALL	0x112
  0088    30FA    LDIA	0xFA
  0089    1903    SZB	0x3,2
  008A    022C    SUBA	0x2C
  008B    1803    SZB	0x3,0
  008C    2896    JP	0x96
  008D    1F2E    SNZB	0x2E,6
  008E    28FF    JP	0xFF
  008F    3000    LDIA	0x0
  0090    022D    SUBA	0x2D
  0091    300A    LDIA	0xA
  0092    1903    SZB	0x3,2
  0093    022C    SUBA	0x2C
  0094    1C03    SNZB	0x3,0
  0095    28FF    JP	0xFF
45:               		{
46:               			KeyCnt=250;
  0096    30FA    LDIA	0xFA
  0097    00AC    LD	0x2C,A
  0098    3002    LDIA	0x2
  0099    01AD    CLR	0x2D
47:               			LockNumb=2;
  009A    00BB    LD	0x3B,A
48:               			if(!LockSta.LockFlag)
  009B    1B2E    SZB	0x2E,6
  009C    28A0    JP	0xA0
49:               			{
50:               				LockSta.LockStart=1;
  009D    142E    SETB	0x2E,0
51:               				LockSta.UnlockEnd=0;
  009E    12AE    CLRB	0x2E,5
52:               			}
  009F    28A2    JP	0xA2
53:               			else
54:               			{
55:               				LockSta.UnlockStart=1;
  00A0    15AE    SETB	0x2E,3
56:               				LockSta.LockEnd=0;
  00A1    112E    CLRB	0x2E,2
57:               			}
58:               			OnOffFlag=0;
  00A2    13F0    CLRB	0x70,7
  00A3    28FF    JP	0xFF
59:               		}
60:               	}
61:               	else if(KeyPress&&KeyCnt>=250&&KeyInBuf==KeyPress&&!LockSta.LockEnd&&!LockSta.UnlockEnd)
  00A4    1C71    SNZB	0x71,0
  00A5    28E2    JP	0xE2
  00A6    3000    LDIA	0x0
  00A7    022D    SUBA	0x2D
  00A8    30FA    LDIA	0xFA
  00A9    1903    SZB	0x3,2
  00AA    022C    SUBA	0x2C
  00AB    1C03    SNZB	0x3,0
  00AC    28E2    JP	0xE2
  00AD    1C71    SNZB	0x71,0
  00AE    28B1    JP	0xB1
  00AF    3001    LDIA	0x1
  00B0    28B2    JP	0xB2
  00B1    3000    LDIA	0x0
  00B2    00F5    LD	0x75,A
  00B3    1EF0    SNZB	0x70,5
  00B4    28B7    JP	0xB7
  00B5    3001    LDIA	0x1
  00B6    28B8    JP	0xB8
  00B7    3000    LDIA	0x0
  00B8    0675    XORA	0x75
  00B9    1903    SZB	0x3,2
  00BA    192E    SZB	0x2E,2
  00BB    28E2    JP	0xE2
  00BC    1AAE    SZB	0x2E,5
  00BD    28E2    JP	0xE2
62:               	{
63:               		KeyCnt++;
  00BE    0AAC    INCR	0x2C
  00BF    1903    SZB	0x3,2
  00C0    0AAD    INCR	0x2D
64:               		if(KeyCnt>=1750)
  00C1    3006    LDIA	0x6
  00C2    022D    SUBA	0x2D
  00C3    30D6    LDIA	0xD6
  00C4    1903    SZB	0x3,2
  00C5    022C    SUBA	0x2C
  00C6    1C03    SNZB	0x3,0
  00C7    28FF    JP	0xFF
65:               		{
66:               			KeyCnt=1750;
  00C8    30D6    LDIA	0xD6
  00C9    00AC    LD	0x2C,A
  00CA    3006    LDIA	0x6
  00CB    00AD    LD	0x2D,A
67:               			LockSta.LockFlag=!LockSta.LockFlag;
  00CC    1003    CLRB	0x3,0
  00CD    1F2E    SNZB	0x2E,6
  00CE    1403    SETB	0x3,0
  00CF    1283    CLRB	0x3,5
  00D0    1303    CLRB	0x3,6
  00D1    1C03    SNZB	0x3,0
  00D2    28D5    JP	0xD5
  00D3    172E    SETB	0x2E,6
  00D4    28D6    JP	0xD6
  00D5    132E    CLRB	0x2E,6
68:               			if(LockSta.LockFlag)
  00D6    1F2E    SNZB	0x2E,6
  00D7    28DD    JP	0xDD
69:               			{
70:               				LockSta.LockStart=0;
  00D8    102E    CLRB	0x2E,0
71:               				LockSta.LockEnd=1;
  00D9    152E    SETB	0x2E,2
72:               				WorkFlag=0;
  00DA    11F1    CLRB	0x71,3
73:               				LEDWorkFlag=0;
  00DB    1370    CLRB	0x70,6
74:               			}
  00DC    28FF    JP	0xFF
75:               			else
76:               			{
77:               				LockSta.UnlockStart=0;
  00DD    11AE    CLRB	0x2E,3
78:               				LockSta.UnlockEnd=1;
  00DE    16AE    SETB	0x2E,5
79:               				WorkFlag=1;
  00DF    15F1    SETB	0x71,3
80:               				LEDWorkFlag=1;
  00E0    1770    SETB	0x70,6
  00E1    28FF    JP	0xFF
81:               			}
82:               		}
83:               	}
84:               	else if(!KeyPress||KeyInBuf!=KeyPress)
  00E2    1C71    SNZB	0x71,0
  00E3    28F2    JP	0xF2
  00E4    1C71    SNZB	0x71,0
  00E5    28E8    JP	0xE8
  00E6    3001    LDIA	0x1
  00E7    28E9    JP	0xE9
  00E8    3000    LDIA	0x0
  00E9    00F5    LD	0x75,A
  00EA    1EF0    SNZB	0x70,5
  00EB    28EE    JP	0xEE
  00EC    3001    LDIA	0x1
  00ED    28EF    JP	0xEF
  00EE    3000    LDIA	0x0
  00EF    0675    XORA	0x75
  00F0    1903    SZB	0x3,2
  00F1    28FF    JP	0xFF
85:               	{
86:               		KeyCnt=0;
  00F2    01AC    CLR	0x2C
  00F3    01AD    CLR	0x2D
87:               		LockSta.UnlockEnd=0;
  00F4    12AE    CLRB	0x2E,5
88:               		if(LockSta.LockEnd)
  00F5    1D2E    SNZB	0x2E,2
  00F6    28F9    JP	0xF9
89:               		{
90:               			LockSta.LockEnd=0;
  00F7    112E    CLRB	0x2E,2
91:               			LockSta.UnlockFail=1;
  00F8    162E    SETB	0x2E,4
92:               		}
93:               		if(LockSta.UnlockStart)
  00F9    1DAE    SNZB	0x2E,3
  00FA    28FD    JP	0xFD
94:               		{
95:               			LockSta.UnlockStart=0;
  00FB    11AE    CLRB	0x2E,3
96:               			LockSta.UnlockFail=1;
  00FC    162E    SETB	0x2E,4
97:               		}
98:               		if(LockSta.LockStart)
  00FD    182E    SZB	0x2E,0
99:               		{
100:              			LockSta.LockStart=0;
  00FE    102E    CLRB	0x2E,0
101:              		}
102:              	}
103:              	KeyInBuf=KeyPress;
  00FF    12F0    CLRB	0x70,5
  0100    1871    SZB	0x71,0
  0101    16F0    SETB	0x70,5
104:              
105:              	if(!PIN_USB)
  0102    1283    CLRB	0x3,5
  0103    1303    CLRB	0x3,6
  0104    1B85    SZB	0x5,7
  0105    2908    JP	0x108
106:              	{
107:              		USBLink=1;
  0106    1670    SETB	0x70,4
108:              	}
  0107    2909    JP	0x109
109:              	else
110:              	{
111:              		USBLink=0;
  0108    1270    CLRB	0x70,4
112:              	}
113:              	/*USB判断*/
114:              	if(USBLink&&!IovFlag)
  0109    1A70    SZB	0x70,4
  010A    1AF1    SZB	0x71,5
  010B    290F    JP	0x10F
115:              	{
116:              		USBFlag=1;
  010C    1671    SETB	0x71,4
117:              		LockSta.LockFlag=0;
  010D    132E    CLRB	0x2E,6
118:              	}
  010E    0008    RET
119:              	else if(!USBLink)
  010F    1E70    SNZB	0x70,4
120:              	{
121:              		USBFlag=0;
  0110    1271    CLRB	0x71,4
  0111    0008    RET
122:              	}
123:              }
124:              
---- C:\Users\Administrator\Desktop\project\K13-01\code\LED.c ----------------------------------------------------------------------
1:                #include "LED.h"
2:                
3:                uint8 NumbArr[10]={0x77,0x24,0x5D,0X6D,0X2E,0X6B,0X7B,0X25,0X7F,0X2F};//数字
4:                uint8 HideNumbArr[11]={0,0x40,0x70,0x78,0x7E,0x7F,0x3F,0X0F,0x07,0X01,0};//自下往上扫描
5:                uint16 OffHideNumbArr[7]={0,0x12,0x5B,0X7F,0x97F,0x2DFF,0x3FFF};
6:                // const uint8 LEDSeg1[16][2]=
7:                // {
8:                //     {1,0},{2,1},{2,0},{3,1},{0,1},{3,0},{4,0},//上到下，左到右排序,左数字
9:                //     {0,2},{1,3},{1,2},{2,3},{0,3},{3,2},{4,2},//上到下，左到右排序,右数字
10:               //     {0,4},{1,4}//感叹号、锁
11:               // };
12:               const uint8 LEDSeg1[16]={1,2,2,3,0,3,4,0,1,1,2,0,3,4,0,1};
13:               uint8 LEDSeg2[16]={0,1,0,1,1,0,0,2,3,2,3,3,2,2,4,4};
14:               uint16 LedIndex=0;
15:               uint8 LEDArrMap[5]={0xff,0xff,0xEf,0xff,0xff};
16:               
17:               void LEDScan()
18:               {
19:                   static uint8 LEDScanIndex=0;
20:               
21:                   Pin_LED1_CFG(IN,0);
  02B6    1683    SETB	0x3,5
  02B7    1686    SETB	0x6,5
  02B8    1295    CLRB	0x15,5
22:                   Pin_LED2_CFG(IN,0);
  02B9    1606    SETB	0x6,4
  02BA    1215    CLRB	0x15,4
23:                   Pin_LED3_CFG(IN,0);
  02BB    1586    SETB	0x6,3
  02BC    1195    CLRB	0x15,3
24:                   Pin_LED4_CFG(IN,0);
  02BD    1587    SETB	0x7,3
  02BE    1703    SETB	0x3,6
  02BF    118F    CLRB	0xF,3
25:                   Pin_LED5_CFG(IN,0);
  02C0    1303    CLRB	0x3,6
  02C1    1507    SETB	0x7,2
  02C2    1703    SETB	0x3,6
  02C3    110F    CLRB	0xF,2
  02C4    0000    NOP
  02C5    0000    NOP
26:                   asm("nop");	asm("nop");
27:               
28:                   switch(LEDScanIndex)
  02C6    2B1C    JP	0x31C
29:                   {
30:                       case 0:
31:                       if(LEDArrMap[0]&0x02) 
  02C7    1CE4    SNZB	0x64,1
  02C8    2ACA    JP	0x2CA
32:                       {
33:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  02C9    234B    CALL	0x34B
34:                       }
35:               		if(LEDArrMap[0]&0x04)  
  02CA    1D64    SNZB	0x64,2
  02CB    2ACD    JP	0x2CD
36:                       {
37:                           Pin_LED3_CFG(OUT,0);PIN_LED3=L ;
  02CC    2345    CALL	0x345
38:                       }
39:               		if(LEDArrMap[0]&0x08) 
  02CD    1DE4    SNZB	0x64,3
  02CE    2AD0    JP	0x2D0
40:                       {
41:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  02CF    2337    CALL	0x337
42:                       }
43:               		if(LEDArrMap[0]&0x10) 
  02D0    1E64    SNZB	0x64,4
  02D1    2AD3    JP	0x2D3
44:                       {
45:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  02D2    232F    CALL	0x32F
46:                       }
47:               		Pin_LED1_CFG(OUT,0);PIN_LED1=H ;
  02D3    1683    SETB	0x3,5
  02D4    1286    CLRB	0x6,5
  02D5    1295    CLRB	0x15,5
  02D6    1283    CLRB	0x3,5
  02D7    1686    SETB	0x6,5
48:                       break;
  02D8    2B29    JP	0x329
49:               
50:                       case 1:
51:                       if(LEDArrMap[1]&0x01)
  02D9    1C65    SNZB	0x65,0
  02DA    2ADC    JP	0x2DC
52:                       {
53:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  02DB    233F    CALL	0x33F
54:                       } 
55:                       if(LEDArrMap[1]&0x04) 
  02DC    1D65    SNZB	0x65,2
  02DD    2ADF    JP	0x2DF
56:                       {
57:                           Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  02DE    2345    CALL	0x345
58:                       }
59:                       if(LEDArrMap[1]&0x08) 
  02DF    1DE5    SNZB	0x65,3
  02E0    2AE2    JP	0x2E2
60:                       {
61:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  02E1    2337    CALL	0x337
62:                       }
63:                       if(LEDArrMap[1]&0x10)
  02E2    1E65    SNZB	0x65,4
  02E3    2AE5    JP	0x2E5
64:                       {
65:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  02E4    232F    CALL	0x32F
66:                       } 
67:                       Pin_LED2_CFG(OUT,0); PIN_LED2=H ;
  02E5    1683    SETB	0x3,5
  02E6    1206    CLRB	0x6,4
  02E7    1215    CLRB	0x15,4
  02E8    1283    CLRB	0x3,5
  02E9    1606    SETB	0x6,4
68:                       break;
  02EA    2B29    JP	0x329
69:               
70:                       case 2:
71:                       if(LEDArrMap[2]&0x01) 
  02EB    1C66    SNZB	0x66,0
  02EC    2AEE    JP	0x2EE
72:                       {
73:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  02ED    233F    CALL	0x33F
74:                       }
75:               		if(LEDArrMap[2]&0x02) 
  02EE    1CE6    SNZB	0x66,1
  02EF    2AF1    JP	0x2F1
76:                       {
77:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  02F0    234B    CALL	0x34B
78:                       }
79:               		if(LEDArrMap[2]&0x08) 
  02F1    1DE6    SNZB	0x66,3
  02F2    2AF4    JP	0x2F4
80:                       {
81:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  02F3    2337    CALL	0x337
82:                       }
83:               		if(LEDArrMap[2]&0x10) 
  02F4    1E66    SNZB	0x66,4
  02F5    2AF7    JP	0x2F7
84:                       {
85:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  02F6    232F    CALL	0x32F
86:                       }
87:               		Pin_LED3_CFG(OUT,0);PIN_LED3=H ;
  02F7    1683    SETB	0x3,5
  02F8    1186    CLRB	0x6,3
  02F9    1195    CLRB	0x15,3
  02FA    1283    CLRB	0x3,5
  02FB    1586    SETB	0x6,3
88:                       break;
  02FC    2B29    JP	0x329
89:               
90:                       case 3:
91:                       if(LEDArrMap[3]&0x01)
  02FD    1C67    SNZB	0x67,0
  02FE    2B00    JP	0x300
92:                       {
93:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  02FF    233F    CALL	0x33F
94:                       }
95:               		if(LEDArrMap[3]&0x02)
  0300    1CE7    SNZB	0x67,1
  0301    2B03    JP	0x303
96:                       {
97:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  0302    234B    CALL	0x34B
98:                       }
99:               		if(LEDArrMap[3]&0x04)
  0303    1D67    SNZB	0x67,2
  0304    2B06    JP	0x306
100:                      {
101:                          Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  0305    2345    CALL	0x345
102:                      }
103:              		Pin_LED4_CFG(OUT,0);PIN_LED4=H ;
  0306    1683    SETB	0x3,5
  0307    1187    CLRB	0x7,3
  0308    1703    SETB	0x3,6
  0309    118F    CLRB	0xF,3
  030A    1283    CLRB	0x3,5
  030B    1303    CLRB	0x3,6
  030C    1587    SETB	0x7,3
104:                      break;
  030D    2B29    JP	0x329
105:              
106:                      case 4:
107:                      if(LEDArrMap[4]&0x01)
  030E    1C68    SNZB	0x68,0
  030F    2B11    JP	0x311
108:                      {
109:                          Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  0310    233F    CALL	0x33F
110:                      }
111:              		if(LEDArrMap[4]&0x04)
  0311    1D68    SNZB	0x68,2
  0312    2B14    JP	0x314
112:                      {
113:                          Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  0313    2345    CALL	0x345
114:                      }
115:                      Pin_LED5_CFG(OUT,0);PIN_LED5=H ;
  0314    1683    SETB	0x3,5
  0315    1107    CLRB	0x7,2
  0316    1703    SETB	0x3,6
  0317    110F    CLRB	0xF,2
  0318    1283    CLRB	0x3,5
  0319    1303    CLRB	0x3,6
  031A    1507    SETB	0x7,2
116:                  }
  031B    2B29    JP	0x329
  031C    1283    CLRB	0x3,5
  031D    1303    CLRB	0x3,6
  031E    0839    LD	A,0x39
  031F    0084    LD	0x4,A
  0320    3005    LDIA	0x5
  0321    0204    SUBA	0x4
  0322    1803    SZB	0x3,0
  0323    2B29    JP	0x329
  0324    3006    LDIA	0x6
  0325    008A    LD	0xA,A
  0326    30F6    LDIA	0xF6
  0327    0704    ADDA	0x4
  0328    0082    LD	0x2,A
  0329    3005    LDIA	0x5
117:                  LEDScanIndex++;
  032A    0AB9    INCR	0x39
118:                  if(LEDScanIndex>=5)
  032B    0239    SUBA	0x39
  032C    1803    SZB	0x3,0
119:                  {
120:                      LEDScanIndex=0;
  032D    01B9    CLR	0x39
  032E    0008    RET
121:                  }
122:              }
123:              
124:              void DisplayIcon(uint16 index)
125:              {
126:                  uint8 i=0;
127:                  uint16 Mask=0x01;
  0559    01CA    CLR	0x4A
  055A    0ACA    INCR	0x4A
  055B    01CB    CLR	0x4B
128:              
129:                  for(i=0;i<16;i++)
  055C    01CC    CLR	0x4C
130:                  {
131:                      if(index&Mask)
  055D    084A    LD	A,0x4A
  055E    0575    ANDA	0x75
  055F    00F7    LD	0x77,A
  0560    084B    LD	A,0x4B
  0561    0576    ANDA	0x76
  0562    00F8    LD	0x78,A
  0563    0477    ORA	0x77
132:                      {
133:                          LEDArrMap[LEDSeg1[i]]|=(1<<LEDSeg2[i]);
  0564    3001    LDIA	0x1
  0565    00F7    LD	0x77,A
  0566    1903    SZB	0x3,2
  0567    2D70    JP	0x570
  0568    2581    CALL	0x581
  0569    258E    CALL	0x58E
  056A    2700    CALL	0x700
  056B    3E64    ADDIA	0x64
  056C    0084    LD	0x4,A
  056D    0878    LD	A,0x78
  056E    0480    ORR	0x0
134:                      }
  056F    2D78    JP	0x578
135:                      else
136:                      {
137:                          LEDArrMap[LEDSeg1[i]]&=~(1<<LEDSeg2[i]);
  0570    2581    CALL	0x581
  0571    3AFF    XORIA	0xFF
  0572    258E    CALL	0x58E
  0573    2700    CALL	0x700
  0574    3E64    ADDIA	0x64
  0575    0084    LD	0x4,A
  0576    0878    LD	A,0x78
  0577    0580    ANDR	0x0
  0578    3010    LDIA	0x10
138:                      }
139:                      
140:                      Mask<<=1;
  0579    1003    CLRB	0x3,0
  057A    0DCA    RLCR	0x4A
  057B    0DCB    RLCR	0x4B
  057C    0ACC    INCR	0x4C
  057D    024C    SUBA	0x4C
  057E    1803    SZB	0x3,0
  057F    0008    RET
  0580    2D5D    JP	0x55D
141:                  }
142:              }
143:              
144:              void DisplayPro()
145:              {
146:                  LedIndex=0;
  0753    01AA    CLR	0x2A
  0754    01AB    CLR	0x2B
147:                  WorkLedPro();
  0755    2351    CALL	0x351
148:                  USBLedPro();
  0756    23CC    CALL	0x3CC
149:                  LockPro();
  0757    2515    CALL	0x515
150:                  ErrPro();
  0758    2716    CALL	0x716
151:                  DisplayIcon(LedIndex);
  0759    082B    LD	A,0x2B
  075A    00F6    LD	0x76,A
  075B    082A    LD	A,0x2A
  075C    00F5    LD	0x75,A
  075D    2D59    JP	0x559
152:              }
153:              
154:              void USBLedPro()
155:              {
156:                  static uint8 index=0;
157:                  static uint8 cnt=0;
158:              
159:                  if(USBFlag&&!WorkFlag&&!OnOffFlag)//充电正常
  03CC    1A71    SZB	0x71,4
  03CD    19F1    SZB	0x71,3
  03CE    2C1E    JP	0x41E
  03CF    1BF0    SZB	0x70,7
  03D0    2C1E    JP	0x41E
  03D1    3028    LDIA	0x28
160:                  {
161:                      cnt++;
  03D2    0AB7    INCR	0x37
162:                      if(cnt>=40)
  03D3    0237    SUBA	0x37
  03D4    1C03    SNZB	0x3,0
  03D5    2BDC    JP	0x3DC
  03D6    300B    LDIA	0xB
163:                      {
164:                          cnt=0;
  03D7    01B7    CLR	0x37
165:                          index++;
  03D8    0AB8    INCR	0x38
166:                          if(index>=11)
  03D9    0238    SUBA	0x38
  03DA    1803    SZB	0x3,0
167:                          {
168:                              index=0;
  03DB    01B8    CLR	0x38
169:                          }
170:                      }
171:                      if(BatPercent<99)
  03DC    3063    LDIA	0x63
  03DD    0243    SUBA	0x43
172:                      {
173:                          LedIndex=NumbArr[BatPercent/10];
  03DE    300A    LDIA	0xA
  03DF    1803    SZB	0x3,0
  03E0    2C07    JP	0x407
  03E1    00F5    LD	0x75,A
  03E2    0843    LD	A,0x43
  03E3    268E    CALL	0x68E
174:                          LedIndex|=((uint16)NumbArr[BatPercent%10]&~HideNumbArr[index])<<7;
  03E4    2421    CALL	0x421
  03E5    2672    CALL	0x672
  03E6    3EC9    ADDIA	0xC9
  03E7    0084    LD	0x4,A
  03E8    0800    LD	A,0x0
  03E9    00CA    LD	0x4A,A
  03EA    0838    LD	A,0x38
  03EB    3EBE    ADDIA	0xBE
  03EC    0084    LD	0x4,A
  03ED    0900    COMA	0x0
  03EE    054A    ANDA	0x4A
  03EF    00CB    LD	0x4B,A
  03F0    3007    LDIA	0x7
  03F1    01CC    CLR	0x4C
  03F2    00FF    LD	0x7F,A
  03F3    1003    CLRB	0x3,0
  03F4    0DCB    RLCR	0x4B
  03F5    0DCC    RLCR	0x4C
  03F6    0BFF    SZDECR	0x7F
  03F7    2BF3    JP	0x3F3
  03F8    084B    LD	A,0x4B
  03F9    04AA    ORR	0x2A
  03FA    084C    LD	A,0x4C
  03FB    04AB    ORR	0x2B
175:                          LedIndex&=~HideNumbArr[index];
  03FC    0838    LD	A,0x38
  03FD    3EBE    ADDIA	0xBE
  03FE    0084    LD	0x4,A
  03FF    0900    COMA	0x0
  0400    00CA    LD	0x4A,A
  0401    01CB    CLR	0x4B
  0402    09CB    COMR	0x4B
  0403    05AA    ANDR	0x2A
  0404    084B    LD	A,0x4B
  0405    05AB    ANDR	0x2B
176:                      }
  0406    0008    RET
177:                      else
178:                      {
179:                          index=0;
  0407    01B8    CLR	0x38
180:                          LedIndex=NumbArr[BatPercent/10];
  0408    00F5    LD	0x75,A
  0409    0843    LD	A,0x43
  040A    268E    CALL	0x68E
181:                          LedIndex|=NumbArr[BatPercent%10]<<7;
  040B    2421    CALL	0x421
  040C    2672    CALL	0x672
  040D    3EC9    ADDIA	0xC9
  040E    0084    LD	0x4,A
  040F    0800    LD	A,0x0
  0410    00CA    LD	0x4A,A
  0411    3007    LDIA	0x7
  0412    01CB    CLR	0x4B
  0413    00FF    LD	0x7F,A
  0414    1003    CLRB	0x3,0
  0415    0DCA    RLCR	0x4A
  0416    0DCB    RLCR	0x4B
  0417    0BFF    SZDECR	0x7F
  0418    2C14    JP	0x414
  0419    084A    LD	A,0x4A
  041A    04AA    ORR	0x2A
  041B    084B    LD	A,0x4B
  041C    04AB    ORR	0x2B
  041D    0008    RET
182:                      }
183:                      
184:                  }
185:                  else
186:                  {
187:                      index=0;
  041E    01B8    CLR	0x38
188:                      cnt=0;
  041F    01B7    CLR	0x37
  0420    0008    RET
189:                  }
190:              }
191:              
192:              void WorkLedPro()
193:              {
194:                  static int8 LedSwitchCnt=0;
195:                  static bit LedSwitchFlag=0;
196:                  static int8 index=0;
197:                  static uint8 cnt=0;
198:                  static bit dir=0;
199:                  if(LEDWorkFlag&&!OnOffFlag&&!LockSta.LockFlag&&!LockSta.LockStart&&(!USBFlag||WorkFlag))
  0351    1B70    SZB	0x70,6
  0352    1BF0    SZB	0x70,7
  0353    2B75    JP	0x375
  0354    1F2E    SNZB	0x2E,6
  0355    182E    SZB	0x2E,0
  0356    2B75    JP	0x375
  0357    1E71    SNZB	0x71,4
  0358    2B5B    JP	0x35B
  0359    1DF1    SNZB	0x71,3
  035A    2B75    JP	0x375
200:                  {
201:                      if(BatPercent<=10&&WorkFlag)
  035B    300B    LDIA	0xB
  035C    0243    SUBA	0x43
  035D    1C03    SNZB	0x3,0
  035E    1DF1    SNZB	0x71,3
  035F    2B69    JP	0x369
  0360    3050    LDIA	0x50
202:                      {
203:                          LedSwitchCnt++;
  0361    0AB6    INCR	0x36
204:                          if(LedSwitchCnt>=80)
  0362    0236    SUBA	0x36
  0363    1C03    SNZB	0x3,0
  0364    2B6B    JP	0x36B
  0365    3008    LDIA	0x8
205:                          {
206:                              LedSwitchCnt=0;
  0366    01B6    CLR	0x36
207:                              LedSwitchFlag=!LedSwitchFlag;
  0367    06F0    XORR	0x70
  0368    2B6B    JP	0x36B
208:                          }
209:                      }
210:                      else
211:                      {
212:                          LedSwitchCnt=0;
  0369    01B6    CLR	0x36
213:                          LedSwitchFlag=1;
  036A    15F0    SETB	0x70,3
214:                      }
215:                      if(LedSwitchFlag)
  036B    1DF0    SNZB	0x70,3
  036C    0008    RET
216:                      {
217:                          LedIndex=NumbArr[BatPercent/10];
  036D    300A    LDIA	0xA
  036E    00F5    LD	0x75,A
  036F    0843    LD	A,0x43
  0370    268E    CALL	0x68E
218:                          LedIndex|=(uint16)NumbArr[BatPercent%10]<<7;
  0371    2421    CALL	0x421
  0372    2672    CALL	0x672
  0373    23AF    CALL	0x3AF
  0374    0008    RET
219:                      }
220:                  }
221:                  else if(OnOffFlag)
  0375    1FF0    SNZB	0x70,7
  0376    0008    RET
  0377    3028    LDIA	0x28
222:                  {
223:                      cnt++;
  0378    0AB4    INCR	0x34
224:                      if(cnt>=40)
  0379    0234    SUBA	0x34
  037A    1C03    SNZB	0x3,0
  037B    2B8A    JP	0x38A
  037C    3007    LDIA	0x7
225:                      {
226:                          cnt=0;
  037D    01B4    CLR	0x34
227:                          index++;
  037E    0AB5    INCR	0x35
228:                          if(index>=7)
  037F    0235    SUBA	0x35
  0380    1C03    SNZB	0x3,0
  0381    2B8A    JP	0x38A
229:                          {
230:                              if(dir)
  0382    1D70    SNZB	0x70,2
  0383    2B87    JP	0x387
231:                              {
232:                                  OnOffFlag=0;
  0384    13F0    CLRB	0x70,7
233:                                  WorkMin=0;
  0385    01FA    CLR	0x7A
  0386    0008    RET
234:                                  return;
235:                              }
236:                              dir=!dir;
  0387    3004    LDIA	0x4
  0388    06F0    XORR	0x70
237:                              index=0;
  0389    01B5    CLR	0x35
238:                          }
239:                      }
240:                      if(!dir)
  038A    1970    SZB	0x70,2
  038B    2B98    JP	0x398
241:                      {
242:                          LedIndex=NumbArr[BatPercent/10];
  038C    300A    LDIA	0xA
  038D    00F5    LD	0x75,A
  038E    0843    LD	A,0x43
  038F    268E    CALL	0x68E
243:                          LedIndex|=(uint16)NumbArr[BatPercent%10]<<7;
  0390    2421    CALL	0x421
  0391    2672    CALL	0x672
  0392    23AF    CALL	0x3AF
244:                          LedIndex&=~OffHideNumbArr[index];
  0393    1003    CLRB	0x3,0
  0394    0D35    RLCA	0x35
  0395    3EB0    ADDIA	0xB0
  0396    0084    LD	0x4,A
245:                      }
  0397    2BC0    JP	0x3C0
246:                      else
247:                      {
248:                          LedIndex=NumbArr[WorkMin/10];
  0398    300A    LDIA	0xA
  0399    00F5    LD	0x75,A
  039A    087A    LD	A,0x7A
  039B    268E    CALL	0x68E
  039C    3EC9    ADDIA	0xC9
  039D    0084    LD	0x4,A
  039E    1383    CLRB	0x3,7
  039F    0800    LD	A,0x0
  03A0    00AA    LD	0x2A,A
  03A1    300A    LDIA	0xA
  03A2    01AB    CLR	0x2B
249:                          LedIndex|=(uint16)NumbArr[WorkMin%10]<<7;
  03A3    00F5    LD	0x75,A
  03A4    087A    LD	A,0x7A
  03A5    2672    CALL	0x672
  03A6    23AF    CALL	0x3AF
250:                          LedIndex&=~OffHideNumbArr[6-index];
  03A7    30FE    LDIA	0xFE
  03A8    00F5    LD	0x75,A
  03A9    0835    LD	A,0x35
  03AA    2745    CALL	0x745
  03AB    3EBC    ADDIA	0xBC
  03AC    0084    LD	0x4,A
  03AD    1383    CLRB	0x3,7
  03AE    2BC0    JP	0x3C0
251:                      }
252:                  }
253:              }
254:              
255:              void LockPro()
256:              {
257:                  static uint8 SwitchCnt=0,LockSwitchCnt=0;
258:                  static uint8 Ledcnt=0;
259:                  static bit LedSwitchFlag=0;
260:                  if(!USBFlag)
  0515    1A71    SZB	0x71,4
  0516    0008    RET
261:                  {
262:                      if(LockSta.LockStart||LockSta.UnlockStart)
  0517    182E    SZB	0x2E,0
  0518    2D1B    JP	0x51B
  0519    1DAE    SNZB	0x2E,3
  051A    2D3D    JP	0x53D
  051B    3064    LDIA	0x64
263:                      {
264:                          SwitchCnt++;
  051C    0AB3    INCR	0x33
265:                          if(SwitchCnt>=100)
  051D    0233    SUBA	0x33
  051E    1C03    SNZB	0x3,0
  051F    2D25    JP	0x525
266:                          {
267:                              SwitchCnt=0;
  0520    01B3    CLR	0x33
268:                              if(LockNumb>0)
  0521    083B    LD	A,0x3B
  0522    1903    SZB	0x3,2
  0523    2D25    JP	0x525
269:                              {
270:                                  LockNumb--;
  0524    03BB    DECR	0x3B
271:                              }
272:                          }
273:                          LedIndex=NumbArr[0];
  0525    1683    SETB	0x3,5
  0526    0849    LD	A,0x49
  0527    1283    CLRB	0x3,5
  0528    00AA    LD	0x2A,A
  0529    01AB    CLR	0x2B
274:                          LedIndex|=(uint16)NumbArr[LockNumb+1]<<7;
  052A    083B    LD	A,0x3B
  052B    3ECA    ADDIA	0xCA
  052C    0084    LD	0x4,A
  052D    1383    CLRB	0x3,7
  052E    0800    LD	A,0x0
  052F    00F5    LD	0x75,A
  0530    3007    LDIA	0x7
  0531    01F6    CLR	0x76
  0532    00FF    LD	0x7F,A
  0533    1003    CLRB	0x3,0
  0534    0DF5    RLCR	0x75
  0535    0DF6    RLCR	0x76
  0536    0BFF    SZDECR	0x7F
  0537    2D33    JP	0x533
  0538    0875    LD	A,0x75
  0539    04AA    ORR	0x2A
  053A    0876    LD	A,0x76
  053B    04AB    ORR	0x2B
275:                      }
  053C    2D3E    JP	0x53E
276:                      else
277:                      {
278:                          SwitchCnt=0;
  053D    01B3    CLR	0x33
279:                      }
280:                      if(LockSta.LockEnd||LockSta.UnlockFail||LockSta.UnlockStart)
  053E    1D2E    SNZB	0x2E,2
  053F    1A2E    SZB	0x2E,4
  0540    2D43    JP	0x543
  0541    1DAE    SNZB	0x2E,3
  0542    2D56    JP	0x556
  0543    3023    LDIA	0x23
281:                      {
282:                          LockSwitchCnt++;
  0544    0AB2    INCR	0x32
283:                          if(LockSwitchCnt>=35)
  0545    0232    SUBA	0x32
  0546    1C03    SNZB	0x3,0
  0547    2D53    JP	0x553
  0548    3002    LDIA	0x2
284:                          {
285:                              LockSwitchCnt=0;
  0549    01B2    CLR	0x32
286:                              LedSwitchFlag=!LedSwitchFlag;
  054A    06F0    XORR	0x70
287:                              if(!LedSwitchFlag&&LockSta.UnlockFail)
  054B    1CF0    SNZB	0x70,1
  054C    1E2E    SNZB	0x2E,4
  054D    2D53    JP	0x553
  054E    3003    LDIA	0x3
288:                              {
289:                                  Ledcnt++;
  054F    0AB1    INCR	0x31
290:                                  if(Ledcnt>=3)
  0550    0231    SUBA	0x31
  0551    1803    SZB	0x3,0
291:                                  {
292:                                      LockSta.UnlockFail=0;
  0552    122E    CLRB	0x2E,4
293:                                  }
294:                              }
295:                          }
296:                          if(LedSwitchFlag)
  0553    18F0    SZB	0x70,1
297:                          {
298:                              LedIndex|=iconLock;
  0554    17AB    SETB	0x2B,7
  0555    0008    RET
299:                          }
300:                      }
301:                      else
302:                      {
303:                          Ledcnt=0;
  0556    01B1    CLR	0x31
304:                          LockSwitchCnt=0;
  0557    01B2    CLR	0x32
  0558    0008    RET
305:                      }
306:                  }
307:              }
308:              
309:              void ErrPro()
310:              {
311:                  static uint8 SwitchCnt=0;
312:                  static bit LedSwitchFlag=0;
313:                  if(IovFlag)
  0716    1EF1    SNZB	0x71,5
  0717    2F26    JP	0x726
  0718    3023    LDIA	0x23
314:                  {
315:                      SwitchCnt++;
  0719    0AB0    INCR	0x30
316:                      if(SwitchCnt>=35)
  071A    0230    SUBA	0x30
  071B    1C03    SNZB	0x3,0
  071C    2F20    JP	0x720
  071D    3001    LDIA	0x1
317:                      {
318:                          SwitchCnt=0;
  071E    01B0    CLR	0x30
319:                          LedSwitchFlag=!LedSwitchFlag;
  071F    06F0    XORR	0x70
320:              
321:                      }
322:                      if(LedSwitchFlag)
  0720    1C70    SNZB	0x70,0
  0721    0008    RET
323:                      {
324:                          LedIndex=iconErr;
  0722    3040    LDIA	0x40
  0723    01AA    CLR	0x2A
  0724    00AB    LD	0x2B,A
  0725    0008    RET
325:                      }
326:                  }
327:                  else
328:                  {
329:                      SwitchCnt=0;
  0726    01B0    CLR	0x30
  0727    0008    RET
330:                  }
331:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul8.c ----------------------------------------------------------------------
1:                // 8 x 8 bit multiplication with 8 bit result
2:                
3:                unsigned char
4:                __bmul(unsigned char multiplier, unsigned char multiplicand)
  0745    00F7    LD	0x77,A
  0746    01F6    CLR	0x76
  0747    0875    LD	A,0x75
  0748    1877    SZB	0x77,0
  0749    07F6    ADDR	0x76
  074A    1003    CLRB	0x3,0
  074B    0DF5    RLCR	0x75
  074C    1003    CLRB	0x3,0
  074D    0CF7    RRCR	0x77
  074E    0877    LD	A,0x77
  074F    1D03    SNZB	0x3,2
  0750    2F47    JP	0x747
  0751    0876    LD	A,0x76
  0752    0008    RET
5:                {
6:                	unsigned char product = 0;
7:                
8:                #if defined(__OPTIMIZE_SPEED__)
9:                
10:               	if(multiplier & 0x01)
11:               		product = (product + multiplicand) & 0xff;
12:               	multiplicand <<= 1;
13:               
14:               	if(multiplier & 0x02)
15:               		product = (product + multiplicand) & 0xff;
16:               	multiplicand <<= 1;
17:               
18:               	if(multiplier & 0x04)
19:               		product = (product + multiplicand) & 0xff;
20:               	multiplicand <<= 1;
21:               
22:               	if(multiplier & 0x08)
23:               		product = (product + multiplicand) & 0xff;
24:               	multiplicand <<= 1;
25:               
26:               	if(multiplier & 0x10)
27:               		product = (product + multiplicand) & 0xff;
28:               	multiplicand <<= 1;
29:               
30:               	if(multiplier & 0x20)
31:               		product = (product + multiplicand) & 0xff;
32:               	multiplicand <<= 1;
33:               
34:               	if(multiplier & 0x40)
35:               		product = (product + multiplicand) & 0xff;
36:               	multiplicand <<= 1;
37:               
38:               	if(multiplier & 0x80)
39:               		product = (product + multiplicand) & 0xff;
40:               
41:               #else
42:               	do {
43:               		if(multiplier & 1)
44:               			product += multiplicand;
45:               		multiplicand <<= 1;
46:               		multiplier >>= 1;
47:               	} while(multiplier != 0);
48:               
49:               #endif
50:               	return product;
51:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  0672    00F7    LD	0x77,A
  0673    3008    LDIA	0x8
  0674    00F8    LD	0x78,A
  0675    01F9    CLR	0x79
  0676    0877    LD	A,0x77
  0677    00F6    LD	0x76,A
  0678    3007    LDIA	0x7
  0679    1003    CLRB	0x3,0
  067A    0CF6    RRCR	0x76
  067B    3EFF    ADDIA	0xFF
  067C    1003    CLRB	0x3,0
  067D    1D03    SNZB	0x3,2
  067E    2E7A    JP	0x67A
  067F    0D79    RLCA	0x79
  0680    0476    ORA	0x76
  0681    00F9    LD	0x79,A
  0682    1003    CLRB	0x3,0
  0683    0DF7    RLCR	0x77
  0684    0875    LD	A,0x75
  0685    0279    SUBA	0x79
  0686    1C03    SNZB	0x3,0
  0687    2E8A    JP	0x68A
  0688    0875    LD	A,0x75
  0689    02F9    SUBR	0x79
  068A    0BF8    SZDECR	0x78
  068B    2E76    JP	0x676
  068C    0879    LD	A,0x79
  068D    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  068E    00F6    LD	0x76,A
  068F    01F8    CLR	0x78
  0690    0875    LD	A,0x75
  0691    1903    SZB	0x3,2
  0692    2EA7    JP	0x6A7
  0693    01F7    CLR	0x77
  0694    0AF7    INCR	0x77
  0695    1BF5    SZB	0x75,7
  0696    2E9A    JP	0x69A
  0697    1003    CLRB	0x3,0
  0698    0DF5    RLCR	0x75
  0699    2E94    JP	0x694
  069A    1003    CLRB	0x3,0
  069B    0DF8    RLCR	0x78
  069C    0875    LD	A,0x75
  069D    0276    SUBA	0x76
  069E    1C03    SNZB	0x3,0
  069F    2EA4    JP	0x6A4
  06A0    0875    LD	A,0x75
  06A1    02F6    SUBR	0x76
  06A2    1478    SETB	0x78,0
  06A3    1003    CLRB	0x3,0
  06A4    0CF5    RRCR	0x75
  06A5    0BF7    SZDECR	0x77
  06A6    2E9A    JP	0x69A
  06A7    0878    LD	A,0x78
  06A8    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul32.c ----------------------------------------------------------------------
1:                // 32 x 32 bit multiplication with 32 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned long
15:               __lmul(unsigned long multiplier, unsigned long multiplicand)
  05C6    01F5    CLR	0x75
  05C7    01F6    CLR	0x76
  05C8    01F7    CLR	0x77
  05C9    01F8    CLR	0x78
  05CA    1C4A    SNZB	0x4A,0
  05CB    2DE0    JP	0x5E0
  05CC    084E    LD	A,0x4E
  05CD    07F5    ADDR	0x75
  05CE    084F    LD	A,0x4F
  05CF    1103    CLRB	0x3,2
  05D0    1803    SZB	0x3,0
  05D1    3E01    ADDIA	0x1
  05D2    1D03    SNZB	0x3,2
  05D3    07F6    ADDR	0x76
  05D4    0850    LD	A,0x50
  05D5    1103    CLRB	0x3,2
  05D6    1803    SZB	0x3,0
  05D7    3E01    ADDIA	0x1
  05D8    1D03    SNZB	0x3,2
  05D9    07F7    ADDR	0x77
  05DA    0851    LD	A,0x51
  05DB    1103    CLRB	0x3,2
  05DC    1803    SZB	0x3,0
  05DD    3E01    ADDIA	0x1
  05DE    1D03    SNZB	0x3,2
  05DF    07F8    ADDR	0x78
  05E0    1003    CLRB	0x3,0
  05E1    0DCE    RLCR	0x4E
  05E2    0DCF    RLCR	0x4F
  05E3    0DD0    RLCR	0x50
  05E4    0DD1    RLCR	0x51
  05E5    1003    CLRB	0x3,0
  05E6    0CCD    RRCR	0x4D
  05E7    0CCC    RRCR	0x4C
  05E8    0CCB    RRCR	0x4B
  05E9    0CCA    RRCR	0x4A
  05EA    084D    LD	A,0x4D
  05EB    044C    ORA	0x4C
  05EC    044B    ORA	0x4B
  05ED    044A    ORA	0x4A
  05EE    1D03    SNZB	0x3,2
  05EF    2DCA    JP	0x5CA
  05F0    0878    LD	A,0x78
  05F1    00CD    LD	0x4D,A
  05F2    0877    LD	A,0x77
  05F3    00CC    LD	0x4C,A
  05F4    0876    LD	A,0x76
  05F5    00CB    LD	0x4B,A
  05F6    0875    LD	A,0x75
  05F7    00CA    LD	0x4A,A
  05F8    0008    RET
16:               {
17:               	unsigned long product;
18:               
19:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:               #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:               #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:               
24:               #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:               	{
26:               
27:               #define USE_SHRINK
28:               
29:               /*
30:               a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                            a  b  c  d
32:               *            e  f  g  h
33:               -----------------------
34:                          |         dh
35:                          |      ch  0
36:                          |   bh  0  0
37:                          |ah  0  0  0
38:                          |      dg  0
39:                          |   cg  0  0
40:                          |bg  0  0  0
41:                        ag| 0  0  0  0 (we ignore this intermediate product
42:                                        because it does not affect the low 32 bits of the result)
43:                          |   df  0  0
44:                          |cf  0  0  0
45:                        bf| 0  0  0  0 (ignore)
46:                     af  0| 0  0  0  0 (ignore)
47:                          |de  0  0  0
48:                        ce| 0  0  0  0 (ignore)
49:                     be  0| 0  0  0  0 (ignore)
50:               +  ae  0  0| 0  0  0  0 (ignore)
51:               =======================
52:                */
53:               		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:               
55:               #if defined(USE_MASKS)
56:               		product += ((unsigned long)
57:               			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:               			     +
59:               			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:               			<< 8;
61:               
62:               		product += ((unsigned long)
63:               			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:               			    +
65:               			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:               			    +
67:               			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:               			<< 16;
69:               
70:               		/* cast to smaller type to avoid adding high bits just to discard */
71:               		product += ((unsigned long)
72:               			    (unsigned char)
73:               			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:               			    +
75:               			    (unsigned char)
76:               			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:               			    +
78:               			    (unsigned char)
79:               			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:               			    +
81:               			    (unsigned char)
82:               			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:               			<< 24;
84:               
85:               #elif defined(USE_SHRINK)
86:               		/* add direct to upper bytes, rather than shift and add all bytes */
87:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:               			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:               			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:               
92:               
93:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:               			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:               			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:               			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:               
100:              		*(((unsigned char*)&product)+3) +=
101:              			(unsigned char)
102:              			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:              		*(((unsigned char*)&product)+3) +=
104:              			(unsigned char)
105:              			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:              		*(((unsigned char*)&product)+3) +=
107:              			(unsigned char)
108:              			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:              		*(((unsigned char*)&product)+3) +=
110:              			(unsigned char)
111:              			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:              
113:              #else
114:              #error No method chosen
115:              #endif
116:              	}
117:              #else
118:              
119:              	product = 0;
120:              	do {
121:              		if(multiplier & 1)
122:              			product += multiplicand;
123:              		multiplicand <<= 1;
124:              		multiplier >>= 1;
125:              	} while(multiplier != 0);
126:              
127:              #endif
128:              	return product;
129:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lldiv.c ----------------------------------------------------------------------
1:                // long unsigned unsigned division
2:                
3:                unsigned long int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lldiv(unsigned long int divisor, unsigned long int dividend)
  04CD    01DA    CLR	0x5A
  04CE    01DB    CLR	0x5B
  04CF    01DC    CLR	0x5C
  04D0    01DD    CLR	0x5D
  04D1    0855    LD	A,0x55
  04D2    0454    ORA	0x54
  04D3    0453    ORA	0x53
  04D4    0452    ORA	0x52
  04D5    1903    SZB	0x3,2
  04D6    2D0C    JP	0x50C
  04D7    01DE    CLR	0x5E
  04D8    0ADE    INCR	0x5E
  04D9    1BD5    SZB	0x55,7
  04DA    2CE1    JP	0x4E1
  04DB    1003    CLRB	0x3,0
  04DC    0DD2    RLCR	0x52
  04DD    0DD3    RLCR	0x53
  04DE    0DD4    RLCR	0x54
  04DF    0DD5    RLCR	0x55
  04E0    2CD8    JP	0x4D8
  04E1    1003    CLRB	0x3,0
  04E2    0DDA    RLCR	0x5A
  04E3    0DDB    RLCR	0x5B
  04E4    0DDC    RLCR	0x5C
  04E5    0DDD    RLCR	0x5D
  04E6    0855    LD	A,0x55
  04E7    0259    SUBA	0x59
  04E8    1D03    SNZB	0x3,2
  04E9    2CF4    JP	0x4F4
  04EA    0854    LD	A,0x54
  04EB    0258    SUBA	0x58
  04EC    1D03    SNZB	0x3,2
  04ED    2CF4    JP	0x4F4
  04EE    0853    LD	A,0x53
  04EF    0257    SUBA	0x57
  04F0    1D03    SNZB	0x3,2
  04F1    2CF4    JP	0x4F4
  04F2    0852    LD	A,0x52
  04F3    0256    SUBA	0x56
  04F4    1C03    SNZB	0x3,0
  04F5    2D06    JP	0x506
  04F6    0852    LD	A,0x52
  04F7    02D6    SUBR	0x56
  04F8    0853    LD	A,0x53
  04F9    1C03    SNZB	0x3,0
  04FA    0F53    SZINCA	0x53
  04FB    02D7    SUBR	0x57
  04FC    0854    LD	A,0x54
  04FD    1C03    SNZB	0x3,0
  04FE    0F54    SZINCA	0x54
  04FF    02D8    SUBR	0x58
  0500    0855    LD	A,0x55
  0501    1C03    SNZB	0x3,0
  0502    0F55    SZINCA	0x55
  0503    02D9    SUBR	0x59
  0504    145A    SETB	0x5A,0
  0505    1003    CLRB	0x3,0
  0506    0CD5    RRCR	0x55
  0507    0CD4    RRCR	0x54
  0508    0CD3    RRCR	0x53
  0509    0CD2    RRCR	0x52
  050A    0BDE    SZDECR	0x5E
  050B    2CE1    JP	0x4E1
  050C    085D    LD	A,0x5D
  050D    00D5    LD	0x55,A
  050E    085C    LD	A,0x5C
  050F    00D4    LD	0x54,A
  0510    085B    LD	A,0x5B
  0511    00D3    LD	0x53,A
  0512    085A    LD	A,0x5A
  0513    00D2    LD	0x52,A
  0514    0008    RET
7:                #else
8:                __lldiv(unsigned long int dividend, unsigned long int divisor)
9:                #endif
10:               {
11:               	unsigned long int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x80000000UL) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\even.c ----------------------------------------------------------------------
1:                #include "even.h"
2:                
3:                uint8 cnt2ms=0;
4:                uint8 cnt10ms=0;
5:                bit time2ms=0;
6:                bit time10ms=0;
7:                
8:                void interrupt Isr_Timer()
9:                {
10:                   TMR2IF = 0;
  06A9    1283    CLRB	0x3,5
  06AA    1303    CLRB	0x3,6
  06AB    108C    CLRB	0xC,1
  06AC    300A    LDIA	0xA
11:                   cnt2ms++;
  06AD    0ABE    INCR	0x3E
12:                   cnt10ms++;
  06AE    0ABD    INCR	0x3D
13:                   if(cnt2ms>=10)
  06AF    023E    SUBA	0x3E
  06B0    1C03    SNZB	0x3,0
  06B1    2EB5    JP	0x6B5
14:                   {
15:                       LEDScan();
  06B2    22B6    CALL	0x2B6
16:                       cnt2ms=0;
  06B3    01BE    CLR	0x3E
17:                       time2ms=1;
  06B4    1571    SETB	0x71,2
18:                   }
19:                   if(cnt10ms>=50)
  06B5    3032    LDIA	0x32
  06B6    023D    SUBA	0x3D
  06B7    1C03    SNZB	0x3,0
  06B8    2EBB    JP	0x6BB
20:                   {
21:                       cnt10ms=0;
  06B9    01BD    CLR	0x3D
22:                       time10ms=1;
  06BA    14F1    SETB	0x71,1
  06BB    0874    LD	A,0x74
  06BC    008A    LD	0xA,A
  06BD    0873    LD	A,0x73
  06BE    0084    LD	0x4,A
  06BF    0E72    SWAPA	0x72
  06C0    0083    LD	0x3,A
  06C1    0EFE    SWAPR	0x7E
  06C2    0E7E    SWAPA	0x7E
  06C3    0009    RETI
23:                   }
24:               }
25:               
26:               
27:               
28:               
29:               
30:               
31:               
32:               
33:               
34:               
35:               
36:               
---- stringtab ------------------------------------------------------------------
  0700    3007    LDIA	0x7
  0701    008A    LD	0xA,A
  0702    0804    LD	A,0x4
  0703    0A84    INCR	0x4
  0704    0782    ADDR	0x2
  0705    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    30D3    LDIA	0xD3
  000E    1383    CLRB	0x3,7
  000F    00FD    LD	0x7D,A
  0010    3005    LDIA	0x5
  0011    00FE    LD	0x7E,A
  0012    3093    LDIA	0x93
  0013    00FF    LD	0x7F,A
  0014    30A0    LDIA	0xA0
  0015    0084    LD	0x4,A
  0016    272C    CALL	0x72C
  0017    30FF    LDIA	0xFF
  0018    00E4    LD	0x64,A
  0019    00E5    LD	0x65,A
  001A    30EF    LDIA	0xEF
  001B    00E6    LD	0x66,A
  001C    30FF    LDIA	0xFF
  001D    00E7    LD	0x67,A
  001E    00E8    LD	0x68,A
  001F    30D2    LDIA	0xD2
  0020    00E9    LD	0x69,A
  0021    30F0    LDIA	0xF0
  0022    00EA    LD	0x6A,A
  0023    3020    LDIA	0x20
  0024    0084    LD	0x4,A
  0025    304A    LDIA	0x4A
  0026    2767    CALL	0x767
  0027    01FA    CLR	0x7A
  0028    01F0    CLR	0x70
  0029    01F1    CLR	0x71
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F2    LD	0x72,A
  0007    0804    LD	A,0x4
  0008    00F3    LD	0x73,A
  0009    080A    LD	A,0xA
  000A    00F4    LD	0x74,A
  000B    2EA9    JP	0x6A9
---- common_function ------------------------------------------------------------------
  0001    2C82    JP	0x482
  0002    2C87    JP	0x487
  0003    2C8C    JP	0x48C
  002A    0183    CLR	0x3
  002B    2F6F    JP	0x76F
  0112    0AAC    INCR	0x2C
  0113    1903    SZB	0x3,2
  0114    0AAD    INCR	0x2D
  0115    3000    LDIA	0x0
  0116    022D    SUBA	0x2D
  0117    0008    RET
  01D8    083F    LD	A,0x3F
  01D9    00CD    LD	0x4D,A
  01DA    01CE    CLR	0x4E
  01DB    084E    LD	A,0x4E
  01DC    0251    SUBA	0x51
  01DD    1D03    SNZB	0x3,2
  01DE    29E1    JP	0x1E1
  01DF    084D    LD	A,0x4D
  01E0    0250    SUBA	0x50
  01E1    083F    LD	A,0x3F
  01E2    0008    RET
  01E3    07D0    ADDR	0x50
  01E4    1803    SZB	0x3,0
  01E5    0AD1    INCR	0x51
  01E6    30FE    LDIA	0xFE
  01E7    07D1    ADDR	0x51
  01E8    0008    RET
  029B    0084    LD	0x4,A
  029C    1383    CLRB	0x3,7
  029D    0800    LD	A,0x0
  029E    00E0    LD	0x60,A
  029F    0A84    INCR	0x4
  02A0    0800    LD	A,0x0
  02A1    00E1    LD	0x61,A
  02A2    0860    LD	A,0x60
  02A3    00D2    LD	0x52,A
  02A4    0861    LD	A,0x61
  02A5    00D3    LD	0x53,A
  02A6    01D4    CLR	0x54
  02A7    01D5    CLR	0x55
  02A8    0823    LD	A,0x23
  02A9    00CD    LD	0x4D,A
  02AA    0822    LD	A,0x22
  02AB    00CC    LD	0x4C,A
  02AC    0821    LD	A,0x21
  02AD    00CB    LD	0x4B,A
  02AE    0820    LD	A,0x20
  02AF    00CA    LD	0x4A,A
  02B0    0008    RET
  02B1    0842    LD	A,0x42
  02B2    0084    LD	0x4,A
  02B3    3003    LDIA	0x3
  02B4    0204    SUBA	0x4
  02B5    0008    RET
  032F    1683    SETB	0x3,5
  0330    1107    CLRB	0x7,2
  0331    1703    SETB	0x3,6
  0332    110F    CLRB	0xF,2
  0333    1283    CLRB	0x3,5
  0334    1303    CLRB	0x3,6
  0335    1107    CLRB	0x7,2
  0336    0008    RET
  0337    1683    SETB	0x3,5
  0338    1187    CLRB	0x7,3
  0339    1703    SETB	0x3,6
  033A    118F    CLRB	0xF,3
  033B    1283    CLRB	0x3,5
  033C    1303    CLRB	0x3,6
  033D    1187    CLRB	0x7,3
  033E    0008    RET
  033F    1683    SETB	0x3,5
  0340    1286    CLRB	0x6,5
  0341    1295    CLRB	0x15,5
  0342    1283    CLRB	0x3,5
  0343    1286    CLRB	0x6,5
  0344    0008    RET
  0345    1683    SETB	0x3,5
  0346    1186    CLRB	0x6,3
  0347    1195    CLRB	0x15,3
  0348    1283    CLRB	0x3,5
  0349    1186    CLRB	0x6,3
  034A    0008    RET
  034B    1683    SETB	0x3,5
  034C    1206    CLRB	0x6,4
  034D    1215    CLRB	0x15,4
  034E    1283    CLRB	0x3,5
  034F    1206    CLRB	0x6,4
  0350    0008    RET
  03AF    3EC9    ADDIA	0xC9
  03B0    0084    LD	0x4,A
  03B1    0800    LD	A,0x0
  03B2    00CA    LD	0x4A,A
  03B3    3007    LDIA	0x7
  03B4    01CB    CLR	0x4B
  03B5    00FF    LD	0x7F,A
  03B6    1003    CLRB	0x3,0
  03B7    0DCA    RLCR	0x4A
  03B8    0DCB    RLCR	0x4B
  03B9    0BFF    SZDECR	0x7F
  03BA    2BB6    JP	0x3B6
  03BB    084A    LD	A,0x4A
  03BC    04AA    ORR	0x2A
  03BD    084B    LD	A,0x4B
  03BE    04AB    ORR	0x2B
  03BF    0008    RET
  03C0    0800    LD	A,0x0
  03C1    00CA    LD	0x4A,A
  03C2    0A84    INCR	0x4
  03C3    0800    LD	A,0x0
  03C4    00CB    LD	0x4B,A
  03C5    09CA    COMR	0x4A
  03C6    09CB    COMR	0x4B
  03C7    084A    LD	A,0x4A
  03C8    05AA    ANDR	0x2A
  03C9    084B    LD	A,0x4B
  03CA    05AB    ANDR	0x2B
  03CB    0008    RET
  0421    3EC9    ADDIA	0xC9
  0422    0084    LD	0x4,A
  0423    1383    CLRB	0x3,7
  0424    0800    LD	A,0x0
  0425    00AA    LD	0x2A,A
  0426    300A    LDIA	0xA
  0427    01AB    CLR	0x2B
  0428    00F5    LD	0x75,A
  0429    0843    LD	A,0x43
  042A    0008    RET
  047B    00F5    LD	0x75,A
  047C    3064    LDIA	0x64
  047D    01F6    CLR	0x76
  047E    00F7    LD	0x77,A
  047F    01F8    CLR	0x78
  0480    0008    RET
  0581    084C    LD	A,0x4C
  0582    3EA0    ADDIA	0xA0
  0583    0084    LD	0x4,A
  0584    1383    CLRB	0x3,7
  0585    0A00    INCA	0x0
  0586    2D89    JP	0x589
  0587    1003    CLRB	0x3,0
  0588    0DF7    RLCR	0x77
  0589    3EFF    ADDIA	0xFF
  058A    1D03    SNZB	0x3,2
  058B    2D87    JP	0x587
  058C    0877    LD	A,0x77
  058D    0008    RET
  058E    00F8    LD	0x78,A
  058F    084C    LD	A,0x4C
  0590    3E01    ADDIA	0x1
  0591    0084    LD	0x4,A
  0592    0008    RET
  0593    3400    RET	0x0
  0594    3401    RET	0x1
  0595    3400    RET	0x0
  0596    3401    RET	0x1
  0597    3401    RET	0x1
  0598    3400    RET	0x0
  0599    3400    RET	0x0
  059A    3402    RET	0x2
  059B    3403    RET	0x3
  059C    3402    RET	0x2
  059D    3403    RET	0x3
  059E    3403    RET	0x3
  059F    3402    RET	0x2
  05A0    3402    RET	0x2
  05A1    3404    RET	0x4
  05A2    3404    RET	0x4
  05A3    3400    RET	0x0
  05A4    3400    RET	0x0
  05A5    3412    RET	0x12
  05A6    3400    RET	0x0
  05A7    345B    RET	0x5B
  05A8    3400    RET	0x0
  05A9    347F    RET	0x7F
  05AA    3400    RET	0x0
  05AB    347F    RET	0x7F
  05AC    3409    RET	0x9
  05AD    34FF    RET	0xFF
  05AE    342D    RET	0x2D
  05AF    34FF    RET	0xFF
  05B0    343F    RET	0x3F
  05B1    3400    RET	0x0
  05B2    3440    RET	0x40
  05B3    3470    RET	0x70
  05B4    3478    RET	0x78
  05B5    347E    RET	0x7E
  05B6    347F    RET	0x7F
  05B7    343F    RET	0x3F
  05B8    340F    RET	0xF
  05B9    3407    RET	0x7
  05BA    3401    RET	0x1
  05BB    3400    RET	0x0
  05BC    3477    RET	0x77
  05BD    3424    RET	0x24
  05BE    345D    RET	0x5D
  05BF    346D    RET	0x6D
  05C0    342E    RET	0x2E
  05C1    346B    RET	0x6B
  05C2    347B    RET	0x7B
  05C3    3425    RET	0x25
  05C4    347F    RET	0x7F
  05C5    342F    RET	0x2F
  066D    3064    LDIA	0x64
  066E    1283    CLRB	0x3,5
  066F    1303    CLRB	0x3,6
  0670    023C    SUBA	0x3C
  0671    0008    RET
  06F6    2AC7    JP	0x2C7
  06F7    2AD9    JP	0x2D9
  06F8    2AEB    JP	0x2EB
  06F9    2AFD    JP	0x2FD
  06FA    2B0E    JP	0x30E
  06FB    2A5C    JP	0x25C
  06FC    2A64    JP	0x264
  06FD    2A6E    JP	0x26E
  0706    3401    RET	0x1
  0707    3402    RET	0x2
  0708    3402    RET	0x2
  0709    3403    RET	0x3
  070A    3400    RET	0x0
  070B    3403    RET	0x3
  070C    3404    RET	0x4
  070D    3400    RET	0x0
  070E    3401    RET	0x1
  070F    3401    RET	0x1
  0710    3402    RET	0x2
  0711    3400    RET	0x0
  0712    3403    RET	0x3
  0713    3404    RET	0x4
  0714    3400    RET	0x0
  0715    3401    RET	0x1
  0728    087E    LD	A,0x7E
  0729    008A    LD	0xA,A
  072A    087F    LD	A,0x7F
  072B    0082    LD	0x2,A
  072C    2728    CALL	0x728
  072D    0080    LD	0x0,A
  072E    0A84    INCR	0x4
  072F    0804    LD	A,0x4
  0730    067D    XORA	0x7D
  0731    1903    SZB	0x3,2
  0732    3400    RET	0x0
  0733    0AFF    INCR	0x7F
  0734    1903    SZB	0x3,2
  0735    0AFE    INCR	0x7E
  0736    2F2C    JP	0x72C
  0767    0064    CLRWDT
  0768    0180    CLR	0x0
  0769    0A84    INCR	0x4
  076A    0604    XORA	0x4
  076B    1903    SZB	0x3,2
  076C    3400    RET	0x0
  076D    0604    XORA	0x4
  076E    2F68    JP	0x768
