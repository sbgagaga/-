---- C:\Users\Administrator\Desktop\project\K13-01\code\main.c ----------------------------------------------------------------------
1:                #include "K13-01.h"
2:                
3:                void main()
4:                {
5:                    SystemInit();
  078E    2778    CALL	0x778
6:                    while (1)
7:                    {
8:                        Apply();
  078F    2647    CALL	0x647
  0790    0064    CLRWDT
  0791    2F8F    JP	0x78F
9:                        asm("clrwdt");
10:                   }
11:               }
12:               
---- C:\Users\Administrator\Desktop\project\K13-01\code\K13-01.c ----------------------------------------------------------------------
1:                #include "K13-01.h"
2:                
3:                bit SystemONFlag=0;
4:                uint8 VarPowerUpCount=0;
5:                
6:                uint8 BatPercent=0;
7:                
8:                uint8 WorkMin=0;
9:                
10:               uint8 LockNumb=0;
11:               
12:               TYPE_UNION_LockSta LockSta;
13:               
14:               bit OnOffFlag=0;
15:               bit WorkFlag=0;
16:               bit IovFlag=0;
17:               bit LowBatFlag=0;
18:               bit USBFlag=0;
19:               
20:               uint8 Sec1sCnt=0;
21:               uint8 BatAddTime=240;
22:               uint8 BatDecTime=210;
23:               
24:               void Apply()
25:               {
26:                   if(time2ms)
  0647    1CF1    SNZB	0x71,1
  0648    2E4D    JP	0x64D
27:                   {
28:                       time2ms=0;
  0649    10F1    CLRB	0x71,1
29:                       if(SystemONFlag)
  064A    1F71    SNZB	0x71,6
  064B    2E4D    JP	0x64D
30:                       {
31:                           KeyScan();
  064C    2024    CALL	0x24
32:                       }
33:                   }
34:                   if(time10ms)
  064D    1C71    SNZB	0x71,0
  064E    0008    RET
35:                   {
36:                       time10ms=0;
  064F    1071    CLRB	0x71,0
37:                       if(SystemONFlag==0&&VarPowerUpCount<100)
  0650    1B71    SZB	0x71,6
  0651    2E58    JP	0x658
  0652    266B    CALL	0x66B
  0653    1803    SZB	0x3,0
  0654    2E58    JP	0x658
38:                       {
39:                           VarPowerUpCount++;
  0655    0AC2    INCR	0x42
40:                           ADCPro();
  0656    2463    CALL	0x463
41:                       }
  0657    2E5D    JP	0x65D
42:                       else if(VarPowerUpCount>=100)
  0658    266B    CALL	0x66B
  0659    1C03    SNZB	0x3,0
  065A    2E5D    JP	0x65D
43:                       {
44:                           SystemONFlag=1;
  065B    1771    SETB	0x71,6
45:                           VarPowerUpCount=0;
  065C    01C2    CLR	0x42
46:                       }
47:                       /*上电完成*/
48:                       if(SystemONFlag)
  065D    1F71    SNZB	0x71,6
  065E    2E63    JP	0x663
49:                       {
50:                           ADCPro();
  065F    2463    CALL	0x463
51:                           Motor();
  0660    240D    CALL	0x40D
52:                           DisplayPro();
  0661    276D    CALL	0x76D
53:                           #ifndef DEBUGFlag
54:                           SystemSleep();
  0662    2541    CALL	0x541
  0663    3064    LDIA	0x64
55:                           #endif
56:                       }
57:                       Sec1sCnt++;
  0664    1303    CLRB	0x3,6
  0665    0AC0    INCR	0x40
58:                       if(Sec1sCnt>=100)
  0666    0240    SUBA	0x40
  0667    1C03    SNZB	0x3,0
  0668    0008    RET
59:                       {
60:                           Sec1sCnt=0;
  0669    01C0    CLR	0x40
61:                           Sec1sPro();
  066A    28FF    JP	0xFF
62:                       }
63:                   }
64:               }
65:               
66:               void SystemSleep()
67:               {
68:                   static uint8 SleepCnt=0;
69:                   if(WorkFlag||OnOffFlag||LowBatFlag||USBFlag||IovFlag||KeyPress||LockSta.LockStart)
  0541    1D71    SNZB	0x71,2
  0542    1B70    SZB	0x70,6
  0543    2D4C    JP	0x54C
  0544    1EF1    SNZB	0x71,5
  0545    19F1    SZB	0x71,3
  0546    2D4C    JP	0x54C
  0547    1E71    SNZB	0x71,4
  0548    1BF0    SZB	0x70,7
  0549    2D4C    JP	0x54C
  054A    1C33    SNZB	0x33,0
  054B    2D4E    JP	0x54E
70:                   {
71:                       SleepCnt=0;
  054C    01BF    CLR	0x3F
72:                   }
  054D    0008    RET
  054E    30C8    LDIA	0xC8
73:                   else
74:                   {
75:                       SleepCnt++;
  054F    0ABF    INCR	0x3F
76:                       if(SleepCnt>=200)
  0550    023F    SUBA	0x3F
  0551    1C03    SNZB	0x3,0
  0552    0008    RET
77:                       {
78:                           SleepCnt=0;
  0553    01BF    CLR	0x3F
  0554    0064    CLRWDT
79:                           asm("clrwdt");
80:                           INTCON=0;
  0555    018B    CLR	0xB
81:                           PIE1 = 0;
  0556    1683    SETB	0x3,5
  0557    1303    CLRB	0x3,6
  0558    018C    CLR	0xC
82:                           PIE2 = 0;	
  0559    018D    CLR	0xD
83:                           PIR1 = 0;
  055A    1283    CLRB	0x3,5
  055B    018C    CLR	0xC
84:                           ADCON0	= 0;
  055C    019F    CLR	0x1F
85:               
86:                           TRISA =0X00;
  055D    1683    SETB	0x3,5
87:               	        TRISB =0X00;
88:                           TRISC =0x00;
89:                           WPUA = 0xFF;
90:                           WPUB = 0xFF;
91:                           WPUC = 0xFF;
  055E    268B    CALL	0x68B
92:                           PORTA =	0;			//初始端口配置为输出低；
  055F    1283    CLRB	0x3,5
  0560    1303    CLRB	0x3,6
  0561    0185    CLR	0x5
93:                           PORTB = 0;
  0562    0186    CLR	0x6
94:                           PORTC = 0;
  0563    0187    CLR	0x7
95:                           PIN_BAT=H;
  0564    1485    SETB	0x5,1
96:                           PIN_IOV=H;
  0565    1505    SETB	0x5,2
97:                           PIN_GND=H;
  0566    1405    SETB	0x5,0
98:                           PIN_EN =L;
  0567    1285    CLRB	0x5,5
99:                           Pin_KEY_CFG(1,1);
  0568    1683    SETB	0x3,5
  0569    1706    SETB	0x6,6
  056A    1715    SETB	0x15,6
100:                          Pin_USB_CFG(1,1);
  056B    1786    SETB	0x6,7
  056C    1795    SETB	0x15,7
101:              
102:                          WDT_OFF();
  056D    1283    CLRB	0x3,5
  056E    1703    SETB	0x3,6
  056F    0185    CLR	0x5
103:                          RBIE=1;
  0570    158B    SETB	0xB,3
104:                          IOCB=0xC0;
  0571    30C0    LDIA	0xC0
  0572    1683    SETB	0x3,5
  0573    1303    CLRB	0x3,6
  0574    0096    LD	0x16,A
105:                          OSCCON=0X01;
  0575    3001    LDIA	0x1
  0576    008F    LD	0xF,A
106:                          RBIF = 0;
  0577    100B    CLRB	0xB,0
107:                          PORTB;
  0578    1283    CLRB	0x3,5
  0579    0806    LD	A,0x6
  057A    0063    STOP
  057B    0000    NOP
108:                          asm("sleep");
109:              		    asm("nop");
110:                          SystemInit();
  057C    2F78    JP	0x778
111:                      }
112:                  }
113:              }
114:              
115:              void SystemInit()
  0778    0000    NOP
  0779    0064    CLRWDT
116:              {
117:                  asm("nop");
118:              	asm("clrwdt");
119:                  GPIOInit();
  077A    2670    CALL	0x670
120:                  TimerInit();
  077B    2751    CALL	0x751
121:                  WDT_ON();
  077C    3001    LDIA	0x1
  077D    1283    CLRB	0x3,5
  077E    1703    SETB	0x3,6
  077F    0085    LD	0x5,A
  0780    0008    RET
122:              }
123:              
124:              void GPIOInit()
125:              {
126:                  RBPU=0;
  0670    1683    SETB	0x3,5
  0671    1303    CLRB	0x3,6
  0672    1381    CLRB	0x1,7
127:              	/*全配置成输出*/
128:              	TRISA =0X00;
129:              	TRISB =0X00;
130:              	TRISC =0X00;
131:              	//TRISE =0X00; 
132:              
133:                  /*全部设置上拉，输出会自动断开上拉*/
134:              	WPUA  =0XFF;
135:              	WPUB  =0XFF;
136:              	WPUC  =0XFF;
  0673    268B    CALL	0x68B
137:              	//WPUE  =0XFF;
138:              
139:                  /*默认输出0*/
140:              	PORTA =	0X80;
  0674    3080    LDIA	0x80
  0675    1283    CLRB	0x3,5
  0676    1303    CLRB	0x3,6
  0677    0085    LD	0x5,A
141:              	PORTB = 0X80;
  0678    0086    LD	0x6,A
142:              	PORTC = 0;
  0679    0187    CLR	0x7
143:              	//PORTE = 0;
144:              
145:              	PIN_EN =true;
  067A    1685    SETB	0x5,5
146:                  RBPU=0;
  067B    1683    SETB	0x3,5
  067C    1381    CLRB	0x1,7
147:                  Pin_KEY_CFG(IN,1);
  067D    1706    SETB	0x6,6
  067E    1715    SETB	0x15,6
148:                  Pin_USB_CFG(IN,1);
  067F    1786    SETB	0x6,7
  0680    1795    SETB	0x15,7
149:              	
150:              	Pin_BAT_CFG(1,0); ANS1=1; //AN1配置为模拟输入；
  0681    1485    SETB	0x5,1
  0682    1703    SETB	0x3,6
  0683    108E    CLRB	0xE,1
  0684    1488    SETB	0x8,1
151:              	Pin_IOV_CFG(1,0); ANS2=1; //AN2配置为模拟输入；
  0685    1303    CLRB	0x3,6
  0686    1505    SETB	0x5,2
  0687    1703    SETB	0x3,6
  0688    110E    CLRB	0xE,2
  0689    1508    SETB	0x8,2
  068A    0008    RET
152:                  //Pin_Vin_CFG(1,0); ANS9=1;//AN9配置为模拟输入；
153:              }
154:              
155:              void TimerInit()
156:              {
157:                  // OSCCON=0X71;		//晶振配置为8M,内部
158:              	// INTCON=0B11000000;	//使能全局中断，外设中断
159:              	// PIE1=0B00000001;	//TIMER1溢出中断
160:                  // TMR1IF = 0;
161:              	// TMR1IE = 1;	
162:                  // TMR1H=0xFC;
163:                  // TMR1L=0x18;         //设置定时器1计时1ms
164:                  // T1CON = 0X01; //预分配4倍,使能定时器1
165:              
166:              	OSCCON=0X61;		//晶振配置为4M,内部
  0751    3061    LDIA	0x61
  0752    1303    CLRB	0x3,6
  0753    008F    LD	0xF,A
167:              	INTCON=0B11000000;	//使能全局中断，外设中断
  0754    30C0    LDIA	0xC0
  0755    008B    LD	0xB,A
168:              	PIE1=0B00000010;	//TIMER2匹配中断
  0756    3002    LDIA	0x2
  0757    008C    LD	0xC,A
169:              	T2CON=0B00000100;	//使能TIMER2
  0758    3004    LDIA	0x4
  0759    1283    CLRB	0x3,5
  075A    0092    LD	0x12,A
170:              	PR2	= 200;			//TIMER时钟为Fosc/4; 200us进一次中断
  075B    30C8    LDIA	0xC8
  075C    1683    SETB	0x3,5
  075D    0092    LD	0x12,A
  075E    0008    RET
171:              }
---- C:\Users\Administrator\Desktop\project\K13-01\code\ADC.c ----------------------------------------------------------------------
1:                #include "ADC.h"
2:                
3:                uint8 ADCState=0;
4:                uint16 ADCVal[3]={0};//bg、current、Vbat
5:                uint32 ADsum=0;
6:                uint8 ADcnt=0;
7:                
8:                uint8 CurrentCnt=0;
9:                
10:               void ADCPro()
11:               {
12:                   switch (ADCState)
  0463    2C73    JP	0x473
13:                   {
14:                       case 0://内部参考电压采样
15:                       ADCRead(AD_BG,ADCVal);
  0464    304A    LDIA	0x4A
  0465    00E5    LD	0x65,A
  0466    300F    LDIA	0xF
  0467    21D0    CALL	0x1D0
16:                       break;
  0468    2C7B    JP	0x47B
17:               
18:                       case 1://过流采样
19:                       ADCRead(AD_AN2,ADCVal+1);
  0469    304C    LDIA	0x4C
  046A    00E5    LD	0x65,A
  046B    3002    LDIA	0x2
  046C    21D0    CALL	0x1D0
20:                       break;
  046D    2C7B    JP	0x47B
21:               
22:                       case 2://电池电压采样
23:                       ADCRead(AD_AN1,ADCVal+2);
  046E    304E    LDIA	0x4E
  046F    00E5    LD	0x65,A
  0470    3001    LDIA	0x1
  0471    21D0    CALL	0x1D0
24:                       break;
  0472    2C7B    JP	0x47B
  0473    2298    CALL	0x298
  0474    1803    SZB	0x3,0
  0475    2C7B    JP	0x47B
  0476    3000    LDIA	0x0
  0477    008A    LD	0xA,A
  0478    3001    LDIA	0x1
  0479    0704    ADDA	0x4
  047A    0082    LD	0x2,A
25:                   }
26:                   if(SystemONFlag==0)
  047B    1B71    SZB	0x71,6
  047C    2C92    JP	0x492
27:                   {
28:                       if(ADCVal[2]<BAT_3V2) 
  047D    3000    LDIA	0x0
  047E    024F    SUBA	0x4F
  047F    3086    LDIA	0x86
  0480    1903    SZB	0x3,2
  0481    024E    SUBA	0x4E
  0482    1803    SZB	0x3,0
  0483    2C86    JP	0x486
29:                       {
30:                           BatPercent=0; 
  0484    01C9    CLR	0x49
31:                       }
  0485    2C92    JP	0x492
32:                       else if(ADCVal[2]>BAT_4V2)
  0486    3000    LDIA	0x0
  0487    024F    SUBA	0x4F
  0488    30B0    LDIA	0xB0
  0489    1903    SZB	0x3,2
  048A    024E    SUBA	0x4E
  048B    1C03    SNZB	0x3,0
  048C    2C8F    JP	0x48F
33:                       {
34:                           BatPercent=99; 
  048D    3063    LDIA	0x63
  048E    2C91    JP	0x491
35:                       }
36:                       else
37:                       {
38:                           BatPercent=ADCVal[2]-BAT_3V0;
  048F    084E    LD	A,0x4E
  0490    3E83    ADDIA	0x83
  0491    00C9    LD	0x49,A
39:                       }
40:                   }
41:                   if(ADCVal[2]<BAT_3V0)
  0492    3000    LDIA	0x0
  0493    024F    SUBA	0x4F
  0494    307D    LDIA	0x7D
  0495    1903    SZB	0x3,2
  0496    024E    SUBA	0x4E
  0497    1803    SZB	0x3,0
  0498    2C9B    JP	0x49B
42:                   {
43:                       LowBatFlag=1;
  0499    16F1    SETB	0x71,5
44:                   }
  049A    2C9C    JP	0x49C
45:                   else
46:                   {
47:                       LowBatFlag=0;
  049B    12F1    CLRB	0x71,5
48:                   }
49:                   if(ADCVal[1]>VOLTAGE07V)
  049C    3000    LDIA	0x0
  049D    024D    SUBA	0x4D
  049E    301E    LDIA	0x1E
  049F    1903    SZB	0x3,2
  04A0    024C    SUBA	0x4C
  04A1    1C03    SNZB	0x3,0
  04A2    2CAC    JP	0x4AC
  04A3    30C8    LDIA	0xC8
50:                   {
51:                       CurrentCnt++;
  04A4    0AC6    INCR	0x46
52:                       if(CurrentCnt>=200)
  04A5    0246    SUBA	0x46
  04A6    1C03    SNZB	0x3,0
  04A7    0008    RET
53:                       {
54:                           CurrentCnt=200;
  04A8    30C8    LDIA	0xC8
  04A9    00C6    LD	0x46,A
55:                           IovFlag=1;
  04AA    1671    SETB	0x71,4
  04AB    0008    RET
56:                       }
57:                   }
58:                   else
59:                   {
60:                       CurrentCnt=0;
  04AC    01C6    CLR	0x46
61:                       IovFlag=0;
  04AD    1271    CLRB	0x71,4
  04AE    0008    RET
62:                   }
63:               }
64:               
65:               void Sec1sPro()
66:               {
67:                   static uint8 ActualPercent=0;
68:                   uint8 PercentErr=0;
69:                   uint16 TempPercent=0;
  00FF    01D6    CLR	0x56
  0100    01D7    CLR	0x57
70:               
71:                   /*充电数字增加时间*/
72:                   if(USBFlag)
  0101    1DF1    SNZB	0x71,3
  0102    295E    JP	0x15E
73:                   {
74:                       if(ADCVal[2]<BAT_3V3) 
  0103    3000    LDIA	0x0
  0104    024F    SUBA	0x4F
  0105    308A    LDIA	0x8A
  0106    1903    SZB	0x3,2
  0107    024E    SUBA	0x4E
  0108    1803    SZB	0x3,0
  0109    290C    JP	0x10C
75:                       {
76:                           TempPercent=0; 
  010A    01D6    CLR	0x56
  010B    2915    JP	0x115
77:                       }
78:                       else if(ADCVal[2]>BAT_4V2)
  010C    3000    LDIA	0x0
  010D    024F    SUBA	0x4F
  010E    30B0    LDIA	0xB0
  010F    1903    SZB	0x3,2
  0110    024E    SUBA	0x4E
  0111    1C03    SNZB	0x3,0
  0112    2917    JP	0x117
79:                       {
80:                           TempPercent=99; 
  0113    3063    LDIA	0x63
  0114    00D6    LD	0x56,A
  0115    01D7    CLR	0x57
81:                       }
  0116    2933    JP	0x133
82:                       else
83:                       {
84:                           TempPercent=ADCVal[2]-BAT_3V3;
  0117    084F    LD	A,0x4F
  0118    00D7    LD	0x57,A
  0119    084E    LD	A,0x4E
  011A    00D6    LD	0x56,A
  011B    3076    LDIA	0x76
  011C    21CA    CALL	0x1CA
85:                           TempPercent=TempPercent*4/3;
  011D    3003    LDIA	0x3
  011E    00F5    LD	0x75,A
  011F    01F6    CLR	0x76
  0120    0857    LD	A,0x57
  0121    00D4    LD	0x54,A
  0122    0856    LD	A,0x56
  0123    00D3    LD	0x53,A
  0124    1003    CLRB	0x3,0
  0125    0DD3    RLCR	0x53
  0126    0DD4    RLCR	0x54
  0127    1003    CLRB	0x3,0
  0128    0DD3    RLCR	0x53
  0129    0DD4    RLCR	0x54
  012A    0853    LD	A,0x53
  012B    00F7    LD	0x77,A
  012C    0854    LD	A,0x54
  012D    00F8    LD	0x78,A
  012E    261D    CALL	0x61D
  012F    0876    LD	A,0x76
  0130    00D7    LD	0x57,A
  0131    0875    LD	A,0x75
  0132    00D6    LD	0x56,A
86:                       }
87:                       if(ActualPercent>TempPercent)
88:                       {
89:                           if(ActualPercent)
  0133    21BF    CALL	0x1BF
  0134    1803    SZB	0x3,0
  0135    293A    JP	0x13A
  0136    1903    SZB	0x3,2
  0137    2949    JP	0x149
90:                           {
91:                               ActualPercent--;
  0138    03C5    DECR	0x45
  0139    2949    JP	0x149
92:                           }
93:                       }
94:                       else if(ActualPercent<TempPercent)
  013A    00D3    LD	0x53,A
  013B    01D4    CLR	0x54
  013C    0857    LD	A,0x57
  013D    0254    SUBA	0x54
  013E    1D03    SNZB	0x3,2
  013F    2942    JP	0x142
  0140    0856    LD	A,0x56
  0141    0253    SUBA	0x53
  0142    1803    SZB	0x3,0
  0143    2949    JP	0x149
95:                       {
96:                           if(ActualPercent<99)
  0144    3063    LDIA	0x63
  0145    0245    SUBA	0x45
  0146    1803    SZB	0x3,0
  0147    2949    JP	0x149
97:                           {
98:                               ActualPercent++;
  0148    0AC5    INCR	0x45
99:                           }
100:                      }
101:                      if(ActualPercent>BatPercent)
  0149    0845    LD	A,0x45
  014A    0249    SUBA	0x49
  014B    1803    SZB	0x3,0
  014C    295C    JP	0x15C
102:                      {
103:                          PercentErr=ActualPercent-BatPercent;
  014D    0849    LD	A,0x49
  014E    0245    SUBA	0x45
  014F    00D5    LD	0x55,A
104:                          if(PercentErr<5)
  0150    3005    LDIA	0x5
  0151    0255    SUBA	0x55
  0152    1803    SZB	0x3,0
  0153    295A    JP	0x15A
105:                          {
106:                              BatAddTime=90-15*PercentErr;
  0154    30F1    LDIA	0xF1
  0155    00F5    LD	0x75,A
  0156    0855    LD	A,0x55
  0157    275F    CALL	0x75F
  0158    3E5A    ADDIA	0x5A
  0159    295D    JP	0x15D
107:                          }
108:                          else
109:                          {
110:                              BatAddTime=15;
  015A    300F    LDIA	0xF
  015B    295D    JP	0x15D
111:                          }
112:                      }
113:                      else
114:                      {
115:                          BatAddTime=240;
  015C    30F0    LDIA	0xF0
  015D    00EB    LD	0x6B,A
116:                      }
117:                  }
118:              
119:                  /*工作数字减少时间*/
120:                  if(WorkFlag)
  015E    1D71    SNZB	0x71,2
  015F    29BC    JP	0x1BC
121:                  {
122:                      if(ADCVal[2]<BAT_3V2) 
  0160    3000    LDIA	0x0
  0161    024F    SUBA	0x4F
  0162    3086    LDIA	0x86
  0163    1903    SZB	0x3,2
  0164    024E    SUBA	0x4E
  0165    1803    SZB	0x3,0
  0166    2969    JP	0x169
123:                      {
124:                          TempPercent=0; 
  0167    01D6    CLR	0x56
  0168    2972    JP	0x172
125:                      }
126:                      else if(ADCVal[2]>BAT_4V0)
  0169    3000    LDIA	0x0
  016A    024F    SUBA	0x4F
  016B    30A8    LDIA	0xA8
  016C    1903    SZB	0x3,2
  016D    024E    SUBA	0x4E
  016E    1C03    SNZB	0x3,0
  016F    2974    JP	0x174
127:                      {
128:                          TempPercent=99; 
  0170    3063    LDIA	0x63
  0171    00D6    LD	0x56,A
  0172    01D7    CLR	0x57
129:                      }
  0173    297A    JP	0x17A
130:                      else
131:                      {
132:                          TempPercent=ADCVal[2]-BAT_3V2;
  0174    084F    LD	A,0x4F
  0175    00D7    LD	0x57,A
  0176    084E    LD	A,0x4E
  0177    00D6    LD	0x56,A
  0178    307A    LDIA	0x7A
  0179    21CA    CALL	0x1CA
133:                      }
134:                      if(TempPercent>=33)
  017A    3000    LDIA	0x0
  017B    0257    SUBA	0x57
  017C    3021    LDIA	0x21
  017D    1903    SZB	0x3,2
  017E    0256    SUBA	0x56
  017F    1C03    SNZB	0x3,0
  0180    298E    JP	0x18E
135:                      {
136:                          TempPercent=33+(ADCVal[2]-BAT_3V6)*2; 
  0181    084F    LD	A,0x4F
  0182    00D7    LD	0x57,A
  0183    084E    LD	A,0x4E
  0184    00D6    LD	0x56,A
  0185    30F5    LDIA	0xF5
  0186    1003    CLRB	0x3,0
  0187    0DD6    RLCR	0x56
  0188    0DD7    RLCR	0x57
  0189    07D6    ADDR	0x56
  018A    1803    SZB	0x3,0
  018B    0AD7    INCR	0x57
  018C    30FE    LDIA	0xFE
  018D    07D7    ADDR	0x57
137:                      }
138:                      if(ActualPercent>TempPercent)
139:                      {
140:                          if(ActualPercent)
  018E    21BF    CALL	0x1BF
  018F    1803    SZB	0x3,0
  0190    2995    JP	0x195
  0191    1903    SZB	0x3,2
  0192    29A4    JP	0x1A4
141:                          {
142:                              ActualPercent--;
  0193    03C5    DECR	0x45
  0194    29A4    JP	0x1A4
143:                          }
144:                      }
145:                      else if(ActualPercent<TempPercent)
  0195    00D3    LD	0x53,A
  0196    01D4    CLR	0x54
  0197    0857    LD	A,0x57
  0198    0254    SUBA	0x54
  0199    1D03    SNZB	0x3,2
  019A    299D    JP	0x19D
  019B    0856    LD	A,0x56
  019C    0253    SUBA	0x53
  019D    1803    SZB	0x3,0
  019E    29A4    JP	0x1A4
146:                      {
147:                          if(ActualPercent<99)
  019F    3063    LDIA	0x63
  01A0    0245    SUBA	0x45
  01A1    1803    SZB	0x3,0
  01A2    29A4    JP	0x1A4
148:                          {
149:                              ActualPercent++;
  01A3    0AC5    INCR	0x45
150:                          }
151:                      }
152:                      if(ActualPercent<BatPercent)
  01A4    0849    LD	A,0x49
  01A5    0245    SUBA	0x45
  01A6    1803    SZB	0x3,0
  01A7    29BC    JP	0x1BC
153:                      {
154:                          PercentErr=BatPercent-ActualPercent;
  01A8    0845    LD	A,0x45
  01A9    0249    SUBA	0x49
  01AA    00D5    LD	0x55,A
155:                          if(PercentErr<5&&ActualPercent)
  01AB    3005    LDIA	0x5
  01AC    0255    SUBA	0x55
  01AD    1803    SZB	0x3,0
  01AE    29B9    JP	0x1B9
  01AF    0845    LD	A,0x45
  01B0    1903    SZB	0x3,2
  01B1    29B9    JP	0x1B9
156:                          {
157:                              BatDecTime=75-15*PercentErr;
  01B2    30F1    LDIA	0xF1
  01B3    00F5    LD	0x75,A
  01B4    0855    LD	A,0x55
  01B5    275F    CALL	0x75F
  01B6    3E4B    ADDIA	0x4B
  01B7    00EA    LD	0x6A,A
158:                          }
  01B8    0008    RET
159:                          else
160:                          {
161:                              BatDecTime=8;
  01B9    3008    LDIA	0x8
  01BA    00EA    LD	0x6A,A
  01BB    0008    RET
162:                          }
163:                      }
164:                      else
165:                      {
166:                          BatDecTime=210;
  01BC    30D2    LDIA	0xD2
  01BD    00EA    LD	0x6A,A
  01BE    0008    RET
167:                      }
168:                  }
169:                  else
170:                  {
171:                      BatDecTime=210;
172:                  }
173:              }
174:              
175:              void ADCRead(uint8 ch,uint16 *Val)
  01D0    1683    SETB	0x3,5
  01D1    00D3    LD	0x53,A
176:              {
177:              	uint16 ad_temp,AD_H,AD_L;
178:              
179:              	if(ADSample(ch))
  01D2    2701    CALL	0x701
  01D3    3A00    XORIA	0x0
  01D4    1903    SZB	0x3,2
  01D5    0008    RET
180:              	{
181:                      AD_H=ADRESH;
  01D6    081E    LD	A,0x1E
  01D7    1683    SETB	0x3,5
  01D8    00D4    LD	0x54,A
  01D9    01D5    CLR	0x55
182:                      AD_L=ADRESL;
  01DA    081E    LD	A,0x1E
  01DB    00D6    LD	0x56,A
  01DC    01D7    CLR	0x57
183:              		ad_temp=(AD_H<<4)|(AD_L>>4);  //12位ad
  01DD    0855    LD	A,0x55
  01DE    1283    CLRB	0x3,5
  01DF    00E7    LD	0x67,A
  01E0    1683    SETB	0x3,5
  01E1    0854    LD	A,0x54
  01E2    1283    CLRB	0x3,5
  01E3    00E6    LD	0x66,A
  01E4    30F0    LDIA	0xF0
  01E5    0EE6    SWAPR	0x66
  01E6    0EE7    SWAPR	0x67
  01E7    05E7    ANDR	0x67
  01E8    0866    LD	A,0x66
  01E9    390F    ANDIA	0xF
  01EA    04E7    ORR	0x67
  01EB    30F0    LDIA	0xF0
  01EC    05E6    ANDR	0x66
  01ED    0866    LD	A,0x66
  01EE    1683    SETB	0x3,5
  01EF    00D8    LD	0x58,A
  01F0    1283    CLRB	0x3,5
  01F1    0867    LD	A,0x67
  01F2    1683    SETB	0x3,5
  01F3    00D9    LD	0x59,A
  01F4    0857    LD	A,0x57
  01F5    1283    CLRB	0x3,5
  01F6    00E7    LD	0x67,A
  01F7    1683    SETB	0x3,5
  01F8    0856    LD	A,0x56
  01F9    1283    CLRB	0x3,5
  01FA    00E6    LD	0x66,A
  01FB    3004    LDIA	0x4
  01FC    1003    CLRB	0x3,0
  01FD    0CE7    RRCR	0x67
  01FE    0CE6    RRCR	0x66
  01FF    3EFF    ADDIA	0xFF
  0200    1D03    SNZB	0x3,2
  0201    29FC    JP	0x1FC
  0202    0866    LD	A,0x66
  0203    1683    SETB	0x3,5
  0204    04D8    ORR	0x58
  0205    1283    CLRB	0x3,5
  0206    0867    LD	A,0x67
  0207    1683    SETB	0x3,5
  0208    04D9    ORR	0x59
184:              		ADsum += ad_temp;
  0209    0858    LD	A,0x58
  020A    1283    CLRB	0x3,5
  020B    00E6    LD	0x66,A
  020C    1683    SETB	0x3,5
  020D    0859    LD	A,0x59
  020E    1283    CLRB	0x3,5
  020F    00E7    LD	0x67,A
  0210    01E8    CLR	0x68
  0211    01E9    CLR	0x69
  0212    0866    LD	A,0x66
  0213    07A5    ADDR	0x25
  0214    0867    LD	A,0x67
  0215    1103    CLRB	0x3,2
  0216    1803    SZB	0x3,0
  0217    3E01    ADDIA	0x1
  0218    1D03    SNZB	0x3,2
  0219    07A6    ADDR	0x26
  021A    0868    LD	A,0x68
  021B    1103    CLRB	0x3,2
  021C    1803    SZB	0x3,0
  021D    3E01    ADDIA	0x1
  021E    1D03    SNZB	0x3,2
  021F    07A7    ADDR	0x27
  0220    0869    LD	A,0x69
  0221    1103    CLRB	0x3,2
  0222    1803    SZB	0x3,0
  0223    3E01    ADDIA	0x1
  0224    1D03    SNZB	0x3,2
  0225    07A8    ADDR	0x28
  0226    300A    LDIA	0xA
185:              		ADcnt++;
  0227    0AC7    INCR	0x47
186:              		if(ADcnt >= 10)
  0228    0247    SUBA	0x47
  0229    1C03    SNZB	0x3,0
  022A    0008    RET
  022B    300A    LDIA	0xA
187:              		{
188:                          ADcnt = 0;	
  022C    01C7    CLR	0x47
189:              			ADsum /=10;
  022D    00D8    LD	0x58,A
  022E    01D9    CLR	0x59
  022F    01DA    CLR	0x5A
  0230    01DB    CLR	0x5B
  0231    0828    LD	A,0x28
  0232    00DF    LD	0x5F,A
  0233    0827    LD	A,0x27
  0234    00DE    LD	0x5E,A
  0235    0826    LD	A,0x26
  0236    00DD    LD	0x5D,A
  0237    0825    LD	A,0x25
  0238    00DC    LD	0x5C,A
  0239    24F9    CALL	0x4F9
  023A    085B    LD	A,0x5B
  023B    00A8    LD	0x28,A
  023C    085A    LD	A,0x5A
  023D    00A7    LD	0x27,A
  023E    0859    LD	A,0x59
  023F    00A6    LD	0x26,A
  0240    0858    LD	A,0x58
  0241    00A5    LD	0x25,A
190:                          switch (ADCState)
  0242    2A70    JP	0x270
191:                          {
192:                              case 0:
193:                              *Val=ADsum;//内部参考电压
  0243    0865    LD	A,0x65
  0244    0084    LD	0x4,A
  0245    0825    LD	A,0x25
  0246    1383    CLRB	0x3,7
  0247    0080    LD	0x0,A
  0248    0A84    INCR	0x4
  0249    0826    LD	A,0x26
  024A    2A6E    JP	0x26E
194:                              break;
195:              
196:                              case 1:
197:                              *Val=ADsum*1000/(*(Val-1));//电流
  024B    0865    LD	A,0x65
  024C    3EFE    ADDIA	0xFE
  024D    2282    CALL	0x282
  024E    3003    LDIA	0x3
  024F    01D7    CLR	0x57
  0250    01D6    CLR	0x56
  0251    00D5    LD	0x55,A
  0252    30E8    LDIA	0xE8
  0253    00D4    LD	0x54,A
  0254    2A5D    JP	0x25D
198:                              break;
199:              
200:                              case 2:
201:                              *Val=ADsum*100/(*(Val-2));//电池电压
  0255    0865    LD	A,0x65
  0256    3EFC    ADDIA	0xFC
  0257    2282    CALL	0x282
  0258    3064    LDIA	0x64
  0259    00D4    LD	0x54,A
  025A    01D5    CLR	0x55
  025B    01D6    CLR	0x56
  025C    01D7    CLR	0x57
  025D    25EA    CALL	0x5EA
  025E    0853    LD	A,0x53
  025F    00DF    LD	0x5F,A
  0260    0852    LD	A,0x52
  0261    00DE    LD	0x5E,A
  0262    0851    LD	A,0x51
  0263    00DD    LD	0x5D,A
  0264    0850    LD	A,0x50
  0265    00DC    LD	0x5C,A
  0266    24F9    CALL	0x4F9
  0267    0865    LD	A,0x65
  0268    0084    LD	0x4,A
  0269    0858    LD	A,0x58
  026A    1383    CLRB	0x3,7
  026B    0080    LD	0x0,A
  026C    0A84    INCR	0x4
  026D    0859    LD	A,0x59
  026E    0080    LD	0x0,A
202:                              break;
  026F    2A78    JP	0x278
  0270    2298    CALL	0x298
  0271    1803    SZB	0x3,0
  0272    2A78    JP	0x278
  0273    3007    LDIA	0x7
  0274    008A    LD	0xA,A
  0275    3092    LDIA	0x92
  0276    0704    ADDA	0x4
  0277    0082    LD	0x2,A
  0278    3003    LDIA	0x3
203:                          }
204:              			ADsum = 0;
  0279    01A5    CLR	0x25
  027A    01A6    CLR	0x26
  027B    01A7    CLR	0x27
  027C    01A8    CLR	0x28
205:                          ADCState++;
  027D    0AC8    INCR	0x48
206:                          if(ADCState>=3)
  027E    0248    SUBA	0x48
  027F    1803    SZB	0x3,0
207:                          {
208:                              ADCState=0;
  0280    01C8    CLR	0x48
  0281    0008    RET
209:                          }
210:              		}
211:              	}
212:              }
213:              
214:              /************************************************************
215:              函数名称：ADSample()
216:              函数功能：AD采样函数
217:              入口参数：ADCH,AD通道
218:              出口参数：ADRESH,ADRESL
219:              备    注：采样成功返回1，超时返回0
220:              ************************************************************/
221:              uint8 ADSample(uint8 ch)
  0701    00F6    LD	0x76,A
222:              {
223:              	ADCON1 = 0x00;					//左对齐
  0702    019F    CLR	0x1F
224:              	ADCON0 = 0X41 | ( ch << 2);	//16分频
  0703    00F5    LD	0x75,A
  0704    3001    LDIA	0x1
  0705    1003    CLRB	0x3,0
  0706    0DF5    RLCR	0x75
  0707    3EFF    ADDIA	0xFF
  0708    1003    CLRB	0x3,0
  0709    1D03    SNZB	0x3,2
  070A    2F06    JP	0x706
  070B    0D75    RLCA	0x75
  070C    3841    ORIA	0x41
  070D    1283    CLRB	0x3,5
  070E    009F    LD	0x1F,A
  070F    0000    NOP
  0710    0000    NOP
225:              	asm("nop");
226:              	asm("nop");
227:              	GODONE = 1;						//开始转换
  0711    1283    CLRB	0x3,5
  0712    1303    CLRB	0x3,6
  0713    149F    SETB	0x1F,1
228:              	volatile unsigned char i = 0;
  0714    01F7    CLR	0x77
229:              	while(GODONE)
  0715    1C9F    SNZB	0x1F,1
  0716    3401    RET	0x1
230:              	{
231:              		if(0 == (--i))				//ad等待限时，防止拔插电后出现死循环
  0717    0BF7    SZDECR	0x77
  0718    2F15    JP	0x715
232:              			return 0;
  0719    3400    RET	0x0
233:              	}
234:              	return 1;
235:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  061D    01D1    CLR	0x51
  061E    01D2    CLR	0x52
  061F    0875    LD	A,0x75
  0620    0476    ORA	0x76
  0621    1903    SZB	0x3,2
  0622    2E42    JP	0x642
  0623    01D0    CLR	0x50
  0624    0AD0    INCR	0x50
  0625    1BF6    SZB	0x76,7
  0626    2E2B    JP	0x62B
  0627    1003    CLRB	0x3,0
  0628    0DF5    RLCR	0x75
  0629    0DF6    RLCR	0x76
  062A    2E24    JP	0x624
  062B    1003    CLRB	0x3,0
  062C    0DD1    RLCR	0x51
  062D    0DD2    RLCR	0x52
  062E    0876    LD	A,0x76
  062F    0278    SUBA	0x78
  0630    1D03    SNZB	0x3,2
  0631    2E34    JP	0x634
  0632    0875    LD	A,0x75
  0633    0277    SUBA	0x77
  0634    1C03    SNZB	0x3,0
  0635    2E3E    JP	0x63E
  0636    0875    LD	A,0x75
  0637    02F7    SUBR	0x77
  0638    0876    LD	A,0x76
  0639    1C03    SNZB	0x3,0
  063A    03F8    DECR	0x78
  063B    02F8    SUBR	0x78
  063C    1451    SETB	0x51,0
  063D    1003    CLRB	0x3,0
  063E    0CF6    RRCR	0x76
  063F    0CF5    RRCR	0x75
  0640    0BD0    SZDECR	0x50
  0641    2E2B    JP	0x62B
  0642    0852    LD	A,0x52
  0643    00F6    LD	0x76,A
  0644    0851    LD	A,0x51
  0645    00F5    LD	0x75,A
  0646    0008    RET
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\Motor.c ----------------------------------------------------------------------
1:                #include "Motor.h"
2:                
3:                uint16 WorkCnt=0;
4:                uint16 TimeDecCnt=0;
5:                uint16 TimeAddCnt=0;
6:                
7:                void Motor()
8:                {
9:                    if(!WorkFlag)
  040D    1971    SZB	0x71,2
  040E    2C15    JP	0x415
10:                   {
11:                       MotorOff();
  040F    1185    CLRB	0x5,3
12:                       WorkCnt=0;
  0410    01AD    CLR	0x2D
  0411    01AE    CLR	0x2E
13:                       TimeDecCnt=0;
  0412    01AB    CLR	0x2B
  0413    01AC    CLR	0x2C
14:                   }
  0414    2C3C    JP	0x43C
15:                   else if(WorkFlag&&!LockSta.LockFlag)
  0415    1971    SZB	0x71,2
  0416    1B33    SZB	0x33,6
  0417    2C3C    JP	0x43C
16:                   {
17:                       MotorOn();
  0418    1585    SETB	0x5,3
18:                       TimeDecCnt++;
  0419    0AAB    INCR	0x2B
  041A    1903    SZB	0x3,2
  041B    0AAC    INCR	0x2C
19:                       if(TimeDecCnt>=BatDecTime*100)
  041C    086A    LD	A,0x6A
  041D    245D    CALL	0x45D
  041E    26E8    CALL	0x6E8
  041F    0876    LD	A,0x76
  0420    022C    SUBA	0x2C
  0421    1D03    SNZB	0x3,2
  0422    2C25    JP	0x425
  0423    0875    LD	A,0x75
  0424    022B    SUBA	0x2B
  0425    1C03    SNZB	0x3,0
  0426    2C2C    JP	0x42C
20:                       {
21:                           TimeDecCnt=0;
  0427    01AB    CLR	0x2B
  0428    01AC    CLR	0x2C
22:                           if(BatPercent)
  0429    0849    LD	A,0x49
  042A    1D03    SNZB	0x3,2
23:                           {
24:                               BatPercent--;
  042B    03C9    DECR	0x49
25:                           }
26:                       }
27:                       WorkCnt++;
  042C    0AAD    INCR	0x2D
  042D    1903    SZB	0x3,2
  042E    0AAE    INCR	0x2E
28:                       if(WorkCnt>=6000)
  042F    3017    LDIA	0x17
  0430    022E    SUBA	0x2E
  0431    3070    LDIA	0x70
  0432    1903    SZB	0x3,2
  0433    022D    SUBA	0x2D
  0434    1C03    SNZB	0x3,0
  0435    2C3C    JP	0x43C
  0436    3063    LDIA	0x63
29:                       {
30:                           WorkCnt=0;
  0437    01AD    CLR	0x2D
  0438    01AE    CLR	0x2E
31:                           if(WorkMin<99)
  0439    027A    SUBA	0x7A
  043A    1C03    SNZB	0x3,0
32:                           {
33:                               WorkMin++;
  043B    0AFA    INCR	0x7A
34:                           }
35:                       }
36:                   }
37:                   if(USBFlag)
  043C    1DF1    SNZB	0x71,3
  043D    2C5A    JP	0x45A
38:                   {
39:                       TimeAddCnt++;
  043E    0AA9    INCR	0x29
  043F    1903    SZB	0x3,2
  0440    0AAA    INCR	0x2A
40:                       if(TimeAddCnt>BatAddTime*100)
  0441    086B    LD	A,0x6B
  0442    245D    CALL	0x45D
  0443    26E8    CALL	0x6E8
  0444    082A    LD	A,0x2A
  0445    0276    SUBA	0x76
  0446    1D03    SNZB	0x3,2
  0447    2C4A    JP	0x44A
  0448    0829    LD	A,0x29
  0449    0275    SUBA	0x75
  044A    1803    SZB	0x3,0
  044B    2C52    JP	0x452
  044C    3063    LDIA	0x63
41:                       {
42:                           TimeAddCnt=0;
  044D    01A9    CLR	0x29
  044E    01AA    CLR	0x2A
43:                           if(BatPercent<99)
  044F    0249    SUBA	0x49
  0450    1C03    SNZB	0x3,0
44:                           {
45:                               BatPercent++;
  0451    0AC9    INCR	0x49
46:                           }
47:                       }
48:                       if(BatPercent<=BAT_3V0)
  0452    307E    LDIA	0x7E
  0453    0249    SUBA	0x49
  0454    1803    SZB	0x3,0
  0455    2C58    JP	0x458
49:                       {
50:                           PIN_EN =false;
  0456    1285    CLRB	0x5,5
51:                       }
  0457    0008    RET
52:                       else
53:                       {
54:                           PIN_EN =true;
  0458    1685    SETB	0x5,5
  0459    0008    RET
55:                       }
56:                   }
57:                   else
58:                   {
59:                       TimeAddCnt=0;
  045A    01A9    CLR	0x29
  045B    01AA    CLR	0x2A
  045C    2C58    JP	0x458
60:                       PIN_EN =true;
61:                   }
62:               }
63:               
64:               
65:               
66:               
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul16.c ----------------------------------------------------------------------
1:                // 16 x 16 bit multiplication with 16 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned int
15:               __wmul(unsigned int multiplier, unsigned int multiplicand)
  06E8    01D0    CLR	0x50
  06E9    01D1    CLR	0x51
  06EA    1C75    SNZB	0x75,0
  06EB    2EF2    JP	0x6F2
  06EC    0877    LD	A,0x77
  06ED    07D0    ADDR	0x50
  06EE    1803    SZB	0x3,0
  06EF    0AD1    INCR	0x51
  06F0    0878    LD	A,0x78
  06F1    07D1    ADDR	0x51
  06F2    1003    CLRB	0x3,0
  06F3    0DF7    RLCR	0x77
  06F4    0DF8    RLCR	0x78
  06F5    1003    CLRB	0x3,0
  06F6    0CF6    RRCR	0x76
  06F7    0CF5    RRCR	0x75
  06F8    0875    LD	A,0x75
  06F9    0476    ORA	0x76
  06FA    1D03    SNZB	0x3,2
  06FB    2EEA    JP	0x6EA
  06FC    0851    LD	A,0x51
  06FD    00F6    LD	0x76,A
  06FE    0850    LD	A,0x50
  06FF    00F5    LD	0x75,A
  0700    0008    RET
16:               {
17:                       unsigned int product;
18:               
19:               #if _Has_hardware_multiply || _Has_large_call_stack
20:               
21:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:               
24:               	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:               /*
26:               a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                      a  b
28:               *      c  d
29:               -----------
30:                    |   bd
31:                    |ad  0
32:                    |bc  0
33:               +  ac| 0  0 (we ignore this intermediate product
34:                            because it does not affect the low 16 bits of the result)
35:               ===========
36:                */
37:                       product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                       product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                       product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:               
41:               #else
42:               
43:               	product = 0;
44:               	do {
45:               		if(multiplier & 1)
46:               			product += multiplicand;
47:               		multiplicand <<= 1;
48:               		multiplier >>= 1;
49:               	} while(multiplier != 0);
50:               
51:               #endif
52:                       return product;
53:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\Key.c ----------------------------------------------------------------------
1:                #include "Key.h"
2:                
3:                bit KeyInBuf=0;
4:                bit KeyPress=0;
5:                uint16 KeyCnt=0;
6:                
7:                bit USBLink=0;
8:                
9:                void KeyScan()
10:               {
11:               	if(!PIN_KEY)
  0024    1283    CLRB	0x3,5
  0025    1303    CLRB	0x3,6
  0026    1B06    SZB	0x6,6
  0027    282A    JP	0x2A
12:               	{
13:               		KeyPress=1;
  0028    17F0    SETB	0x70,7
14:               	}
  0029    282B    JP	0x2B
15:               	else
16:               	{
17:               		KeyPress=0;
  002A    13F0    CLRB	0x70,7
18:               	}
19:               	/*按键判断*/
20:               	if(KeyPress&&KeyCnt<10&&KeyInBuf==KeyPress&&!IovFlag&&(!LowBatFlag||USBFlag))
  002B    1FF0    SNZB	0x70,7
  002C    285C    JP	0x5C
  002D    3000    LDIA	0x0
  002E    0232    SUBA	0x32
  002F    300A    LDIA	0xA
  0030    1903    SZB	0x3,2
  0031    0231    SUBA	0x31
  0032    1803    SZB	0x3,0
  0033    285C    JP	0x5C
  0034    1FF0    SNZB	0x70,7
  0035    2838    JP	0x38
  0036    3001    LDIA	0x1
  0037    2839    JP	0x39
  0038    3000    LDIA	0x0
  0039    00F5    LD	0x75,A
  003A    1EF0    SNZB	0x70,5
  003B    283E    JP	0x3E
  003C    3001    LDIA	0x1
  003D    283F    JP	0x3F
  003E    3000    LDIA	0x0
  003F    0675    XORA	0x75
  0040    1903    SZB	0x3,2
  0041    1A71    SZB	0x71,4
  0042    285C    JP	0x5C
  0043    1EF1    SNZB	0x71,5
  0044    2847    JP	0x47
  0045    1DF1    SNZB	0x71,3
  0046    285C    JP	0x5C
21:               	{
22:               		KeyCnt++;
23:               		if(KeyCnt>=10)
  0047    20F9    CALL	0xF9
  0048    300A    LDIA	0xA
  0049    1903    SZB	0x3,2
  004A    0231    SUBA	0x31
  004B    1C03    SNZB	0x3,0
  004C    28E6    JP	0xE6
24:               		{
25:               			WorkFlag=~WorkFlag; 
  004D    3004    LDIA	0x4
  004E    06F1    XORR	0x71
26:               			if(!WorkFlag&&WorkMin!=0&&!USBFlag&&!LockSta.LockFlag)
  004F    1971    SZB	0x71,2
  0050    2859    JP	0x59
  0051    087A    LD	A,0x7A
  0052    1D03    SNZB	0x3,2
  0053    19F1    SZB	0x71,3
  0054    2859    JP	0x59
  0055    1B33    SZB	0x33,6
  0056    2859    JP	0x59
27:               			{
28:               				OnOffFlag=1;
  0057    1770    SETB	0x70,6
29:               			}
  0058    28E6    JP	0xE6
30:               			else
31:               			{
32:               				OnOffFlag=0;
  0059    1370    CLRB	0x70,6
33:               				WorkMin=0;
  005A    01FA    CLR	0x7A
  005B    28E6    JP	0xE6
34:               			}
35:               		}
36:               	}
37:               	else if(KeyPress&&KeyCnt>=10&&KeyCnt<250&&KeyInBuf==KeyPress&&!USBFlag)
  005C    1FF0    SNZB	0x70,7
  005D    288C    JP	0x8C
  005E    3000    LDIA	0x0
  005F    0232    SUBA	0x32
  0060    300A    LDIA	0xA
  0061    1903    SZB	0x3,2
  0062    0231    SUBA	0x31
  0063    1C03    SNZB	0x3,0
  0064    288C    JP	0x8C
  0065    3000    LDIA	0x0
  0066    0232    SUBA	0x32
  0067    30FA    LDIA	0xFA
  0068    1903    SZB	0x3,2
  0069    0231    SUBA	0x31
  006A    1803    SZB	0x3,0
  006B    288C    JP	0x8C
  006C    1FF0    SNZB	0x70,7
  006D    2870    JP	0x70
  006E    3001    LDIA	0x1
  006F    2871    JP	0x71
  0070    3000    LDIA	0x0
  0071    00F5    LD	0x75,A
  0072    1EF0    SNZB	0x70,5
  0073    2876    JP	0x76
  0074    3001    LDIA	0x1
  0075    2877    JP	0x77
  0076    3000    LDIA	0x0
  0077    0675    XORA	0x75
  0078    1903    SZB	0x3,2
  0079    19F1    SZB	0x71,3
  007A    288C    JP	0x8C
38:               	{
39:               		KeyCnt++;
40:               		if(KeyCnt>=250)
  007B    20F9    CALL	0xF9
  007C    30FA    LDIA	0xFA
  007D    1903    SZB	0x3,2
  007E    0231    SUBA	0x31
  007F    1C03    SNZB	0x3,0
  0080    28E6    JP	0xE6
41:               		{
42:               			LockNumb=2;
  0081    3002    LDIA	0x2
  0082    00C1    LD	0x41,A
43:               			if(!LockSta.LockFlag)
  0083    1B33    SZB	0x33,6
  0084    2888    JP	0x88
44:               			{
45:               				LockSta.LockStart=1;
  0085    1433    SETB	0x33,0
46:               				LockSta.UnlockEnd=0;
  0086    12B3    CLRB	0x33,5
47:               			}
  0087    288A    JP	0x8A
48:               			else
49:               			{
50:               				LockSta.UnlockStart=1;
  0088    15B3    SETB	0x33,3
51:               				LockSta.LockEnd=0;
  0089    1133    CLRB	0x33,2
52:               			}
53:               			OnOffFlag=0;
  008A    1370    CLRB	0x70,6
  008B    28E6    JP	0xE6
54:               		}
55:               	}
56:               	else if(KeyPress&&KeyCnt>=250&&KeyInBuf==KeyPress&&!LockSta.LockEnd&&!LockSta.UnlockEnd)
  008C    1FF0    SNZB	0x70,7
  008D    28C8    JP	0xC8
  008E    3000    LDIA	0x0
  008F    0232    SUBA	0x32
  0090    30FA    LDIA	0xFA
  0091    1903    SZB	0x3,2
  0092    0231    SUBA	0x31
  0093    1C03    SNZB	0x3,0
  0094    28C8    JP	0xC8
  0095    1FF0    SNZB	0x70,7
  0096    2899    JP	0x99
  0097    3001    LDIA	0x1
  0098    289A    JP	0x9A
  0099    3000    LDIA	0x0
  009A    00F5    LD	0x75,A
  009B    1EF0    SNZB	0x70,5
  009C    289F    JP	0x9F
  009D    3001    LDIA	0x1
  009E    28A0    JP	0xA0
  009F    3000    LDIA	0x0
  00A0    0675    XORA	0x75
  00A1    1903    SZB	0x3,2
  00A2    1933    SZB	0x33,2
  00A3    28C8    JP	0xC8
  00A4    1AB3    SZB	0x33,5
  00A5    28C8    JP	0xC8
57:               	{
58:               		KeyCnt++;
  00A6    0AB1    INCR	0x31
  00A7    1903    SZB	0x3,2
  00A8    0AB2    INCR	0x32
59:               		if(KeyCnt>=1750)
  00A9    3006    LDIA	0x6
  00AA    0232    SUBA	0x32
  00AB    30D6    LDIA	0xD6
  00AC    1903    SZB	0x3,2
  00AD    0231    SUBA	0x31
  00AE    1C03    SNZB	0x3,0
  00AF    28E6    JP	0xE6
60:               		{
61:               			KeyCnt=1750;
  00B0    30D6    LDIA	0xD6
  00B1    00B1    LD	0x31,A
  00B2    3006    LDIA	0x6
  00B3    00B2    LD	0x32,A
62:               			LockSta.LockFlag=!LockSta.LockFlag;
  00B4    1003    CLRB	0x3,0
  00B5    1F33    SNZB	0x33,6
  00B6    1403    SETB	0x3,0
  00B7    1283    CLRB	0x3,5
  00B8    1303    CLRB	0x3,6
  00B9    1C03    SNZB	0x3,0
  00BA    28BD    JP	0xBD
  00BB    1733    SETB	0x33,6
  00BC    28BE    JP	0xBE
  00BD    1333    CLRB	0x33,6
63:               			if(LockSta.LockFlag)
  00BE    1F33    SNZB	0x33,6
  00BF    28C4    JP	0xC4
64:               			{
65:               				LockSta.LockStart=0;
  00C0    1033    CLRB	0x33,0
66:               				LockSta.LockEnd=1;
  00C1    1533    SETB	0x33,2
67:               				WorkFlag=0;
  00C2    1171    CLRB	0x71,2
68:               			}
  00C3    28E6    JP	0xE6
69:               			else
70:               			{
71:               				LockSta.UnlockStart=0;
  00C4    11B3    CLRB	0x33,3
72:               				LockSta.UnlockEnd=1;
  00C5    16B3    SETB	0x33,5
73:               				WorkFlag=1;
  00C6    1571    SETB	0x71,2
  00C7    28E6    JP	0xE6
74:               			}
75:               		}
76:               	}
77:               	else if(!KeyPress||KeyInBuf!=KeyPress)
  00C8    1FF0    SNZB	0x70,7
  00C9    28D8    JP	0xD8
  00CA    1FF0    SNZB	0x70,7
  00CB    28CE    JP	0xCE
  00CC    3001    LDIA	0x1
  00CD    28CF    JP	0xCF
  00CE    3000    LDIA	0x0
  00CF    00F5    LD	0x75,A
  00D0    1EF0    SNZB	0x70,5
  00D1    28D4    JP	0xD4
  00D2    3001    LDIA	0x1
  00D3    28D5    JP	0xD5
  00D4    3000    LDIA	0x0
  00D5    0675    XORA	0x75
  00D6    1903    SZB	0x3,2
  00D7    28E6    JP	0xE6
78:               	{
79:               		KeyCnt=0;
  00D8    01B1    CLR	0x31
  00D9    01B2    CLR	0x32
80:               		LockSta.UnlockEnd=0;
  00DA    12B3    CLRB	0x33,5
81:               		if((LockSta.LockFlag&&WorkFlag)||LockSta.UnlockStart)
  00DB    1F33    SNZB	0x33,6
  00DC    28DF    JP	0xDF
  00DD    1971    SZB	0x71,2
  00DE    28E1    JP	0xE1
  00DF    1DB3    SNZB	0x33,3
  00E0    28E4    JP	0xE4
82:               		{
83:               			LockSta.UnlockStart=0;
  00E1    11B3    CLRB	0x33,3
84:               			LockSta.UnlockFail=1;
  00E2    1633    SETB	0x33,4
85:               			WorkFlag=0;
  00E3    1171    CLRB	0x71,2
86:               		}
87:               		if(LockSta.LockStart)
  00E4    1833    SZB	0x33,0
88:               		{
89:               			LockSta.LockStart=0;
  00E5    1033    CLRB	0x33,0
90:               		}
91:               	}
92:               	KeyInBuf=KeyPress;
  00E6    12F0    CLRB	0x70,5
  00E7    1BF0    SZB	0x70,7
  00E8    16F0    SETB	0x70,5
93:               
94:               	if(!PIN_USB)
  00E9    1283    CLRB	0x3,5
  00EA    1303    CLRB	0x3,6
  00EB    1B86    SZB	0x6,7
  00EC    28EF    JP	0xEF
95:               	{
96:               		USBLink=1;
  00ED    1670    SETB	0x70,4
97:               	}
  00EE    28F0    JP	0xF0
98:               	else
99:               	{
100:              		USBLink=0;
  00EF    1270    CLRB	0x70,4
101:              	}
102:              	/*USB判断*/
103:              	if(USBLink&&!IovFlag)
  00F0    1A70    SZB	0x70,4
  00F1    1A71    SZB	0x71,4
  00F2    28F6    JP	0xF6
104:              	{
105:              		USBFlag=1;
  00F3    15F1    SETB	0x71,3
106:              		LockSta.LockFlag=0;
  00F4    1333    CLRB	0x33,6
107:              	}
  00F5    0008    RET
108:              	else if(!USBLink)
  00F6    1E70    SNZB	0x70,4
109:              	{
110:              		USBFlag=0;
  00F7    11F1    CLRB	0x71,3
  00F8    0008    RET
111:              	}
112:              }
113:              
---- C:\Users\Administrator\Desktop\project\K13-01\code\LED.c ----------------------------------------------------------------------
1:                #include "LED.h"
2:                
3:                uint8 NumbArr[10]={0x77,0x24,0x5D,0X6D,0X2E,0X6B,0X7B,0X25,0X7F,0X2F};//数字
4:                uint8 HideNumbArr[11]={0,0x40,0x70,0x78,0x7E,0x7F,0x3F,0X0F,0x07,0X01,0};//自下往上扫描
5:                uint16 OffHideNumbArr[7]={0,0x12,0x5B,0X7F,0x97F,0x2DFF,0x3FFF};
6:                // const uint8 LEDSeg1[16][2]=
7:                // {
8:                //     {1,0},{2,1},{2,0},{3,1},{0,1},{3,0},{4,0},//上到下，左到右排序,左数字
9:                //     {0,2},{1,3},{1,2},{2,3},{0,3},{3,2},{4,2},//上到下，左到右排序,右数字
10:               //     {0,4},{1,4}//感叹号、锁
11:               // };
12:               const uint8 LEDSeg1[16]={1,2,2,3,0,3,4,0,1,1,2,0,3,4,0,1};
13:               uint8 LEDSeg2[16]={0,1,0,1,1,0,0,2,3,2,3,3,2,2,4,4};
14:               uint16 LedIndex=0;
15:               uint8 LEDArrMap[5]={0};
16:               
17:               void LEDScan()
18:               {
19:                   static uint8 LEDScanIndex=0;
20:               
21:                   Pin_LED1_CFG(IN,0);
  029D    1683    SETB	0x3,5
  029E    1686    SETB	0x6,5
  029F    1295    CLRB	0x15,5
22:                   Pin_LED2_CFG(IN,0);
  02A0    1606    SETB	0x6,4
  02A1    1215    CLRB	0x15,4
23:                   Pin_LED3_CFG(IN,0);
  02A2    1586    SETB	0x6,3
  02A3    1195    CLRB	0x15,3
24:                   Pin_LED4_CFG(IN,0);
  02A4    1587    SETB	0x7,3
  02A5    1703    SETB	0x3,6
  02A6    118F    CLRB	0xF,3
25:                   Pin_LED5_CFG(IN,0);
  02A7    1303    CLRB	0x3,6
  02A8    1507    SETB	0x7,2
  02A9    1703    SETB	0x3,6
  02AA    110F    CLRB	0xF,2
  02AB    0000    NOP
  02AC    0000    NOP
26:                   asm("nop");	asm("nop");
27:               
28:                   switch(LEDScanIndex)
  02AD    2B03    JP	0x303
29:                   {
30:                       case 0:
31:                       if(LEDArrMap[0]&0x02) 
  02AE    1CA0    SNZB	0x20,1
  02AF    2AB1    JP	0x2B1
32:                       {
33:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  02B0    2332    CALL	0x332
34:                       }
35:               		if(LEDArrMap[0]&0x04)  
  02B1    1D20    SNZB	0x20,2
  02B2    2AB4    JP	0x2B4
36:                       {
37:                           Pin_LED3_CFG(OUT,0);PIN_LED3=L ;
  02B3    232C    CALL	0x32C
38:                       }
39:               		if(LEDArrMap[0]&0x08) 
  02B4    1DA0    SNZB	0x20,3
  02B5    2AB7    JP	0x2B7
40:                       {
41:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  02B6    2316    CALL	0x316
42:                       }
43:               		if(LEDArrMap[0]&0x10) 
  02B7    1E20    SNZB	0x20,4
  02B8    2ABA    JP	0x2BA
44:                       {
45:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  02B9    231E    CALL	0x31E
46:                       }
47:               		Pin_LED1_CFG(OUT,0);PIN_LED1=H ;
  02BA    1683    SETB	0x3,5
  02BB    1286    CLRB	0x6,5
  02BC    1295    CLRB	0x15,5
  02BD    1283    CLRB	0x3,5
  02BE    1686    SETB	0x6,5
48:                       break;
  02BF    2B10    JP	0x310
49:               
50:                       case 1:
51:                       if(LEDArrMap[1]&0x01)
  02C0    1C21    SNZB	0x21,0
  02C1    2AC3    JP	0x2C3
52:                       {
53:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  02C2    2326    CALL	0x326
54:                       } 
55:                       if(LEDArrMap[1]&0x04) 
  02C3    1D21    SNZB	0x21,2
  02C4    2AC6    JP	0x2C6
56:                       {
57:                           Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  02C5    232C    CALL	0x32C
58:                       }
59:                       if(LEDArrMap[1]&0x08) 
  02C6    1DA1    SNZB	0x21,3
  02C7    2AC9    JP	0x2C9
60:                       {
61:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  02C8    2316    CALL	0x316
62:                       }
63:                       if(LEDArrMap[1]&0x10)
  02C9    1E21    SNZB	0x21,4
  02CA    2ACC    JP	0x2CC
64:                       {
65:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  02CB    231E    CALL	0x31E
66:                       } 
67:                       Pin_LED2_CFG(OUT,0); PIN_LED2=H ;
  02CC    1683    SETB	0x3,5
  02CD    1206    CLRB	0x6,4
  02CE    1215    CLRB	0x15,4
  02CF    1283    CLRB	0x3,5
  02D0    1606    SETB	0x6,4
68:                       break;
  02D1    2B10    JP	0x310
69:               
70:                       case 2:
71:                       if(LEDArrMap[2]&0x01) 
  02D2    1C22    SNZB	0x22,0
  02D3    2AD5    JP	0x2D5
72:                       {
73:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  02D4    2326    CALL	0x326
74:                       }
75:               		if(LEDArrMap[2]&0x02) 
  02D5    1CA2    SNZB	0x22,1
  02D6    2AD8    JP	0x2D8
76:                       {
77:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  02D7    2332    CALL	0x332
78:                       }
79:               		if(LEDArrMap[2]&0x08) 
  02D8    1DA2    SNZB	0x22,3
  02D9    2ADB    JP	0x2DB
80:                       {
81:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  02DA    2316    CALL	0x316
82:                       }
83:               		if(LEDArrMap[2]&0x10) 
  02DB    1E22    SNZB	0x22,4
  02DC    2ADE    JP	0x2DE
84:                       {
85:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  02DD    231E    CALL	0x31E
86:                       }
87:               		Pin_LED3_CFG(OUT,0);PIN_LED3=H ;
  02DE    1683    SETB	0x3,5
  02DF    1186    CLRB	0x6,3
  02E0    1195    CLRB	0x15,3
  02E1    1283    CLRB	0x3,5
  02E2    1586    SETB	0x6,3
88:                       break;
  02E3    2B10    JP	0x310
89:               
90:                       case 3:
91:                       if(LEDArrMap[3]&0x01)
  02E4    1C23    SNZB	0x23,0
  02E5    2AE7    JP	0x2E7
92:                       {
93:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  02E6    2326    CALL	0x326
94:                       }
95:               		if(LEDArrMap[3]&0x02)
  02E7    1CA3    SNZB	0x23,1
  02E8    2AEA    JP	0x2EA
96:                       {
97:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  02E9    2332    CALL	0x332
98:                       }
99:               		if(LEDArrMap[3]&0x04)
  02EA    1D23    SNZB	0x23,2
  02EB    2AED    JP	0x2ED
100:                      {
101:                          Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  02EC    232C    CALL	0x32C
102:                      }
103:              		Pin_LED4_CFG(OUT,0);PIN_LED4=H ;
  02ED    1683    SETB	0x3,5
  02EE    1187    CLRB	0x7,3
  02EF    1703    SETB	0x3,6
  02F0    118F    CLRB	0xF,3
  02F1    1283    CLRB	0x3,5
  02F2    1303    CLRB	0x3,6
  02F3    1587    SETB	0x7,3
104:                      break;
  02F4    2B10    JP	0x310
105:              
106:                      case 4:
107:                      if(LEDArrMap[4]&0x01)
  02F5    1C24    SNZB	0x24,0
  02F6    2AF8    JP	0x2F8
108:                      {
109:                          Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  02F7    2326    CALL	0x326
110:                      }
111:              		if(LEDArrMap[4]&0x04)
  02F8    1D24    SNZB	0x24,2
  02F9    2AFB    JP	0x2FB
112:                      {
113:                          Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  02FA    232C    CALL	0x32C
114:                      }
115:                      Pin_LED5_CFG(OUT,0);PIN_LED5=H ;
  02FB    1683    SETB	0x3,5
  02FC    1107    CLRB	0x7,2
  02FD    1703    SETB	0x3,6
  02FE    110F    CLRB	0xF,2
  02FF    1283    CLRB	0x3,5
  0300    1303    CLRB	0x3,6
  0301    1507    SETB	0x7,2
116:                  }
  0302    2B10    JP	0x310
  0303    1283    CLRB	0x3,5
  0304    1303    CLRB	0x3,6
  0305    083E    LD	A,0x3E
  0306    0084    LD	0x4,A
  0307    3005    LDIA	0x5
  0308    0204    SUBA	0x4
  0309    1803    SZB	0x3,0
  030A    2B10    JP	0x310
  030B    3007    LDIA	0x7
  030C    008A    LD	0xA,A
  030D    3089    LDIA	0x89
  030E    0704    ADDA	0x4
  030F    0082    LD	0x2,A
  0310    3005    LDIA	0x5
117:                  LEDScanIndex++;
  0311    0ABE    INCR	0x3E
118:                  if(LEDScanIndex>=5)
  0312    023E    SUBA	0x3E
  0313    1803    SZB	0x3,0
119:                  {
120:                      LEDScanIndex=0;
  0314    01BE    CLR	0x3E
  0315    0008    RET
121:                  }
122:              }
123:              
124:              void DisplayIcon(uint16 index)
125:              {
126:                  uint8 i=0;
127:                  uint16 Mask=0x01;
  057D    01D0    CLR	0x50
  057E    0AD0    INCR	0x50
  057F    01D1    CLR	0x51
128:              
129:                  for(i=0;i<16;i++)
  0580    01D2    CLR	0x52
130:                  {
131:                      if(index&Mask)
  0581    0850    LD	A,0x50
  0582    0575    ANDA	0x75
  0583    00F7    LD	0x77,A
  0584    0851    LD	A,0x51
  0585    0576    ANDA	0x76
  0586    00F8    LD	0x78,A
  0587    0477    ORA	0x77
132:                      {
133:                          LEDArrMap[LEDSeg1[i]]|=(1<<LEDSeg2[i]);
  0588    3001    LDIA	0x1
  0589    00F7    LD	0x77,A
  058A    1903    SZB	0x3,2
  058B    2D94    JP	0x594
  058C    25A5    CALL	0x5A5
  058D    25B2    CALL	0x5B2
  058E    271A    CALL	0x71A
  058F    3E20    ADDIA	0x20
  0590    0084    LD	0x4,A
  0591    0878    LD	A,0x78
  0592    0480    ORR	0x0
134:                      }
  0593    2D9C    JP	0x59C
135:                      else
136:                      {
137:                          LEDArrMap[LEDSeg1[i]]&=~(1<<LEDSeg2[i]);
  0594    25A5    CALL	0x5A5
  0595    3AFF    XORIA	0xFF
  0596    25B2    CALL	0x5B2
  0597    271A    CALL	0x71A
  0598    3E20    ADDIA	0x20
  0599    0084    LD	0x4,A
  059A    0878    LD	A,0x78
  059B    0580    ANDR	0x0
  059C    3010    LDIA	0x10
138:                      }
139:                      
140:                      Mask<<=1;
  059D    1003    CLRB	0x3,0
  059E    0DD0    RLCR	0x50
  059F    0DD1    RLCR	0x51
  05A0    0AD2    INCR	0x52
  05A1    0252    SUBA	0x52
  05A2    1803    SZB	0x3,0
  05A3    0008    RET
  05A4    2D81    JP	0x581
141:                  }
142:              }
143:              
144:              void DisplayPro()
145:              {
146:                  LedIndex=0;
  076D    01AF    CLR	0x2F
  076E    01B0    CLR	0x30
147:                  WorkLedPro();
  076F    2338    CALL	0x338
148:                  USBLedPro();
  0770    23AE    CALL	0x3AE
149:                  LockPro();
  0771    24AF    CALL	0x4AF
150:                  ErrPro();
  0772    2730    CALL	0x730
151:                  DisplayIcon(LedIndex);
  0773    0830    LD	A,0x30
  0774    00F6    LD	0x76,A
  0775    082F    LD	A,0x2F
  0776    00F5    LD	0x75,A
  0777    2D7D    JP	0x57D
152:              }
153:              
154:              void USBLedPro()
155:              {
156:                  static uint8 index=0;
157:                  static uint8 cnt=0;
158:              
159:                  if(USBFlag&&!WorkFlag&&!OnOffFlag)//充电正常
  03AE    19F1    SZB	0x71,3
  03AF    1971    SZB	0x71,2
  03B0    2C00    JP	0x400
  03B1    1B70    SZB	0x70,6
  03B2    2C00    JP	0x400
  03B3    3028    LDIA	0x28
160:                  {
161:                      cnt++;
  03B4    0ABC    INCR	0x3C
162:                      if(cnt>=40)
  03B5    023C    SUBA	0x3C
  03B6    1C03    SNZB	0x3,0
  03B7    2BBE    JP	0x3BE
  03B8    300B    LDIA	0xB
163:                      {
164:                          cnt=0;
  03B9    01BC    CLR	0x3C
165:                          index++;
  03BA    0ABD    INCR	0x3D
166:                          if(index>=11)
  03BB    023D    SUBA	0x3D
  03BC    1803    SZB	0x3,0
167:                          {
168:                              index=0;
  03BD    01BD    CLR	0x3D
169:                          }
170:                      }
171:                      if(BatPercent<99)
  03BE    3063    LDIA	0x63
  03BF    0249    SUBA	0x49
172:                      {
173:                          LedIndex=NumbArr[BatPercent/10];
  03C0    300A    LDIA	0xA
  03C1    1803    SZB	0x3,0
  03C2    2BE9    JP	0x3E9
  03C3    00F5    LD	0x75,A
  03C4    0849    LD	A,0x49
  03C5    26B2    CALL	0x6B2
174:                          LedIndex|=((uint16)NumbArr[BatPercent%10]&~HideNumbArr[index])<<7;
  03C6    2403    CALL	0x403
  03C7    2696    CALL	0x696
  03C8    3EC9    ADDIA	0xC9
  03C9    0084    LD	0x4,A
  03CA    0800    LD	A,0x0
  03CB    00D0    LD	0x50,A
  03CC    083D    LD	A,0x3D
  03CD    3EBE    ADDIA	0xBE
  03CE    0084    LD	0x4,A
  03CF    0900    COMA	0x0
  03D0    0550    ANDA	0x50
  03D1    00D1    LD	0x51,A
  03D2    3007    LDIA	0x7
  03D3    01D2    CLR	0x52
  03D4    00FF    LD	0x7F,A
  03D5    1003    CLRB	0x3,0
  03D6    0DD1    RLCR	0x51
  03D7    0DD2    RLCR	0x52
  03D8    0BFF    SZDECR	0x7F
  03D9    2BD5    JP	0x3D5
  03DA    0851    LD	A,0x51
  03DB    04AF    ORR	0x2F
  03DC    0852    LD	A,0x52
  03DD    04B0    ORR	0x30
175:                          LedIndex&=~HideNumbArr[index];
  03DE    083D    LD	A,0x3D
  03DF    3EBE    ADDIA	0xBE
  03E0    0084    LD	0x4,A
  03E1    0900    COMA	0x0
  03E2    00D0    LD	0x50,A
  03E3    01D1    CLR	0x51
  03E4    09D1    COMR	0x51
  03E5    05AF    ANDR	0x2F
  03E6    0851    LD	A,0x51
  03E7    05B0    ANDR	0x30
176:                      }
  03E8    0008    RET
177:                      else
178:                      {
179:                          index=0;
  03E9    01BD    CLR	0x3D
180:                          LedIndex=NumbArr[BatPercent/10];
  03EA    00F5    LD	0x75,A
  03EB    0849    LD	A,0x49
  03EC    26B2    CALL	0x6B2
181:                          LedIndex|=NumbArr[BatPercent%10]<<7;
  03ED    2403    CALL	0x403
  03EE    2696    CALL	0x696
  03EF    3EC9    ADDIA	0xC9
  03F0    0084    LD	0x4,A
  03F1    0800    LD	A,0x0
  03F2    00D0    LD	0x50,A
  03F3    3007    LDIA	0x7
  03F4    01D1    CLR	0x51
  03F5    00FF    LD	0x7F,A
  03F6    1003    CLRB	0x3,0
  03F7    0DD0    RLCR	0x50
  03F8    0DD1    RLCR	0x51
  03F9    0BFF    SZDECR	0x7F
  03FA    2BF6    JP	0x3F6
  03FB    0850    LD	A,0x50
  03FC    04AF    ORR	0x2F
  03FD    0851    LD	A,0x51
  03FE    04B0    ORR	0x30
  03FF    0008    RET
182:                      }
183:                      
184:                  }
185:                  else
186:                  {
187:                      index=0;
  0400    01BD    CLR	0x3D
188:                      cnt=0;
  0401    01BC    CLR	0x3C
  0402    0008    RET
189:                  }
190:              }
191:              
192:              void WorkLedPro()
193:              {
194:                  static int8 LedSwitchCnt=0;
195:                  static bit LedSwitchFlag=0;
196:                  static int8 index=0;
197:                  static uint8 cnt=0;
198:                  static bit dir=0;
199:                  if(WorkFlag&&!LockSta.LockStart&&!OnOffFlag&&!LockSta.LockFlag)
  0338    1971    SZB	0x71,2
  0339    1833    SZB	0x33,0
  033A    2B57    JP	0x357
  033B    1F70    SNZB	0x70,6
  033C    1B33    SZB	0x33,6
  033D    2B57    JP	0x357
200:                  {
201:                      if(BatPercent<=10)
  033E    300B    LDIA	0xB
  033F    0249    SUBA	0x49
  0340    1803    SZB	0x3,0
  0341    2B4B    JP	0x34B
  0342    3028    LDIA	0x28
202:                      {
203:                          LedSwitchCnt++;
  0343    0ABB    INCR	0x3B
204:                          if(LedSwitchCnt>=40)
  0344    023B    SUBA	0x3B
  0345    1C03    SNZB	0x3,0
  0346    2B4D    JP	0x34D
  0347    3008    LDIA	0x8
205:                          {
206:                              LedSwitchCnt=0;
  0348    01BB    CLR	0x3B
207:                              LedSwitchFlag=!LedSwitchFlag;
  0349    06F0    XORR	0x70
  034A    2B4D    JP	0x34D
208:                          }
209:                      }
210:                      else
211:                      {
212:                          LedSwitchCnt=0;
  034B    01BB    CLR	0x3B
213:                          LedSwitchFlag=1;
  034C    15F0    SETB	0x70,3
214:                      }
215:                      if(LedSwitchFlag)
  034D    1DF0    SNZB	0x70,3
  034E    0008    RET
216:                      {
217:                          LedIndex=NumbArr[BatPercent/10];
  034F    300A    LDIA	0xA
  0350    00F5    LD	0x75,A
  0351    0849    LD	A,0x49
  0352    26B2    CALL	0x6B2
218:                          LedIndex|=(uint16)NumbArr[BatPercent%10]<<7;
  0353    2403    CALL	0x403
  0354    2696    CALL	0x696
  0355    2391    CALL	0x391
  0356    0008    RET
219:                      }
220:                  }
221:                  else if(OnOffFlag)
  0357    1F70    SNZB	0x70,6
  0358    0008    RET
  0359    3028    LDIA	0x28
222:                  {
223:                      cnt++;
  035A    0AB9    INCR	0x39
224:                      if(cnt>=40)
  035B    0239    SUBA	0x39
  035C    1C03    SNZB	0x3,0
  035D    2B6C    JP	0x36C
  035E    3007    LDIA	0x7
225:                      {
226:                          cnt=0;
  035F    01B9    CLR	0x39
227:                          index++;
  0360    0ABA    INCR	0x3A
228:                          if(index>=7)
  0361    023A    SUBA	0x3A
  0362    1C03    SNZB	0x3,0
  0363    2B6C    JP	0x36C
229:                          {
230:                              if(dir)
  0364    1D70    SNZB	0x70,2
  0365    2B69    JP	0x369
231:                              {
232:                                  OnOffFlag=0;
  0366    1370    CLRB	0x70,6
233:                                  WorkMin=0;
  0367    01FA    CLR	0x7A
  0368    0008    RET
234:                                  return;
235:                              }
236:                              dir=!dir;
  0369    3004    LDIA	0x4
  036A    06F0    XORR	0x70
237:                              index=0;
  036B    01BA    CLR	0x3A
238:                          }
239:                      }
240:                      if(!dir)
  036C    1970    SZB	0x70,2
  036D    2B7A    JP	0x37A
241:                      {
242:                          LedIndex=NumbArr[BatPercent/10];
  036E    300A    LDIA	0xA
  036F    00F5    LD	0x75,A
  0370    0849    LD	A,0x49
  0371    26B2    CALL	0x6B2
243:                          LedIndex|=(uint16)NumbArr[BatPercent%10]<<7;
  0372    2403    CALL	0x403
  0373    2696    CALL	0x696
  0374    2391    CALL	0x391
244:                          LedIndex&=~OffHideNumbArr[index];
  0375    1003    CLRB	0x3,0
  0376    0D3A    RLCA	0x3A
  0377    3EB0    ADDIA	0xB0
  0378    0084    LD	0x4,A
245:                      }
  0379    2BA2    JP	0x3A2
246:                      else
247:                      {
248:                          LedIndex=NumbArr[WorkMin/10];
  037A    300A    LDIA	0xA
  037B    00F5    LD	0x75,A
  037C    087A    LD	A,0x7A
  037D    26B2    CALL	0x6B2
  037E    3EC9    ADDIA	0xC9
  037F    0084    LD	0x4,A
  0380    1383    CLRB	0x3,7
  0381    0800    LD	A,0x0
  0382    00AF    LD	0x2F,A
  0383    300A    LDIA	0xA
  0384    01B0    CLR	0x30
249:                          LedIndex|=(uint16)NumbArr[WorkMin%10]<<7;
  0385    00F5    LD	0x75,A
  0386    087A    LD	A,0x7A
  0387    2696    CALL	0x696
  0388    2391    CALL	0x391
250:                          LedIndex&=~OffHideNumbArr[6-index];
  0389    30FE    LDIA	0xFE
  038A    00F5    LD	0x75,A
  038B    083A    LD	A,0x3A
  038C    275F    CALL	0x75F
  038D    3EBC    ADDIA	0xBC
  038E    0084    LD	0x4,A
  038F    1383    CLRB	0x3,7
  0390    2BA2    JP	0x3A2
251:                      }
252:                  }
253:              }
254:              
255:              void LockPro()
256:              {
257:                  static uint8 SwitchCnt=0,LockSwitchCnt=0;
258:                  static uint8 Ledcnt=0;
259:                  static bit LedSwitchFlag=0;
260:                  if(!USBFlag)
  04AF    19F1    SZB	0x71,3
  04B0    0008    RET
261:                  {
262:                      if(LockSta.LockStart||LockSta.UnlockStart)
  04B1    1833    SZB	0x33,0
  04B2    2CB5    JP	0x4B5
  04B3    1DB3    SNZB	0x33,3
  04B4    2CDA    JP	0x4DA
  04B5    3064    LDIA	0x64
263:                      {
264:                          SwitchCnt++;
  04B6    0AB8    INCR	0x38
265:                          if(SwitchCnt>=100)
  04B7    0238    SUBA	0x38
  04B8    1C03    SNZB	0x3,0
  04B9    2CBF    JP	0x4BF
266:                          {
267:                              SwitchCnt=0;
  04BA    01B8    CLR	0x38
268:                              if(LockNumb>0)
  04BB    0841    LD	A,0x41
  04BC    1903    SZB	0x3,2
  04BD    2CBF    JP	0x4BF
269:                              {
270:                                  LockNumb--;
  04BE    03C1    DECR	0x41
271:                              }
272:                          }
273:                          LedIndex=NumbArr[0];
  04BF    1683    SETB	0x3,5
  04C0    0849    LD	A,0x49
  04C1    1283    CLRB	0x3,5
  04C2    00AF    LD	0x2F,A
  04C3    01B0    CLR	0x30
274:                          LedIndex|=(uint16)NumbArr[LockNumb+1]<<7;
  04C4    0841    LD	A,0x41
  04C5    3ECA    ADDIA	0xCA
  04C6    0084    LD	0x4,A
  04C7    1383    CLRB	0x3,7
  04C8    0800    LD	A,0x0
  04C9    00F5    LD	0x75,A
  04CA    3007    LDIA	0x7
  04CB    01F6    CLR	0x76
  04CC    00FF    LD	0x7F,A
  04CD    1003    CLRB	0x3,0
  04CE    0DF5    RLCR	0x75
  04CF    0DF6    RLCR	0x76
  04D0    0BFF    SZDECR	0x7F
  04D1    2CCD    JP	0x4CD
  04D2    0875    LD	A,0x75
  04D3    04AF    ORR	0x2F
  04D4    0876    LD	A,0x76
  04D5    04B0    ORR	0x30
275:                          if(LockSta.UnlockStart)
  04D6    1DB3    SNZB	0x33,3
  04D7    2CDB    JP	0x4DB
276:                          {
277:                              LedIndex|=iconLock;
  04D8    17B0    SETB	0x30,7
  04D9    2CDB    JP	0x4DB
278:                          }
279:                      }
280:                      else
281:                      {
282:                          SwitchCnt=0;
  04DA    01B8    CLR	0x38
283:                      }
284:                      if(LockSta.LockEnd||LockSta.UnlockFail)
  04DB    1933    SZB	0x33,2
  04DC    2CDF    JP	0x4DF
  04DD    1E33    SNZB	0x33,4
  04DE    2CF6    JP	0x4F6
  04DF    3023    LDIA	0x23
285:                      {
286:                          LockSwitchCnt++;
  04E0    0AB7    INCR	0x37
287:                          if(LockSwitchCnt>=35)
  04E1    0237    SUBA	0x37
  04E2    1C03    SNZB	0x3,0
  04E3    2CF0    JP	0x4F0
  04E4    3002    LDIA	0x2
288:                          {
289:                              LockSwitchCnt=0;
  04E5    01B7    CLR	0x37
290:                              LedSwitchFlag=!LedSwitchFlag;
  04E6    06F0    XORR	0x70
291:                              if(!LedSwitchFlag)
  04E7    18F0    SZB	0x70,1
  04E8    2CF0    JP	0x4F0
  04E9    3004    LDIA	0x4
292:                              {
293:                                  Ledcnt++;
  04EA    0AB6    INCR	0x36
294:                                  if(Ledcnt>=4)
  04EB    0236    SUBA	0x36
  04EC    1C03    SNZB	0x3,0
  04ED    2CF0    JP	0x4F0
295:                                  {
296:                                      LockSta.LockEnd=0;
  04EE    1133    CLRB	0x33,2
297:                                      LockSta.UnlockFail=0;
  04EF    1233    CLRB	0x33,4
298:                                  }
299:                              }
300:                          }
301:                          if(LedSwitchFlag)
  04F0    1CF0    SNZB	0x70,1
  04F1    0008    RET
302:                          {
303:                              LedIndex=iconLock;
  04F2    3080    LDIA	0x80
  04F3    01AF    CLR	0x2F
  04F4    00B0    LD	0x30,A
  04F5    0008    RET
304:                          }
305:                      }
306:                      else
307:                      {
308:                          Ledcnt=0;
  04F6    01B6    CLR	0x36
309:                          LockSwitchCnt=0;
  04F7    01B7    CLR	0x37
  04F8    0008    RET
310:                      }
311:                  }
312:              }
313:              
314:              void ErrPro()
315:              {
316:                  static uint8 SwitchCnt=0;
317:                  static bit LedSwitchFlag=0;
318:                  if(IovFlag)
  0730    1E71    SNZB	0x71,4
  0731    2F40    JP	0x740
  0732    3023    LDIA	0x23
319:                  {
320:                      SwitchCnt++;
  0733    0AB5    INCR	0x35
321:                      if(SwitchCnt>=35)
  0734    0235    SUBA	0x35
  0735    1C03    SNZB	0x3,0
  0736    2F3A    JP	0x73A
  0737    3001    LDIA	0x1
322:                      {
323:                          SwitchCnt=0;
  0738    01B5    CLR	0x35
324:                          LedSwitchFlag=!LedSwitchFlag;
  0739    06F0    XORR	0x70
325:              
326:                      }
327:                      if(LedSwitchFlag)
  073A    1C70    SNZB	0x70,0
  073B    0008    RET
328:                      {
329:                          LedIndex=iconErr;
  073C    3040    LDIA	0x40
  073D    01AF    CLR	0x2F
  073E    00B0    LD	0x30,A
  073F    0008    RET
330:                      }
331:                  }
332:                  else
333:                  {
334:                      SwitchCnt=0;
  0740    01B5    CLR	0x35
  0741    0008    RET
335:                  }
336:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul8.c ----------------------------------------------------------------------
1:                // 8 x 8 bit multiplication with 8 bit result
2:                
3:                unsigned char
4:                __bmul(unsigned char multiplier, unsigned char multiplicand)
  075F    00F7    LD	0x77,A
  0760    01F6    CLR	0x76
  0761    0875    LD	A,0x75
  0762    1877    SZB	0x77,0
  0763    07F6    ADDR	0x76
  0764    1003    CLRB	0x3,0
  0765    0DF5    RLCR	0x75
  0766    1003    CLRB	0x3,0
  0767    0CF7    RRCR	0x77
  0768    0877    LD	A,0x77
  0769    1D03    SNZB	0x3,2
  076A    2F61    JP	0x761
  076B    0876    LD	A,0x76
  076C    0008    RET
5:                {
6:                	unsigned char product = 0;
7:                
8:                #if defined(__OPTIMIZE_SPEED__)
9:                
10:               	if(multiplier & 0x01)
11:               		product = (product + multiplicand) & 0xff;
12:               	multiplicand <<= 1;
13:               
14:               	if(multiplier & 0x02)
15:               		product = (product + multiplicand) & 0xff;
16:               	multiplicand <<= 1;
17:               
18:               	if(multiplier & 0x04)
19:               		product = (product + multiplicand) & 0xff;
20:               	multiplicand <<= 1;
21:               
22:               	if(multiplier & 0x08)
23:               		product = (product + multiplicand) & 0xff;
24:               	multiplicand <<= 1;
25:               
26:               	if(multiplier & 0x10)
27:               		product = (product + multiplicand) & 0xff;
28:               	multiplicand <<= 1;
29:               
30:               	if(multiplier & 0x20)
31:               		product = (product + multiplicand) & 0xff;
32:               	multiplicand <<= 1;
33:               
34:               	if(multiplier & 0x40)
35:               		product = (product + multiplicand) & 0xff;
36:               	multiplicand <<= 1;
37:               
38:               	if(multiplier & 0x80)
39:               		product = (product + multiplicand) & 0xff;
40:               
41:               #else
42:               	do {
43:               		if(multiplier & 1)
44:               			product += multiplicand;
45:               		multiplicand <<= 1;
46:               		multiplier >>= 1;
47:               	} while(multiplier != 0);
48:               
49:               #endif
50:               	return product;
51:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  0696    00F7    LD	0x77,A
  0697    3008    LDIA	0x8
  0698    00F8    LD	0x78,A
  0699    01F9    CLR	0x79
  069A    0877    LD	A,0x77
  069B    00F6    LD	0x76,A
  069C    3007    LDIA	0x7
  069D    1003    CLRB	0x3,0
  069E    0CF6    RRCR	0x76
  069F    3EFF    ADDIA	0xFF
  06A0    1003    CLRB	0x3,0
  06A1    1D03    SNZB	0x3,2
  06A2    2E9E    JP	0x69E
  06A3    0D79    RLCA	0x79
  06A4    0476    ORA	0x76
  06A5    00F9    LD	0x79,A
  06A6    1003    CLRB	0x3,0
  06A7    0DF7    RLCR	0x77
  06A8    0875    LD	A,0x75
  06A9    0279    SUBA	0x79
  06AA    1C03    SNZB	0x3,0
  06AB    2EAE    JP	0x6AE
  06AC    0875    LD	A,0x75
  06AD    02F9    SUBR	0x79
  06AE    0BF8    SZDECR	0x78
  06AF    2E9A    JP	0x69A
  06B0    0879    LD	A,0x79
  06B1    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  06B2    00F6    LD	0x76,A
  06B3    01F8    CLR	0x78
  06B4    0875    LD	A,0x75
  06B5    1903    SZB	0x3,2
  06B6    2ECB    JP	0x6CB
  06B7    01F7    CLR	0x77
  06B8    0AF7    INCR	0x77
  06B9    1BF5    SZB	0x75,7
  06BA    2EBE    JP	0x6BE
  06BB    1003    CLRB	0x3,0
  06BC    0DF5    RLCR	0x75
  06BD    2EB8    JP	0x6B8
  06BE    1003    CLRB	0x3,0
  06BF    0DF8    RLCR	0x78
  06C0    0875    LD	A,0x75
  06C1    0276    SUBA	0x76
  06C2    1C03    SNZB	0x3,0
  06C3    2EC8    JP	0x6C8
  06C4    0875    LD	A,0x75
  06C5    02F6    SUBR	0x76
  06C6    1478    SETB	0x78,0
  06C7    1003    CLRB	0x3,0
  06C8    0CF5    RRCR	0x75
  06C9    0BF7    SZDECR	0x77
  06CA    2EBE    JP	0x6BE
  06CB    0878    LD	A,0x78
  06CC    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul32.c ----------------------------------------------------------------------
1:                // 32 x 32 bit multiplication with 32 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned long
15:               __lmul(unsigned long multiplier, unsigned long multiplicand)
  05EA    01F5    CLR	0x75
  05EB    01F6    CLR	0x76
  05EC    01F7    CLR	0x77
  05ED    01F8    CLR	0x78
  05EE    1C50    SNZB	0x50,0
  05EF    2E04    JP	0x604
  05F0    0854    LD	A,0x54
  05F1    07F5    ADDR	0x75
  05F2    0855    LD	A,0x55
  05F3    1103    CLRB	0x3,2
  05F4    1803    SZB	0x3,0
  05F5    3E01    ADDIA	0x1
  05F6    1D03    SNZB	0x3,2
  05F7    07F6    ADDR	0x76
  05F8    0856    LD	A,0x56
  05F9    1103    CLRB	0x3,2
  05FA    1803    SZB	0x3,0
  05FB    3E01    ADDIA	0x1
  05FC    1D03    SNZB	0x3,2
  05FD    07F7    ADDR	0x77
  05FE    0857    LD	A,0x57
  05FF    1103    CLRB	0x3,2
  0600    1803    SZB	0x3,0
  0601    3E01    ADDIA	0x1
  0602    1D03    SNZB	0x3,2
  0603    07F8    ADDR	0x78
  0604    1003    CLRB	0x3,0
  0605    0DD4    RLCR	0x54
  0606    0DD5    RLCR	0x55
  0607    0DD6    RLCR	0x56
  0608    0DD7    RLCR	0x57
  0609    1003    CLRB	0x3,0
  060A    0CD3    RRCR	0x53
  060B    0CD2    RRCR	0x52
  060C    0CD1    RRCR	0x51
  060D    0CD0    RRCR	0x50
  060E    0853    LD	A,0x53
  060F    0452    ORA	0x52
  0610    0451    ORA	0x51
  0611    0450    ORA	0x50
  0612    1D03    SNZB	0x3,2
  0613    2DEE    JP	0x5EE
  0614    0878    LD	A,0x78
  0615    00D3    LD	0x53,A
  0616    0877    LD	A,0x77
  0617    00D2    LD	0x52,A
  0618    0876    LD	A,0x76
  0619    00D1    LD	0x51,A
  061A    0875    LD	A,0x75
  061B    00D0    LD	0x50,A
  061C    0008    RET
16:               {
17:               	unsigned long product;
18:               
19:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:               #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:               #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:               
24:               #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:               	{
26:               
27:               #define USE_SHRINK
28:               
29:               /*
30:               a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                            a  b  c  d
32:               *            e  f  g  h
33:               -----------------------
34:                          |         dh
35:                          |      ch  0
36:                          |   bh  0  0
37:                          |ah  0  0  0
38:                          |      dg  0
39:                          |   cg  0  0
40:                          |bg  0  0  0
41:                        ag| 0  0  0  0 (we ignore this intermediate product
42:                                        because it does not affect the low 32 bits of the result)
43:                          |   df  0  0
44:                          |cf  0  0  0
45:                        bf| 0  0  0  0 (ignore)
46:                     af  0| 0  0  0  0 (ignore)
47:                          |de  0  0  0
48:                        ce| 0  0  0  0 (ignore)
49:                     be  0| 0  0  0  0 (ignore)
50:               +  ae  0  0| 0  0  0  0 (ignore)
51:               =======================
52:                */
53:               		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:               
55:               #if defined(USE_MASKS)
56:               		product += ((unsigned long)
57:               			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:               			     +
59:               			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:               			<< 8;
61:               
62:               		product += ((unsigned long)
63:               			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:               			    +
65:               			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:               			    +
67:               			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:               			<< 16;
69:               
70:               		/* cast to smaller type to avoid adding high bits just to discard */
71:               		product += ((unsigned long)
72:               			    (unsigned char)
73:               			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:               			    +
75:               			    (unsigned char)
76:               			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:               			    +
78:               			    (unsigned char)
79:               			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:               			    +
81:               			    (unsigned char)
82:               			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:               			<< 24;
84:               
85:               #elif defined(USE_SHRINK)
86:               		/* add direct to upper bytes, rather than shift and add all bytes */
87:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:               			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:               			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:               
92:               
93:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:               			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:               			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:               			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:               
100:              		*(((unsigned char*)&product)+3) +=
101:              			(unsigned char)
102:              			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:              		*(((unsigned char*)&product)+3) +=
104:              			(unsigned char)
105:              			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:              		*(((unsigned char*)&product)+3) +=
107:              			(unsigned char)
108:              			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:              		*(((unsigned char*)&product)+3) +=
110:              			(unsigned char)
111:              			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:              
113:              #else
114:              #error No method chosen
115:              #endif
116:              	}
117:              #else
118:              
119:              	product = 0;
120:              	do {
121:              		if(multiplier & 1)
122:              			product += multiplicand;
123:              		multiplicand <<= 1;
124:              		multiplier >>= 1;
125:              	} while(multiplier != 0);
126:              
127:              #endif
128:              	return product;
129:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lldiv.c ----------------------------------------------------------------------
1:                // long unsigned unsigned division
2:                
3:                unsigned long int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lldiv(unsigned long int divisor, unsigned long int dividend)
  04F9    01E0    CLR	0x60
  04FA    01E1    CLR	0x61
  04FB    01E2    CLR	0x62
  04FC    01E3    CLR	0x63
  04FD    085B    LD	A,0x5B
  04FE    045A    ORA	0x5A
  04FF    0459    ORA	0x59
  0500    0458    ORA	0x58
  0501    1903    SZB	0x3,2
  0502    2D38    JP	0x538
  0503    01E4    CLR	0x64
  0504    0AE4    INCR	0x64
  0505    1BDB    SZB	0x5B,7
  0506    2D0D    JP	0x50D
  0507    1003    CLRB	0x3,0
  0508    0DD8    RLCR	0x58
  0509    0DD9    RLCR	0x59
  050A    0DDA    RLCR	0x5A
  050B    0DDB    RLCR	0x5B
  050C    2D04    JP	0x504
  050D    1003    CLRB	0x3,0
  050E    0DE0    RLCR	0x60
  050F    0DE1    RLCR	0x61
  0510    0DE2    RLCR	0x62
  0511    0DE3    RLCR	0x63
  0512    085B    LD	A,0x5B
  0513    025F    SUBA	0x5F
  0514    1D03    SNZB	0x3,2
  0515    2D20    JP	0x520
  0516    085A    LD	A,0x5A
  0517    025E    SUBA	0x5E
  0518    1D03    SNZB	0x3,2
  0519    2D20    JP	0x520
  051A    0859    LD	A,0x59
  051B    025D    SUBA	0x5D
  051C    1D03    SNZB	0x3,2
  051D    2D20    JP	0x520
  051E    0858    LD	A,0x58
  051F    025C    SUBA	0x5C
  0520    1C03    SNZB	0x3,0
  0521    2D32    JP	0x532
  0522    0858    LD	A,0x58
  0523    02DC    SUBR	0x5C
  0524    0859    LD	A,0x59
  0525    1C03    SNZB	0x3,0
  0526    0F59    SZINCA	0x59
  0527    02DD    SUBR	0x5D
  0528    085A    LD	A,0x5A
  0529    1C03    SNZB	0x3,0
  052A    0F5A    SZINCA	0x5A
  052B    02DE    SUBR	0x5E
  052C    085B    LD	A,0x5B
  052D    1C03    SNZB	0x3,0
  052E    0F5B    SZINCA	0x5B
  052F    02DF    SUBR	0x5F
  0530    1460    SETB	0x60,0
  0531    1003    CLRB	0x3,0
  0532    0CDB    RRCR	0x5B
  0533    0CDA    RRCR	0x5A
  0534    0CD9    RRCR	0x59
  0535    0CD8    RRCR	0x58
  0536    0BE4    SZDECR	0x64
  0537    2D0D    JP	0x50D
  0538    0863    LD	A,0x63
  0539    00DB    LD	0x5B,A
  053A    0862    LD	A,0x62
  053B    00DA    LD	0x5A,A
  053C    0861    LD	A,0x61
  053D    00D9    LD	0x59,A
  053E    0860    LD	A,0x60
  053F    00D8    LD	0x58,A
  0540    0008    RET
7:                #else
8:                __lldiv(unsigned long int dividend, unsigned long int divisor)
9:                #endif
10:               {
11:               	unsigned long int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x80000000UL) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\even.c ----------------------------------------------------------------------
1:                #include "even.h"
2:                
3:                uint8 cnt2ms=0;
4:                uint8 cnt10ms=0;
5:                bit time2ms=0;
6:                bit time10ms=0;
7:                
8:                void interrupt Isr_Timer()
9:                {
10:                   TMR2IF = 0;
  06CD    1283    CLRB	0x3,5
  06CE    1303    CLRB	0x3,6
  06CF    108C    CLRB	0xC,1
  06D0    300A    LDIA	0xA
11:                   cnt2ms++;
  06D1    0AC4    INCR	0x44
12:                   cnt10ms++;
  06D2    0AC3    INCR	0x43
13:                   if(cnt2ms>=10)
  06D3    0244    SUBA	0x44
  06D4    1C03    SNZB	0x3,0
  06D5    2ED9    JP	0x6D9
14:                   {
15:                       LEDScan();
  06D6    229D    CALL	0x29D
16:                       cnt2ms=0;
  06D7    01C4    CLR	0x44
17:                       time2ms=1;
  06D8    14F1    SETB	0x71,1
18:                   }
19:                   if(cnt10ms>=50)
  06D9    3032    LDIA	0x32
  06DA    0243    SUBA	0x43
  06DB    1C03    SNZB	0x3,0
  06DC    2EDF    JP	0x6DF
20:                   {
21:                       cnt10ms=0;
  06DD    01C3    CLR	0x43
22:                       time10ms=1;
  06DE    1471    SETB	0x71,0
  06DF    0874    LD	A,0x74
  06E0    008A    LD	0xA,A
  06E1    0873    LD	A,0x73
  06E2    0084    LD	0x4,A
  06E3    0E72    SWAPA	0x72
  06E4    0083    LD	0x3,A
  06E5    0EFE    SWAPR	0x7E
  06E6    0E7E    SWAPA	0x7E
  06E7    0009    RETI
23:                   }
24:               }
25:               
26:               
27:               
28:               
29:               
30:               
31:               
32:               
33:               
34:               
35:               
36:               
---- stringtab ------------------------------------------------------------------
  071A    3007    LDIA	0x7
  071B    008A    LD	0xA,A
  071C    0804    LD	A,0x4
  071D    0A84    INCR	0x4
  071E    0782    ADDR	0x2
  071F    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    30D3    LDIA	0xD3
  000E    1383    CLRB	0x3,7
  000F    00FD    LD	0x7D,A
  0010    3005    LDIA	0x5
  0011    00FE    LD	0x7E,A
  0012    30B7    LDIA	0xB7
  0013    00FF    LD	0x7F,A
  0014    30A0    LDIA	0xA0
  0015    0084    LD	0x4,A
  0016    2746    CALL	0x746
  0017    30D2    LDIA	0xD2
  0018    00EA    LD	0x6A,A
  0019    30F0    LDIA	0xF0
  001A    00EB    LD	0x6B,A
  001B    3020    LDIA	0x20
  001C    0084    LD	0x4,A
  001D    3050    LDIA	0x50
  001E    2781    CALL	0x781
  001F    01FA    CLR	0x7A
  0020    01F0    CLR	0x70
  0021    01F1    CLR	0x71
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F2    LD	0x72,A
  0007    0804    LD	A,0x4
  0008    00F3    LD	0x73,A
  0009    080A    LD	A,0xA
  000A    00F4    LD	0x74,A
  000B    2ECD    JP	0x6CD
---- common_function ------------------------------------------------------------------
  0001    2C64    JP	0x464
  0002    2C69    JP	0x469
  0003    2C6E    JP	0x46E
  0022    0183    CLR	0x3
  0023    2F8E    JP	0x78E
  00F9    0AB1    INCR	0x31
  00FA    1903    SZB	0x3,2
  00FB    0AB2    INCR	0x32
  00FC    3000    LDIA	0x0
  00FD    0232    SUBA	0x32
  00FE    0008    RET
  01BF    0845    LD	A,0x45
  01C0    00D3    LD	0x53,A
  01C1    01D4    CLR	0x54
  01C2    0854    LD	A,0x54
  01C3    0257    SUBA	0x57
  01C4    1D03    SNZB	0x3,2
  01C5    29C8    JP	0x1C8
  01C6    0853    LD	A,0x53
  01C7    0256    SUBA	0x56
  01C8    0845    LD	A,0x45
  01C9    0008    RET
  01CA    07D6    ADDR	0x56
  01CB    1803    SZB	0x3,0
  01CC    0AD7    INCR	0x57
  01CD    30FF    LDIA	0xFF
  01CE    07D7    ADDR	0x57
  01CF    0008    RET
  0282    0084    LD	0x4,A
  0283    1383    CLRB	0x3,7
  0284    0800    LD	A,0x0
  0285    00E6    LD	0x66,A
  0286    0A84    INCR	0x4
  0287    0800    LD	A,0x0
  0288    00E7    LD	0x67,A
  0289    0866    LD	A,0x66
  028A    00D8    LD	0x58,A
  028B    0867    LD	A,0x67
  028C    00D9    LD	0x59,A
  028D    01DA    CLR	0x5A
  028E    01DB    CLR	0x5B
  028F    0828    LD	A,0x28
  0290    00D3    LD	0x53,A
  0291    0827    LD	A,0x27
  0292    00D2    LD	0x52,A
  0293    0826    LD	A,0x26
  0294    00D1    LD	0x51,A
  0295    0825    LD	A,0x25
  0296    00D0    LD	0x50,A
  0297    0008    RET
  0298    0848    LD	A,0x48
  0299    0084    LD	0x4,A
  029A    3003    LDIA	0x3
  029B    0204    SUBA	0x4
  029C    0008    RET
  0316    1683    SETB	0x3,5
  0317    1187    CLRB	0x7,3
  0318    1703    SETB	0x3,6
  0319    118F    CLRB	0xF,3
  031A    1283    CLRB	0x3,5
  031B    1303    CLRB	0x3,6
  031C    1187    CLRB	0x7,3
  031D    0008    RET
  031E    1683    SETB	0x3,5
  031F    1107    CLRB	0x7,2
  0320    1703    SETB	0x3,6
  0321    110F    CLRB	0xF,2
  0322    1283    CLRB	0x3,5
  0323    1303    CLRB	0x3,6
  0324    1107    CLRB	0x7,2
  0325    0008    RET
  0326    1683    SETB	0x3,5
  0327    1286    CLRB	0x6,5
  0328    1295    CLRB	0x15,5
  0329    1283    CLRB	0x3,5
  032A    1286    CLRB	0x6,5
  032B    0008    RET
  032C    1683    SETB	0x3,5
  032D    1186    CLRB	0x6,3
  032E    1195    CLRB	0x15,3
  032F    1283    CLRB	0x3,5
  0330    1186    CLRB	0x6,3
  0331    0008    RET
  0332    1683    SETB	0x3,5
  0333    1206    CLRB	0x6,4
  0334    1215    CLRB	0x15,4
  0335    1283    CLRB	0x3,5
  0336    1206    CLRB	0x6,4
  0337    0008    RET
  0391    3EC9    ADDIA	0xC9
  0392    0084    LD	0x4,A
  0393    0800    LD	A,0x0
  0394    00D0    LD	0x50,A
  0395    3007    LDIA	0x7
  0396    01D1    CLR	0x51
  0397    00FF    LD	0x7F,A
  0398    1003    CLRB	0x3,0
  0399    0DD0    RLCR	0x50
  039A    0DD1    RLCR	0x51
  039B    0BFF    SZDECR	0x7F
  039C    2B98    JP	0x398
  039D    0850    LD	A,0x50
  039E    04AF    ORR	0x2F
  039F    0851    LD	A,0x51
  03A0    04B0    ORR	0x30
  03A1    0008    RET
  03A2    0800    LD	A,0x0
  03A3    00D0    LD	0x50,A
  03A4    0A84    INCR	0x4
  03A5    0800    LD	A,0x0
  03A6    00D1    LD	0x51,A
  03A7    09D0    COMR	0x50
  03A8    09D1    COMR	0x51
  03A9    0850    LD	A,0x50
  03AA    05AF    ANDR	0x2F
  03AB    0851    LD	A,0x51
  03AC    05B0    ANDR	0x30
  03AD    0008    RET
  0403    3EC9    ADDIA	0xC9
  0404    0084    LD	0x4,A
  0405    1383    CLRB	0x3,7
  0406    0800    LD	A,0x0
  0407    00AF    LD	0x2F,A
  0408    300A    LDIA	0xA
  0409    01B0    CLR	0x30
  040A    00F5    LD	0x75,A
  040B    0849    LD	A,0x49
  040C    0008    RET
  045D    00F5    LD	0x75,A
  045E    3064    LDIA	0x64
  045F    01F6    CLR	0x76
  0460    00F7    LD	0x77,A
  0461    01F8    CLR	0x78
  0462    0008    RET
  05A5    0852    LD	A,0x52
  05A6    3EA0    ADDIA	0xA0
  05A7    0084    LD	0x4,A
  05A8    1383    CLRB	0x3,7
  05A9    0A00    INCA	0x0
  05AA    2DAD    JP	0x5AD
  05AB    1003    CLRB	0x3,0
  05AC    0DF7    RLCR	0x77
  05AD    3EFF    ADDIA	0xFF
  05AE    1D03    SNZB	0x3,2
  05AF    2DAB    JP	0x5AB
  05B0    0877    LD	A,0x77
  05B1    0008    RET
  05B2    00F8    LD	0x78,A
  05B3    0852    LD	A,0x52
  05B4    3E01    ADDIA	0x1
  05B5    0084    LD	0x4,A
  05B6    0008    RET
  05B7    3400    RET	0x0
  05B8    3401    RET	0x1
  05B9    3400    RET	0x0
  05BA    3401    RET	0x1
  05BB    3401    RET	0x1
  05BC    3400    RET	0x0
  05BD    3400    RET	0x0
  05BE    3402    RET	0x2
  05BF    3403    RET	0x3
  05C0    3402    RET	0x2
  05C1    3403    RET	0x3
  05C2    3403    RET	0x3
  05C3    3402    RET	0x2
  05C4    3402    RET	0x2
  05C5    3404    RET	0x4
  05C6    3404    RET	0x4
  05C7    3400    RET	0x0
  05C8    3400    RET	0x0
  05C9    3412    RET	0x12
  05CA    3400    RET	0x0
  05CB    345B    RET	0x5B
  05CC    3400    RET	0x0
  05CD    347F    RET	0x7F
  05CE    3400    RET	0x0
  05CF    347F    RET	0x7F
  05D0    3409    RET	0x9
  05D1    34FF    RET	0xFF
  05D2    342D    RET	0x2D
  05D3    34FF    RET	0xFF
  05D4    343F    RET	0x3F
  05D5    3400    RET	0x0
  05D6    3440    RET	0x40
  05D7    3470    RET	0x70
  05D8    3478    RET	0x78
  05D9    347E    RET	0x7E
  05DA    347F    RET	0x7F
  05DB    343F    RET	0x3F
  05DC    340F    RET	0xF
  05DD    3407    RET	0x7
  05DE    3401    RET	0x1
  05DF    3400    RET	0x0
  05E0    3477    RET	0x77
  05E1    3424    RET	0x24
  05E2    345D    RET	0x5D
  05E3    346D    RET	0x6D
  05E4    342E    RET	0x2E
  05E5    346B    RET	0x6B
  05E6    347B    RET	0x7B
  05E7    3425    RET	0x25
  05E8    347F    RET	0x7F
  05E9    342F    RET	0x2F
  066B    3064    LDIA	0x64
  066C    1283    CLRB	0x3,5
  066D    1303    CLRB	0x3,6
  066E    0242    SUBA	0x42
  066F    0008    RET
  068B    0185    CLR	0x5
  068C    0186    CLR	0x6
  068D    0187    CLR	0x7
  068E    30FF    LDIA	0xFF
  068F    1703    SETB	0x3,6
  0690    008E    LD	0xE,A
  0691    1303    CLRB	0x3,6
  0692    0095    LD	0x15,A
  0693    1703    SETB	0x3,6
  0694    008F    LD	0xF,A
  0695    0008    RET
  0720    3401    RET	0x1
  0721    3402    RET	0x2
  0722    3402    RET	0x2
  0723    3403    RET	0x3
  0724    3400    RET	0x0
  0725    3403    RET	0x3
  0726    3404    RET	0x4
  0727    3400    RET	0x0
  0728    3401    RET	0x1
  0729    3401    RET	0x1
  072A    3402    RET	0x2
  072B    3400    RET	0x0
  072C    3403    RET	0x3
  072D    3404    RET	0x4
  072E    3400    RET	0x0
  072F    3401    RET	0x1
  0742    087E    LD	A,0x7E
  0743    008A    LD	0xA,A
  0744    087F    LD	A,0x7F
  0745    0082    LD	0x2,A
  0746    2742    CALL	0x742
  0747    0080    LD	0x0,A
  0748    0A84    INCR	0x4
  0749    0804    LD	A,0x4
  074A    067D    XORA	0x7D
  074B    1903    SZB	0x3,2
  074C    3400    RET	0x0
  074D    0AFF    INCR	0x7F
  074E    1903    SZB	0x3,2
  074F    0AFE    INCR	0x7E
  0750    2F46    JP	0x746
  0781    0064    CLRWDT
  0782    0180    CLR	0x0
  0783    0A84    INCR	0x4
  0784    0604    XORA	0x4
  0785    1903    SZB	0x3,2
  0786    3400    RET	0x0
  0787    0604    XORA	0x4
  0788    2F82    JP	0x782
  0789    2AAE    JP	0x2AE
  078A    2AC0    JP	0x2C0
  078B    2AD2    JP	0x2D2
  078C    2AE4    JP	0x2E4
  078D    2AF5    JP	0x2F5
  0792    2A43    JP	0x243
  0793    2A4B    JP	0x24B
  0794    2A55    JP	0x255
