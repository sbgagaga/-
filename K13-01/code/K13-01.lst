---- C:\Users\Administrator\Desktop\project\K13-01\code\main.c ----------------------------------------------------------------------
1:                #include "K13-01.h"
2:                
3:                void main()
4:                {
5:                    SystemInit();
  07C6    27B0    CALL	0x7B0
6:                    while (1)
7:                    {
8:                        Apply();
  07C7    26A1    CALL	0x6A1
  07C8    0064    CLRWDT
  07C9    2FC7    JP	0x7C7
9:                        asm("clrwdt");
10:                   }
11:               }
12:               
---- C:\Users\Administrator\Desktop\project\K13-01\code\K13-01.c ----------------------------------------------------------------------
1:                #include "K13-01.h"
2:                
3:                bit SystemONFlag=0;
4:                uint8 VarPowerUpCount=0;
5:                
6:                uint8 BatPercent=0;
7:                
8:                uint8 WorkMin=0;
9:                
10:               uint8 LockNumb=0;
11:               
12:               TYPE_UNION_LockSta LockSta;
13:               
14:               bit OnOffFlag=0;
15:               bit WorkFlag=0;
16:               bit IovFlag=0;
17:               bit LowBatFlag=0;
18:               bit USBFlag=0;
19:               
20:               uint8 Sec1sCnt=0;
21:               uint8 BatAddTime=0;
22:               uint8 BatDecTime=0;
23:               
24:               void Apply()
25:               {
26:                   if(time2ms)
  06A1    1CF1    SNZB	0x71,1
  06A2    2EA7    JP	0x6A7
27:                   {
28:                       time2ms=0;
  06A3    10F1    CLRB	0x71,1
29:                       if(SystemONFlag)
  06A4    1EF1    SNZB	0x71,5
  06A5    2EA7    JP	0x6A7
30:                       {
31:                           KeyScan();
  06A6    213A    CALL	0x13A
32:                       }
33:                   }
34:                   if(time10ms)
  06A7    1C71    SNZB	0x71,0
  06A8    0008    RET
35:                   {
36:                       time10ms=0;
  06A9    1071    CLRB	0x71,0
37:                       if(SystemONFlag==0&&VarPowerUpCount<100)
  06AA    1AF1    SZB	0x71,5
  06AB    2EB2    JP	0x6B2
  06AC    26C3    CALL	0x6C3
  06AD    1803    SZB	0x3,0
  06AE    2EB2    JP	0x6B2
38:                       {
39:                           VarPowerUpCount++;
  06AF    0ABD    INCR	0x3D
40:                           ADCPro();
  06B0    256C    CALL	0x56C
41:                       }
  06B1    2EB7    JP	0x6B7
42:                       else if(VarPowerUpCount>=100)
  06B2    26C3    CALL	0x6C3
  06B3    1C03    SNZB	0x3,0
  06B4    2EB7    JP	0x6B7
43:                       {
44:                           SystemONFlag=1;
  06B5    16F1    SETB	0x71,5
45:                           VarPowerUpCount=0;
  06B6    01BD    CLR	0x3D
46:                       }
47:                       /*上电完成*/
48:                       if(SystemONFlag)
  06B7    1EF1    SNZB	0x71,5
  06B8    2EBC    JP	0x6BC
49:                       {
50:                           ADCPro();
  06B9    256C    CALL	0x56C
51:                           Motor();
  06BA    2474    CALL	0x474
52:                           DisplayPro();
  06BB    27A3    CALL	0x7A3
  06BC    3064    LDIA	0x64
53:                           //SystemSleep();
54:                       }
55:                       Sec1sCnt++;
  06BD    0ABB    INCR	0x3B
56:                       if(Sec1sCnt>=100)
  06BE    023B    SUBA	0x3B
  06BF    1C03    SNZB	0x3,0
  06C0    0008    RET
57:                       {
58:                           Sec1sCnt=0;
  06C1    01BB    CLR	0x3B
59:                           Sec1sPro();
  06C2    2A0F    JP	0x20F
60:                       }
61:                       
62:                   }
63:               }
64:               
65:               void SystemSleep()
66:               {
67:                   static uint8 SleepCnt=0;
68:                   if(WorkFlag||OnOffFlag||LowBatFlag||USBFlag||IovFlag)
69:                   {
70:                       SleepCnt=0;
71:                   }
72:                   else
73:                   {
74:                       SleepCnt++;
75:                       if(SleepCnt>=200)
76:                       {
77:                           SleepCnt=0;
78:                           asm("clrwdt");
79:                           INTCON=0;
80:                           PIE1 = 0;
81:                           PIE2 = 0;	
82:                           PIR1 = 0;
83:                           ADCON0	= 0;
84:               
85:                           TRISA =0X00;
86:               	        TRISB =0X00;
87:                           WPUA = 0xFF;
88:                           WPUB = 0xFF;
89:                           WPUC = 0xFF;
90:                           PORTA =	0;			//初始端口配置为输出低；
91:                           PORTB = 0;
92:                           PORTC = 0;
93:                           PIN_BAT=H;
94:                           PIN_IOV=H;
95:                           PIN_GND=H;
96:                           PIN_EN =L;
97:                           Pin_KEY_CFG(1,1);
98:                           Pin_USB_CFG(1,1);
99:               
100:                          WDT_OFF();
101:                          RBIE=1;
102:                          IOCB=0xC0;
103:                          OSCCON=0X01;
104:                          RBIF = 0;
105:                          PORTB;
106:                          asm("sleep");
107:              		    asm("nop");
108:                          SystemInit();
109:                      }
110:                  }
111:              }
112:              
113:              void SystemInit()
  07B0    0000    NOP
  07B1    0064    CLRWDT
114:              {
115:                  asm("nop");
116:              	asm("clrwdt");
117:                  GPIOInit();
  07B2    2679    CALL	0x679
118:                  TimerInit();
  07B3    2787    CALL	0x787
119:                  WDT_ON();
  07B4    3001    LDIA	0x1
  07B5    1283    CLRB	0x3,5
  07B6    1703    SETB	0x3,6
  07B7    0085    LD	0x5,A
  07B8    0008    RET
120:              }
121:              
122:              void GPIOInit()
123:              {
124:                  RBPU=0;
  0679    1683    SETB	0x3,5
  067A    1303    CLRB	0x3,6
  067B    1381    CLRB	0x1,7
125:              	/*全配置成输出*/
126:              	TRISA =0X00;
  067C    0185    CLR	0x5
127:              	TRISB =0X00;
  067D    0186    CLR	0x6
128:              	TRISC =0X00;
  067E    0187    CLR	0x7
129:              	//TRISE =0X00; 
130:              
131:                  /*全部设置上拉，输出会自动断开上拉*/
132:              	WPUA  =0XFF;
  067F    30FF    LDIA	0xFF
  0680    1703    SETB	0x3,6
  0681    008E    LD	0xE,A
133:              	WPUB  =0XFF;
  0682    1303    CLRB	0x3,6
  0683    0095    LD	0x15,A
134:              	WPUC  =0XFF;
  0684    1703    SETB	0x3,6
  0685    008F    LD	0xF,A
135:              	//WPUE  =0XFF;
136:              
137:                  /*默认输出0*/
138:              	PORTA =	0X80;
  0686    3080    LDIA	0x80
  0687    1283    CLRB	0x3,5
  0688    1303    CLRB	0x3,6
  0689    0085    LD	0x5,A
139:              	PORTB = 0X80;
  068A    0086    LD	0x6,A
140:              	PORTC = 0;
  068B    0187    CLR	0x7
141:              	//PORTE = 0;
142:              
143:              	PIN_EN =true;
  068C    1685    SETB	0x5,5
144:                  RBPU=0;
  068D    1683    SETB	0x3,5
  068E    1381    CLRB	0x1,7
145:                  Pin_KEY_CFG(IN,1);
  068F    1705    SETB	0x5,6
  0690    1703    SETB	0x3,6
  0691    170E    SETB	0xE,6
146:                  Pin_USB_CFG(IN,1);
  0692    1303    CLRB	0x3,6
  0693    1785    SETB	0x5,7
  0694    1703    SETB	0x3,6
  0695    178E    SETB	0xE,7
147:              	
148:              	Pin_BAT_CFG(1,0); ANS1=1; //AN1配置为模拟输入；
  0696    1303    CLRB	0x3,6
  0697    1485    SETB	0x5,1
  0698    1703    SETB	0x3,6
  0699    108E    CLRB	0xE,1
  069A    1488    SETB	0x8,1
149:              	Pin_IOV_CFG(1,0); ANS2=1; //AN2配置为模拟输入；
  069B    1303    CLRB	0x3,6
  069C    1505    SETB	0x5,2
  069D    1703    SETB	0x3,6
  069E    110E    CLRB	0xE,2
  069F    1508    SETB	0x8,2
  06A0    0008    RET
150:                  //Pin_Vin_CFG(1,0); ANS9=1;//AN9配置为模拟输入；
151:              }
152:              
153:              void TimerInit()
154:              {
155:                  // OSCCON=0X71;		//晶振配置为8M,内部
156:              	// INTCON=0B11000000;	//使能全局中断，外设中断
157:              	// PIE1=0B00000001;	//TIMER1溢出中断
158:                  // TMR1IF = 0;
159:              	// TMR1IE = 1;	
160:                  // TMR1H=0xFC;
161:                  // TMR1L=0x18;         //设置定时器1计时1ms
162:                  // T1CON = 0X01; //预分配4倍,使能定时器1
163:              
164:              	OSCCON=0X61;		//晶振配置为4M,内部
  0787    3061    LDIA	0x61
  0788    1303    CLRB	0x3,6
  0789    008F    LD	0xF,A
165:              	INTCON=0B11000000;	//使能全局中断，外设中断
  078A    30C0    LDIA	0xC0
  078B    008B    LD	0xB,A
166:              	PIE1=0B00000010;	//TIMER2匹配中断
  078C    3002    LDIA	0x2
  078D    008C    LD	0xC,A
167:              	T2CON=0B00000100;	//使能TIMER2
  078E    3004    LDIA	0x4
  078F    1283    CLRB	0x3,5
  0790    0092    LD	0x12,A
168:              	PR2	= 200;			//TIMER时钟为Fosc/4; 200us进一次中断
  0791    30C8    LDIA	0xC8
  0792    1683    SETB	0x3,5
  0793    0092    LD	0x12,A
  0794    0008    RET
169:              }
---- C:\Users\Administrator\Desktop\project\K13-01\code\ADC.c ----------------------------------------------------------------------
1:                #include "ADC.h"
2:                
3:                uint8 ADCState=0;
4:                uint16 ADCVal[3]={0};//bg、current、Vbat
5:                uint16 ADCMax=0,ADCMin=0;
6:                uint32 ADsum=0;
7:                uint8 ADcnt=0;
8:                
9:                uint8 CurrentCnt=0;
10:               
11:               void ADCPro()
12:               {
13:                   switch (ADCState)
  056C    2D7C    JP	0x57C
14:                   {
15:                       case 0://内部参考电压采样
16:                       ADCRead(AD_BG,ADCVal);
  056D    3047    LDIA	0x47
  056E    00E2    LD	0x62,A
  056F    300F    LDIA	0xF
  0570    2024    CALL	0x24
17:                       break;
  0571    2D84    JP	0x584
18:               
19:                       case 1://过流采样
20:                       ADCRead(AD_AN2,ADCVal+1);
  0572    3049    LDIA	0x49
  0573    00E2    LD	0x62,A
  0574    3002    LDIA	0x2
  0575    2024    CALL	0x24
21:                       break;
  0576    2D84    JP	0x584
22:               
23:                       case 2://电池电压采样
24:                       ADCRead(AD_AN1,ADCVal+2);
  0577    304B    LDIA	0x4B
  0578    00E2    LD	0x62,A
  0579    3001    LDIA	0x1
  057A    2024    CALL	0x24
25:                       break;
  057B    2D84    JP	0x584
  057C    2135    CALL	0x135
  057D    1803    SZB	0x3,0
  057E    2D84    JP	0x584
  057F    3000    LDIA	0x0
  0580    008A    LD	0xA,A
  0581    3001    LDIA	0x1
  0582    0704    ADDA	0x4
  0583    0082    LD	0x2,A
26:                   }
27:                   if(SystemONFlag==0)
  0584    1AF1    SZB	0x71,5
  0585    2D9B    JP	0x59B
28:                   {
29:                       if(ADCVal[2]<BAT_3V2) 
  0586    3001    LDIA	0x1
  0587    024C    SUBA	0x4C
  0588    300B    LDIA	0xB
  0589    1903    SZB	0x3,2
  058A    024B    SUBA	0x4B
  058B    1803    SZB	0x3,0
  058C    2D8F    JP	0x58F
30:                       {
31:                           BatPercent=0; 
  058D    01C6    CLR	0x46
32:                       }
  058E    2D9B    JP	0x59B
33:                       else if(ADCVal[2]>BAT_4V2)
  058F    3001    LDIA	0x1
  0590    024C    SUBA	0x4C
  0591    305F    LDIA	0x5F
  0592    1903    SZB	0x3,2
  0593    024B    SUBA	0x4B
  0594    1C03    SNZB	0x3,0
  0595    2D98    JP	0x598
34:                       {
35:                           BatPercent=99; 
  0596    3063    LDIA	0x63
  0597    2D9A    JP	0x59A
36:                       }
37:                       else
38:                       {
39:                           BatPercent=ADCVal[2]-BAT_3V0;
  0598    084B    LD	A,0x4B
  0599    3E06    ADDIA	0x6
  059A    00C6    LD	0x46,A
40:                       }
41:                   }
42:                   if(ADCVal[2]<BAT_3V0)
43:                   {
44:                       LowBatFlag=1;
45:                   }
46:                   else
47:                   {
48:                       LowBatFlag=0;
49:                   }
50:                   if(ADCVal[1]>VOLTAGE07V)
  059B    3000    LDIA	0x0
  059C    024A    SUBA	0x4A
  059D    303B    LDIA	0x3B
  059E    1903    SZB	0x3,2
  059F    0249    SUBA	0x49
  05A0    1C03    SNZB	0x3,0
  05A1    2DAB    JP	0x5AB
  05A2    30C8    LDIA	0xC8
51:                   {
52:                       CurrentCnt++;
  05A3    0AC1    INCR	0x41
53:                       if(CurrentCnt>=200)
  05A4    0241    SUBA	0x41
  05A5    1C03    SNZB	0x3,0
  05A6    0008    RET
54:                       {
55:                           CurrentCnt=200;
  05A7    30C8    LDIA	0xC8
  05A8    00C1    LD	0x41,A
56:                           IovFlag=1;
  05A9    1671    SETB	0x71,4
  05AA    0008    RET
57:                       }
58:                   }
59:                   else
60:                   {
61:                       CurrentCnt=0;
  05AB    01C1    CLR	0x41
62:                       IovFlag=0;
  05AC    1271    CLRB	0x71,4
  05AD    0008    RET
63:                   }
64:               }
65:               
66:               void Sec1sPro()
67:               {
68:                   static uint8 ActualPercent=0;
69:                   uint8 PercentErr=0;
70:                   uint16 TempPercent=0;
  020F    01D3    CLR	0x53
  0210    01D4    CLR	0x54
71:               
72:                   /*充电数字增加时间*/
73:                   if(USBFlag)
  0211    1DF1    SNZB	0x71,3
  0212    2A6E    JP	0x26E
74:                   {
75:                       if(ADCVal[2]<BAT_3V3) 
  0213    3001    LDIA	0x1
  0214    024C    SUBA	0x4C
  0215    3013    LDIA	0x13
  0216    1903    SZB	0x3,2
  0217    024B    SUBA	0x4B
  0218    1803    SZB	0x3,0
  0219    2A1C    JP	0x21C
76:                       {
77:                           TempPercent=0; 
  021A    01D3    CLR	0x53
  021B    2A25    JP	0x225
78:                       }
79:                       else if(ADCVal[2]>BAT_4V2)
  021C    3001    LDIA	0x1
  021D    024C    SUBA	0x4C
  021E    305F    LDIA	0x5F
  021F    1903    SZB	0x3,2
  0220    024B    SUBA	0x4B
  0221    1C03    SNZB	0x3,0
  0222    2A27    JP	0x227
80:                       {
81:                           TempPercent=99; 
  0223    3063    LDIA	0x63
  0224    00D3    LD	0x53,A
  0225    01D4    CLR	0x54
82:                       }
  0226    2A43    JP	0x243
83:                       else
84:                       {
85:                           TempPercent=ADCVal[2]-BAT_3V3;
  0227    084C    LD	A,0x4C
  0228    00D4    LD	0x54,A
  0229    084B    LD	A,0x4B
  022A    00D3    LD	0x53,A
  022B    30ED    LDIA	0xED
  022C    22DA    CALL	0x2DA
86:                           TempPercent=TempPercent*4/3;
  022D    3003    LDIA	0x3
  022E    00F5    LD	0x75,A
  022F    01F6    CLR	0x76
  0230    0854    LD	A,0x54
  0231    00D1    LD	0x51,A
  0232    0853    LD	A,0x53
  0233    00D0    LD	0x50,A
  0234    1003    CLRB	0x3,0
  0235    0DD0    RLCR	0x50
  0236    0DD1    RLCR	0x51
  0237    1003    CLRB	0x3,0
  0238    0DD0    RLCR	0x50
  0239    0DD1    RLCR	0x51
  023A    0850    LD	A,0x50
  023B    00F7    LD	0x77,A
  023C    0851    LD	A,0x51
  023D    00F8    LD	0x78,A
  023E    264F    CALL	0x64F
  023F    0876    LD	A,0x76
  0240    00D4    LD	0x54,A
  0241    0875    LD	A,0x75
  0242    00D3    LD	0x53,A
87:                       }
88:                       if(ActualPercent>TempPercent)
89:                       {
90:                           if(ActualPercent)
  0243    22CF    CALL	0x2CF
  0244    1803    SZB	0x3,0
  0245    2A4A    JP	0x24A
  0246    1903    SZB	0x3,2
  0247    2A59    JP	0x259
91:                           {
92:                               ActualPercent--;
  0248    03C0    DECR	0x40
  0249    2A59    JP	0x259
93:                           }
94:                       }
95:                       else if(ActualPercent<TempPercent)
  024A    00D0    LD	0x50,A
  024B    01D1    CLR	0x51
  024C    0854    LD	A,0x54
  024D    0251    SUBA	0x51
  024E    1D03    SNZB	0x3,2
  024F    2A52    JP	0x252
  0250    0853    LD	A,0x53
  0251    0250    SUBA	0x50
  0252    1803    SZB	0x3,0
  0253    2A59    JP	0x259
96:                       {
97:                           if(ActualPercent<99)
  0254    3063    LDIA	0x63
  0255    0240    SUBA	0x40
  0256    1803    SZB	0x3,0
  0257    2A59    JP	0x259
98:                           {
99:                               ActualPercent++;
  0258    0AC0    INCR	0x40
100:                          }
101:                      }
102:                      if(ActualPercent>BatPercent)
  0259    0840    LD	A,0x40
  025A    0246    SUBA	0x46
  025B    1803    SZB	0x3,0
  025C    2A6C    JP	0x26C
103:                      {
104:                          PercentErr=ActualPercent-BatPercent;
  025D    0846    LD	A,0x46
  025E    0240    SUBA	0x40
  025F    00D2    LD	0x52,A
105:                          if(PercentErr<5)
  0260    3005    LDIA	0x5
  0261    0252    SUBA	0x52
  0262    1803    SZB	0x3,0
  0263    2A6A    JP	0x26A
106:                          {
107:                              BatAddTime=90-15*PercentErr;
  0264    30F1    LDIA	0xF1
  0265    00F5    LD	0x75,A
  0266    0852    LD	A,0x52
  0267    2795    CALL	0x795
  0268    3E5A    ADDIA	0x5A
  0269    2A6D    JP	0x26D
108:                          }
109:                          else
110:                          {
111:                              BatAddTime=15;
  026A    300F    LDIA	0xF
  026B    2A6D    JP	0x26D
112:                          }
113:                      }
114:                      else
115:                      {
116:                          BatAddTime=240;
  026C    30F0    LDIA	0xF0
  026D    00C5    LD	0x45,A
117:                      }
118:                  }
119:              
120:                  /*工作数字减少时间*/
121:                  if(WorkFlag)
  026E    1D71    SNZB	0x71,2
  026F    2ACC    JP	0x2CC
122:                  {
123:                      if(ADCVal[2]<BAT_3V2) 
  0270    3001    LDIA	0x1
  0271    024C    SUBA	0x4C
  0272    300B    LDIA	0xB
  0273    1903    SZB	0x3,2
  0274    024B    SUBA	0x4B
  0275    1803    SZB	0x3,0
  0276    2A79    JP	0x279
124:                      {
125:                          TempPercent=0; 
  0277    01D3    CLR	0x53
  0278    2A82    JP	0x282
126:                      }
127:                      else if(ADCVal[2]>BAT_4V0)
  0279    3001    LDIA	0x1
  027A    024C    SUBA	0x4C
  027B    304E    LDIA	0x4E
  027C    1903    SZB	0x3,2
  027D    024B    SUBA	0x4B
  027E    1C03    SNZB	0x3,0
  027F    2A84    JP	0x284
128:                      {
129:                          TempPercent=99; 
  0280    3063    LDIA	0x63
  0281    00D3    LD	0x53,A
  0282    01D4    CLR	0x54
130:                      }
  0283    2A8A    JP	0x28A
131:                      else
132:                      {
133:                          TempPercent=ADCVal[2]-BAT_3V2;
  0284    084C    LD	A,0x4C
  0285    00D4    LD	0x54,A
  0286    084B    LD	A,0x4B
  0287    00D3    LD	0x53,A
  0288    30F5    LDIA	0xF5
  0289    22DA    CALL	0x2DA
134:                      }
135:                      if(TempPercent>=33)
  028A    3000    LDIA	0x0
  028B    0254    SUBA	0x54
  028C    3021    LDIA	0x21
  028D    1903    SZB	0x3,2
  028E    0253    SUBA	0x53
  028F    1C03    SNZB	0x3,0
  0290    2A9E    JP	0x29E
136:                      {
137:                          TempPercent=33+(ADCVal[2]-BAT_3V6)*2; 
  0291    084C    LD	A,0x4C
  0292    00D4    LD	0x54,A
  0293    084B    LD	A,0x4B
  0294    00D3    LD	0x53,A
  0295    30C9    LDIA	0xC9
  0296    1003    CLRB	0x3,0
  0297    0DD3    RLCR	0x53
  0298    0DD4    RLCR	0x54
  0299    07D3    ADDR	0x53
  029A    1803    SZB	0x3,0
  029B    0AD4    INCR	0x54
  029C    30FD    LDIA	0xFD
  029D    07D4    ADDR	0x54
138:                      }
139:                      if(ActualPercent>TempPercent)
140:                      {
141:                          if(ActualPercent)
  029E    22CF    CALL	0x2CF
  029F    1803    SZB	0x3,0
  02A0    2AA5    JP	0x2A5
  02A1    1903    SZB	0x3,2
  02A2    2AB4    JP	0x2B4
142:                          {
143:                              ActualPercent--;
  02A3    03C0    DECR	0x40
  02A4    2AB4    JP	0x2B4
144:                          }
145:                      }
146:                      else if(ActualPercent<TempPercent)
  02A5    00D0    LD	0x50,A
  02A6    01D1    CLR	0x51
  02A7    0854    LD	A,0x54
  02A8    0251    SUBA	0x51
  02A9    1D03    SNZB	0x3,2
  02AA    2AAD    JP	0x2AD
  02AB    0853    LD	A,0x53
  02AC    0250    SUBA	0x50
  02AD    1803    SZB	0x3,0
  02AE    2AB4    JP	0x2B4
147:                      {
148:                          if(ActualPercent<99)
  02AF    3063    LDIA	0x63
  02B0    0240    SUBA	0x40
  02B1    1803    SZB	0x3,0
  02B2    2AB4    JP	0x2B4
149:                          {
150:                              ActualPercent++;
  02B3    0AC0    INCR	0x40
151:                          }
152:                      }
153:                      if(ActualPercent<BatPercent)
  02B4    0846    LD	A,0x46
  02B5    0240    SUBA	0x40
  02B6    1803    SZB	0x3,0
  02B7    2ACC    JP	0x2CC
154:                      {
155:                          PercentErr=BatPercent-ActualPercent;
  02B8    0840    LD	A,0x40
  02B9    0246    SUBA	0x46
  02BA    00D2    LD	0x52,A
156:                          if(PercentErr<5&&ActualPercent)
  02BB    3005    LDIA	0x5
  02BC    0252    SUBA	0x52
  02BD    1803    SZB	0x3,0
  02BE    2AC9    JP	0x2C9
  02BF    0840    LD	A,0x40
  02C0    1903    SZB	0x3,2
  02C1    2AC9    JP	0x2C9
157:                          {
158:                              BatDecTime=75-15*PercentErr;
  02C2    30F1    LDIA	0xF1
  02C3    00F5    LD	0x75,A
  02C4    0852    LD	A,0x52
  02C5    2795    CALL	0x795
  02C6    3E4B    ADDIA	0x4B
  02C7    00C4    LD	0x44,A
159:                          }
  02C8    0008    RET
160:                          else
161:                          {
162:                              BatDecTime=8;
  02C9    3008    LDIA	0x8
  02CA    00C4    LD	0x44,A
  02CB    0008    RET
163:                          }
164:                      }
165:                      else
166:                      {
167:                          BatDecTime=210;
  02CC    30D2    LDIA	0xD2
  02CD    00C4    LD	0x44,A
  02CE    0008    RET
168:                      }
169:                  }
170:                  else
171:                  {
172:                      BatDecTime=210;
173:                  }
174:              }
175:              
176:              void ADCRead(uint8 ch,uint16 *Val)
  0024    1683    SETB	0x3,5
  0025    00DB    LD	0x5B,A
177:              {
178:              	uint16 ad_temp,AD_H,AD_L;
179:              
180:              	if(ADSample(ch))
  0026    2733    CALL	0x733
  0027    3A00    XORIA	0x0
  0028    1903    SZB	0x3,2
  0029    0008    RET
181:              	{
182:                      AD_H=ADRESH;
  002A    081E    LD	A,0x1E
  002B    1683    SETB	0x3,5
  002C    00DC    LD	0x5C,A
  002D    01DD    CLR	0x5D
183:                      AD_L=ADRESL;
  002E    081E    LD	A,0x1E
  002F    00DE    LD	0x5E,A
  0030    01DF    CLR	0x5F
184:              		ad_temp=(AD_H<<4)|(AD_L>>4);  //12位ad
  0031    085D    LD	A,0x5D
  0032    1283    CLRB	0x3,5
  0033    00E4    LD	0x64,A
  0034    1683    SETB	0x3,5
  0035    085C    LD	A,0x5C
  0036    1283    CLRB	0x3,5
  0037    00E3    LD	0x63,A
  0038    30F0    LDIA	0xF0
  0039    0EE3    SWAPR	0x63
  003A    0EE4    SWAPR	0x64
  003B    05E4    ANDR	0x64
  003C    0863    LD	A,0x63
  003D    390F    ANDIA	0xF
  003E    04E4    ORR	0x64
  003F    30F0    LDIA	0xF0
  0040    05E3    ANDR	0x63
  0041    0863    LD	A,0x63
  0042    1683    SETB	0x3,5
  0043    00E0    LD	0x60,A
  0044    1283    CLRB	0x3,5
  0045    0864    LD	A,0x64
  0046    1683    SETB	0x3,5
  0047    00E1    LD	0x61,A
  0048    085F    LD	A,0x5F
  0049    1283    CLRB	0x3,5
  004A    00E4    LD	0x64,A
  004B    1683    SETB	0x3,5
  004C    085E    LD	A,0x5E
  004D    1283    CLRB	0x3,5
  004E    00E3    LD	0x63,A
  004F    3004    LDIA	0x4
  0050    1003    CLRB	0x3,0
  0051    0CE4    RRCR	0x64
  0052    0CE3    RRCR	0x63
  0053    3EFF    ADDIA	0xFF
  0054    1D03    SNZB	0x3,2
  0055    2850    JP	0x50
  0056    0863    LD	A,0x63
  0057    1683    SETB	0x3,5
  0058    04E0    ORR	0x60
  0059    1283    CLRB	0x3,5
  005A    0864    LD	A,0x64
  005B    1683    SETB	0x3,5
  005C    04E1    ORR	0x61
185:                      if(ad_temp>ADCMax)
  005D    0861    LD	A,0x61
  005E    1283    CLRB	0x3,5
  005F    0230    SUBA	0x30
  0060    1D03    SNZB	0x3,2
  0061    2866    JP	0x66
  0062    1683    SETB	0x3,5
  0063    0860    LD	A,0x60
  0064    1283    CLRB	0x3,5
  0065    022F    SUBA	0x2F
  0066    1803    SZB	0x3,0
  0067    2870    JP	0x70
186:                      {
187:                          ADCMax=ad_temp;
  0068    1683    SETB	0x3,5
  0069    0861    LD	A,0x61
  006A    1283    CLRB	0x3,5
  006B    00B0    LD	0x30,A
  006C    1683    SETB	0x3,5
  006D    0860    LD	A,0x60
  006E    1283    CLRB	0x3,5
  006F    00AF    LD	0x2F,A
188:                      }
189:                      if(ad_temp<ADCMin)
  0070    082E    LD	A,0x2E
  0071    1683    SETB	0x3,5
  0072    0261    SUBA	0x61
  0073    1D03    SNZB	0x3,2
  0074    2879    JP	0x79
  0075    1283    CLRB	0x3,5
  0076    082D    LD	A,0x2D
  0077    1683    SETB	0x3,5
  0078    0260    SUBA	0x60
  0079    1803    SZB	0x3,0
  007A    2882    JP	0x82
190:                      {
191:                          ADCMin=ad_temp;
  007B    0861    LD	A,0x61
  007C    1283    CLRB	0x3,5
  007D    00AE    LD	0x2E,A
  007E    1683    SETB	0x3,5
  007F    0860    LD	A,0x60
  0080    1283    CLRB	0x3,5
  0081    00AD    LD	0x2D,A
192:                      }
193:              		ADsum += ad_temp;
  0082    1683    SETB	0x3,5
  0083    0860    LD	A,0x60
  0084    1283    CLRB	0x3,5
  0085    00E3    LD	0x63,A
  0086    1683    SETB	0x3,5
  0087    0861    LD	A,0x61
  0088    1283    CLRB	0x3,5
  0089    00E4    LD	0x64,A
  008A    01E5    CLR	0x65
  008B    01E6    CLR	0x66
  008C    2124    CALL	0x124
  008D    1803    SZB	0x3,0
  008E    3E01    ADDIA	0x1
  008F    1D03    SNZB	0x3,2
  0090    07A8    ADDR	0x28
  0091    300A    LDIA	0xA
194:              		ADcnt++;
  0092    0AC2    INCR	0x42
195:              		if(ADcnt >= 10)
  0093    0242    SUBA	0x42
  0094    1C03    SNZB	0x3,0
  0095    0008    RET
196:              		{
197:                          ADcnt = 0;	
  0096    01C2    CLR	0x42
198:                          ADsum=  ADsum-ADCMax-ADCMin;
  0097    082D    LD	A,0x2D
  0098    00E3    LD	0x63,A
  0099    082E    LD	A,0x2E
  009A    00E4    LD	0x64,A
  009B    01E5    CLR	0x65
  009C    01E6    CLR	0x66
  009D    082F    LD	A,0x2F
  009E    00E7    LD	0x67,A
  009F    0830    LD	A,0x30
  00A0    00E8    LD	0x68,A
  00A1    01E9    CLR	0x69
  00A2    01EA    CLR	0x6A
  00A3    0867    LD	A,0x67
  00A4    07E3    ADDR	0x63
  00A5    0868    LD	A,0x68
  00A6    1803    SZB	0x3,0
  00A7    0F68    SZINCA	0x68
  00A8    07E4    ADDR	0x64
  00A9    0869    LD	A,0x69
  00AA    1803    SZB	0x3,0
  00AB    0F69    SZINCA	0x69
  00AC    07E5    ADDR	0x65
  00AD    086A    LD	A,0x6A
  00AE    1803    SZB	0x3,0
  00AF    0A6A    INCA	0x6A
  00B0    07E6    ADDR	0x66
  00B1    09E3    COMR	0x63
  00B2    09E4    COMR	0x64
  00B3    09E5    COMR	0x65
  00B4    09E6    COMR	0x66
  00B5    0AE3    INCR	0x63
  00B6    1903    SZB	0x3,2
  00B7    0AE4    INCR	0x64
  00B8    1903    SZB	0x3,2
  00B9    0AE5    INCR	0x65
  00BA    1903    SZB	0x3,2
  00BB    0AE6    INCR	0x66
  00BC    2124    CALL	0x124
  00BD    1803    SZB	0x3,0
  00BE    3E01    ADDIA	0x1
  00BF    1D03    SNZB	0x3,2
  00C0    07A8    ADDR	0x28
199:              			ADsum = ADsum >> 3;
  00C1    3003    LDIA	0x3
  00C2    1003    CLRB	0x3,0
  00C3    0CA8    RRCR	0x28
  00C4    0CA7    RRCR	0x27
  00C5    0CA6    RRCR	0x26
  00C6    0CA5    RRCR	0x25
  00C7    3EFF    ADDIA	0xFF
  00C8    1D03    SNZB	0x3,2
  00C9    28C2    JP	0xC2
200:                          switch (ADCState)
  00CA    28F7    JP	0xF7
201:                          {
202:                              case 0:
203:                              *Val=ADsum;//内部参考电压
  00CB    0862    LD	A,0x62
  00CC    0084    LD	0x4,A
  00CD    0825    LD	A,0x25
  00CE    1383    CLRB	0x3,7
  00CF    0080    LD	0x0,A
  00D0    0A84    INCR	0x4
  00D1    0826    LD	A,0x26
  00D2    28F5    JP	0xF5
204:                              break;
205:              
206:                              case 1:
207:                              *Val=ADsum*1000/(*(Val-1));//电流
  00D3    0862    LD	A,0x62
  00D4    3EFE    ADDIA	0xFE
  00D5    210E    CALL	0x10E
  00D6    3003    LDIA	0x3
  00D7    01D4    CLR	0x54
  00D8    01D3    CLR	0x53
  00D9    00D2    LD	0x52,A
  00DA    30E8    LDIA	0xE8
  00DB    00D1    LD	0x51,A
  00DC    28E5    JP	0xE5
208:                              break;
209:              
210:                              case 2:
211:                              *Val=ADsum*100/(*(Val-2));//电池电压
  00DD    0862    LD	A,0x62
  00DE    3EFC    ADDIA	0xFC
  00DF    210E    CALL	0x10E
  00E0    3064    LDIA	0x64
  00E1    00D1    LD	0x51,A
  00E2    01D2    CLR	0x52
  00E3    01D3    CLR	0x53
  00E4    01D4    CLR	0x54
  00E5    261C    CALL	0x61C
  00E6    0850    LD	A,0x50
  00E7    00DC    LD	0x5C,A
  00E8    084F    LD	A,0x4F
  00E9    00DB    LD	0x5B,A
  00EA    084E    LD	A,0x4E
  00EB    00DA    LD	0x5A,A
  00EC    084D    LD	A,0x4D
  00ED    00D9    LD	0x59,A
  00EE    2524    CALL	0x524
  00EF    0862    LD	A,0x62
  00F0    0084    LD	0x4,A
  00F1    0855    LD	A,0x55
  00F2    0080    LD	0x0,A
  00F3    0A84    INCR	0x4
  00F4    0856    LD	A,0x56
  00F5    0080    LD	0x0,A
212:                              break;
  00F6    28FF    JP	0xFF
  00F7    2135    CALL	0x135
  00F8    1803    SZB	0x3,0
  00F9    28FF    JP	0xFF
  00FA    3007    LDIA	0x7
  00FB    008A    LD	0xA,A
  00FC    30CA    LDIA	0xCA
  00FD    0704    ADDA	0x4
  00FE    0082    LD	0x2,A
  00FF    30FF    LDIA	0xFF
213:                          }
214:                          ADCMax=0;
  0100    01AF    CLR	0x2F
  0101    01B0    CLR	0x30
215:                          ADCMin=0xFFFF;
  0102    00AD    LD	0x2D,A
  0103    00AE    LD	0x2E,A
  0104    3003    LDIA	0x3
216:              			ADsum = 0;
  0105    01A5    CLR	0x25
  0106    01A6    CLR	0x26
  0107    01A7    CLR	0x27
  0108    01A8    CLR	0x28
217:                          ADCState++;
  0109    0AC3    INCR	0x43
218:                          if(ADCState>=3)
  010A    0243    SUBA	0x43
  010B    1803    SZB	0x3,0
219:                          {
220:                              ADCState=0;
  010C    01C3    CLR	0x43
  010D    0008    RET
221:                          }
222:              		}
223:              	}
224:              }
225:              
226:              /************************************************************
227:              函数名称：ADSample()
228:              函数功能：AD采样函数
229:              入口参数：ADCH,AD通道
230:              出口参数：ADRESH,ADRESL
231:              备    注：采样成功返回1，超时返回0
232:              ************************************************************/
233:              uint8 ADSample(uint8 ch)
  0733    00F6    LD	0x76,A
234:              {
235:              	ADCON1 = 0x00;					//左对齐
  0734    019F    CLR	0x1F
236:              	ADCON0 = 0X41 | ( ch << 2);	//16分频
  0735    00F5    LD	0x75,A
  0736    3001    LDIA	0x1
  0737    1003    CLRB	0x3,0
  0738    0DF5    RLCR	0x75
  0739    3EFF    ADDIA	0xFF
  073A    1003    CLRB	0x3,0
  073B    1D03    SNZB	0x3,2
  073C    2F38    JP	0x738
  073D    0D75    RLCA	0x75
  073E    3841    ORIA	0x41
  073F    1283    CLRB	0x3,5
  0740    009F    LD	0x1F,A
  0741    0000    NOP
  0742    0000    NOP
237:              	asm("nop");
238:              	asm("nop");
239:              	GODONE = 1;						//开始转换
  0743    1283    CLRB	0x3,5
  0744    1303    CLRB	0x3,6
  0745    149F    SETB	0x1F,1
240:              	volatile unsigned char i = 0;
  0746    01F7    CLR	0x77
241:              	while(GODONE)
  0747    1C9F    SNZB	0x1F,1
  0748    3401    RET	0x1
242:              	{
243:              		if(0 == (--i))				//ad等待限时，防止拔插电后出现死循环
  0749    0BF7    SZDECR	0x77
  074A    2F47    JP	0x747
244:              			return 0;
  074B    3400    RET	0x0
245:              	}
246:              	return 1;
247:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  064F    01CE    CLR	0x4E
  0650    01CF    CLR	0x4F
  0651    0875    LD	A,0x75
  0652    0476    ORA	0x76
  0653    1903    SZB	0x3,2
  0654    2E74    JP	0x674
  0655    01CD    CLR	0x4D
  0656    0ACD    INCR	0x4D
  0657    1BF6    SZB	0x76,7
  0658    2E5D    JP	0x65D
  0659    1003    CLRB	0x3,0
  065A    0DF5    RLCR	0x75
  065B    0DF6    RLCR	0x76
  065C    2E56    JP	0x656
  065D    1003    CLRB	0x3,0
  065E    0DCE    RLCR	0x4E
  065F    0DCF    RLCR	0x4F
  0660    0876    LD	A,0x76
  0661    0278    SUBA	0x78
  0662    1D03    SNZB	0x3,2
  0663    2E66    JP	0x666
  0664    0875    LD	A,0x75
  0665    0277    SUBA	0x77
  0666    1C03    SNZB	0x3,0
  0667    2E70    JP	0x670
  0668    0875    LD	A,0x75
  0669    02F7    SUBR	0x77
  066A    0876    LD	A,0x76
  066B    1C03    SNZB	0x3,0
  066C    03F8    DECR	0x78
  066D    02F8    SUBR	0x78
  066E    144E    SETB	0x4E,0
  066F    1003    CLRB	0x3,0
  0670    0CF6    RRCR	0x76
  0671    0CF5    RRCR	0x75
  0672    0BCD    SZDECR	0x4D
  0673    2E5D    JP	0x65D
  0674    084F    LD	A,0x4F
  0675    00F6    LD	0x76,A
  0676    084E    LD	A,0x4E
  0677    00F5    LD	0x75,A
  0678    0008    RET
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\Motor.c ----------------------------------------------------------------------
1:                #include "Motor.h"
2:                
3:                uint16 WorkCnt=0;
4:                uint16 TimeDecCnt=0;
5:                uint16 TimeAddCnt=0;
6:                
7:                void Motor()
8:                {
9:                    if(!WorkFlag)
  0474    1971    SZB	0x71,2
  0475    2C7D    JP	0x47D
10:                   {
11:                       MotorOff();
  0476    1185    CLRB	0x5,3
12:                       WorkCnt=0;
  0477    1683    SETB	0x3,5
  0478    01D7    CLR	0x57
  0479    01D8    CLR	0x58
13:                       TimeDecCnt=0;
  047A    01D5    CLR	0x55
  047B    01D6    CLR	0x56
14:                   }
  047C    2CA9    JP	0x4A9
15:                   else if(WorkFlag&&!LockSta.LockFlag)
  047D    1971    SZB	0x71,2
  047E    1B2B    SZB	0x2B,6
  047F    2CA9    JP	0x4A9
16:                   {
17:                       MotorOn();
  0480    1585    SETB	0x5,3
18:                       TimeDecCnt++;
  0481    1683    SETB	0x3,5
  0482    0AD5    INCR	0x55
  0483    1903    SZB	0x3,2
  0484    0AD6    INCR	0x56
19:                       if(TimeDecCnt>=BatDecTime*100)
  0485    1283    CLRB	0x3,5
  0486    0844    LD	A,0x44
  0487    24D1    CALL	0x4D1
  0488    271A    CALL	0x71A
  0489    0876    LD	A,0x76
  048A    1683    SETB	0x3,5
  048B    0256    SUBA	0x56
  048C    1D03    SNZB	0x3,2
  048D    2C90    JP	0x490
  048E    0875    LD	A,0x75
  048F    0255    SUBA	0x55
  0490    1C03    SNZB	0x3,0
  0491    2C98    JP	0x498
20:                       {
21:                           TimeDecCnt=0;
  0492    01D5    CLR	0x55
  0493    01D6    CLR	0x56
22:                           if(BatPercent)
  0494    1283    CLRB	0x3,5
  0495    0846    LD	A,0x46
  0496    1D03    SNZB	0x3,2
23:                           {
24:                               BatPercent--;
  0497    03C6    DECR	0x46
25:                           }
26:                       }
27:                       WorkCnt++;
  0498    1683    SETB	0x3,5
  0499    0AD7    INCR	0x57
  049A    1903    SZB	0x3,2
  049B    0AD8    INCR	0x58
28:                       if(WorkCnt>=6000)
  049C    3017    LDIA	0x17
  049D    0258    SUBA	0x58
  049E    3070    LDIA	0x70
  049F    1903    SZB	0x3,2
  04A0    0257    SUBA	0x57
  04A1    1C03    SNZB	0x3,0
  04A2    2CA9    JP	0x4A9
  04A3    3063    LDIA	0x63
29:                       {
30:                           WorkCnt=0;
  04A4    01D7    CLR	0x57
  04A5    01D8    CLR	0x58
31:                           if(WorkMin<99)
  04A6    027A    SUBA	0x7A
  04A7    1C03    SNZB	0x3,0
32:                           {
33:                               WorkMin++;
  04A8    0AFA    INCR	0x7A
34:                           }
35:                       }
36:                   }
37:                   if(USBFlag)
  04A9    1DF1    SNZB	0x71,3
  04AA    2CCD    JP	0x4CD
38:                   {
39:                       TimeAddCnt++;
  04AB    1683    SETB	0x3,5
  04AC    0AD3    INCR	0x53
  04AD    1903    SZB	0x3,2
  04AE    0AD4    INCR	0x54
40:                       if(TimeAddCnt>BatAddTime*100)
  04AF    1283    CLRB	0x3,5
  04B0    0845    LD	A,0x45
  04B1    24D1    CALL	0x4D1
  04B2    271A    CALL	0x71A
  04B3    1683    SETB	0x3,5
  04B4    0854    LD	A,0x54
  04B5    0276    SUBA	0x76
  04B6    1D03    SNZB	0x3,2
  04B7    2CBA    JP	0x4BA
  04B8    0853    LD	A,0x53
  04B9    0275    SUBA	0x75
  04BA    1803    SZB	0x3,0
  04BB    2CC3    JP	0x4C3
  04BC    3063    LDIA	0x63
41:                       {
42:                           TimeAddCnt=0;
  04BD    01D3    CLR	0x53
  04BE    01D4    CLR	0x54
43:                           if(BatPercent<99)
  04BF    1283    CLRB	0x3,5
  04C0    0246    SUBA	0x46
  04C1    1C03    SNZB	0x3,0
44:                           {
45:                               BatPercent++;
  04C2    0AC6    INCR	0x46
46:                           }
47:                       }
48:                       if(BatPercent<=BAT_3V0)
  04C3    30FB    LDIA	0xFB
  04C4    1283    CLRB	0x3,5
  04C5    0246    SUBA	0x46
  04C6    1803    SZB	0x3,0
  04C7    2CCA    JP	0x4CA
49:                       {
50:                           PIN_EN =false;
  04C8    1285    CLRB	0x5,5
51:                       }
  04C9    0008    RET
52:                       else
53:                       {
54:                           PIN_EN =true;
  04CA    1283    CLRB	0x3,5
  04CB    1685    SETB	0x5,5
  04CC    0008    RET
55:                       }
56:                   }
57:                   else
58:                   {
59:                       TimeAddCnt=0;
  04CD    1683    SETB	0x3,5
  04CE    01D3    CLR	0x53
  04CF    01D4    CLR	0x54
  04D0    2CCA    JP	0x4CA
60:                       PIN_EN =true;
61:                   }
62:               }
63:               
64:               
65:               
66:               
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul16.c ----------------------------------------------------------------------
1:                // 16 x 16 bit multiplication with 16 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned int
15:               __wmul(unsigned int multiplier, unsigned int multiplicand)
  071A    01CD    CLR	0x4D
  071B    01CE    CLR	0x4E
  071C    1C75    SNZB	0x75,0
  071D    2F24    JP	0x724
  071E    0877    LD	A,0x77
  071F    07CD    ADDR	0x4D
  0720    1803    SZB	0x3,0
  0721    0ACE    INCR	0x4E
  0722    0878    LD	A,0x78
  0723    07CE    ADDR	0x4E
  0724    1003    CLRB	0x3,0
  0725    0DF7    RLCR	0x77
  0726    0DF8    RLCR	0x78
  0727    1003    CLRB	0x3,0
  0728    0CF6    RRCR	0x76
  0729    0CF5    RRCR	0x75
  072A    0875    LD	A,0x75
  072B    0476    ORA	0x76
  072C    1D03    SNZB	0x3,2
  072D    2F1C    JP	0x71C
  072E    084E    LD	A,0x4E
  072F    00F6    LD	0x76,A
  0730    084D    LD	A,0x4D
  0731    00F5    LD	0x75,A
  0732    0008    RET
16:               {
17:                       unsigned int product;
18:               
19:               #if _Has_hardware_multiply || _Has_large_call_stack
20:               
21:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:               
24:               	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:               /*
26:               a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                      a  b
28:               *      c  d
29:               -----------
30:                    |   bd
31:                    |ad  0
32:                    |bc  0
33:               +  ac| 0  0 (we ignore this intermediate product
34:                            because it does not affect the low 16 bits of the result)
35:               ===========
36:                */
37:                       product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                       product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                       product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:               
41:               #else
42:               
43:               	product = 0;
44:               	do {
45:               		if(multiplier & 1)
46:               			product += multiplicand;
47:               		multiplicand <<= 1;
48:               		multiplier >>= 1;
49:               	} while(multiplier != 0);
50:               
51:               #endif
52:                       return product;
53:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\Key.c ----------------------------------------------------------------------
1:                #include "Key.h"
2:                
3:                bit KeyInBuf=0;
4:                bit KeyPress=0;
5:                uint16 KeyCnt=0;
6:                
7:                bit USBLink=0;
8:                
9:                void KeyScan()
10:               {
11:               	if(!PIN_KEY)
  013A    1283    CLRB	0x3,5
  013B    1303    CLRB	0x3,6
  013C    1B05    SZB	0x5,6
  013D    2940    JP	0x140
12:               	{
13:               		KeyPress=1;
  013E    16F0    SETB	0x70,5
14:               	}
  013F    2941    JP	0x141
15:               	else
16:               	{
17:               		KeyPress=0;
  0140    12F0    CLRB	0x70,5
18:               	}
19:               	/*按键判断*/
20:               	if(KeyPress&&KeyCnt<10&&KeyInBuf==KeyPress&&!IovFlag)
  0141    1EF0    SNZB	0x70,5
  0142    296E    JP	0x16E
  0143    3000    LDIA	0x0
  0144    022A    SUBA	0x2A
  0145    300A    LDIA	0xA
  0146    1903    SZB	0x3,2
  0147    0229    SUBA	0x29
  0148    1803    SZB	0x3,0
  0149    296E    JP	0x16E
  014A    1EF0    SNZB	0x70,5
  014B    294E    JP	0x14E
  014C    3001    LDIA	0x1
  014D    294F    JP	0x14F
  014E    3000    LDIA	0x0
  014F    00F5    LD	0x75,A
  0150    1F70    SNZB	0x70,6
  0151    2954    JP	0x154
  0152    3001    LDIA	0x1
  0153    2955    JP	0x155
  0154    3000    LDIA	0x0
  0155    0675    XORA	0x75
  0156    1903    SZB	0x3,2
  0157    1A71    SZB	0x71,4
  0158    296E    JP	0x16E
21:               	{
22:               		KeyCnt++;
23:               		if(KeyCnt>=10)
  0159    2209    CALL	0x209
  015A    300A    LDIA	0xA
  015B    1903    SZB	0x3,2
  015C    0229    SUBA	0x29
  015D    1C03    SNZB	0x3,0
  015E    29F6    JP	0x1F6
24:               		{
25:               			WorkFlag=~WorkFlag; 
  015F    3004    LDIA	0x4
  0160    06F1    XORR	0x71
26:               			if(!WorkFlag&&WorkMin&&!USBFlag&&!LockSta.LockFlag)
  0161    1971    SZB	0x71,2
  0162    296B    JP	0x16B
  0163    087A    LD	A,0x7A
  0164    1D03    SNZB	0x3,2
  0165    19F1    SZB	0x71,3
  0166    296B    JP	0x16B
  0167    1B2B    SZB	0x2B,6
  0168    296B    JP	0x16B
27:               			{
28:               				OnOffFlag=1;
  0169    17F0    SETB	0x70,7
29:               			}
  016A    29F6    JP	0x1F6
30:               			else
31:               			{
32:               				OnOffFlag=0;
  016B    13F0    CLRB	0x70,7
33:               				WorkMin=0;
  016C    01FA    CLR	0x7A
  016D    29F6    JP	0x1F6
34:               			}
35:               		}
36:               	}
37:               	else if(KeyPress&&KeyCnt>=10&&KeyCnt<250&&KeyInBuf==KeyPress&&!USBFlag)
  016E    1EF0    SNZB	0x70,5
  016F    299C    JP	0x19C
  0170    3000    LDIA	0x0
  0171    022A    SUBA	0x2A
  0172    300A    LDIA	0xA
  0173    1903    SZB	0x3,2
  0174    0229    SUBA	0x29
  0175    1C03    SNZB	0x3,0
  0176    299C    JP	0x19C
  0177    3000    LDIA	0x0
  0178    022A    SUBA	0x2A
  0179    30FA    LDIA	0xFA
  017A    1903    SZB	0x3,2
  017B    0229    SUBA	0x29
  017C    1803    SZB	0x3,0
  017D    299C    JP	0x19C
  017E    1EF0    SNZB	0x70,5
  017F    2982    JP	0x182
  0180    3001    LDIA	0x1
  0181    2983    JP	0x183
  0182    3000    LDIA	0x0
  0183    00F5    LD	0x75,A
  0184    1F70    SNZB	0x70,6
  0185    2988    JP	0x188
  0186    3001    LDIA	0x1
  0187    2989    JP	0x189
  0188    3000    LDIA	0x0
  0189    0675    XORA	0x75
  018A    1903    SZB	0x3,2
  018B    19F1    SZB	0x71,3
  018C    299C    JP	0x19C
38:               	{
39:               		KeyCnt++;
40:               		if(KeyCnt>=250)
  018D    2209    CALL	0x209
  018E    30FA    LDIA	0xFA
  018F    1903    SZB	0x3,2
  0190    0229    SUBA	0x29
  0191    1C03    SNZB	0x3,0
  0192    29F6    JP	0x1F6
41:               		{
42:               			LockNumb=2;
  0193    3002    LDIA	0x2
  0194    00BC    LD	0x3C,A
43:               			if(!LockSta.LockFlag)
  0195    1B2B    SZB	0x2B,6
  0196    2999    JP	0x199
44:               			{
45:               				LockSta.LockStart=1;
  0197    142B    SETB	0x2B,0
46:               				
47:               			}
  0198    299A    JP	0x19A
48:               			else
49:               			{
50:               				LockSta.UnlockStart=1;
  0199    15AB    SETB	0x2B,3
51:               			}
52:               			OnOffFlag=0;
  019A    13F0    CLRB	0x70,7
  019B    29F6    JP	0x1F6
53:               		}
54:               	}
55:               	else if(KeyPress&&KeyCnt>=250&&KeyInBuf==KeyPress&&!LockSta.LockEnd&&!LockSta.UnlockEnd)
  019C    1EF0    SNZB	0x70,5
  019D    29D8    JP	0x1D8
  019E    3000    LDIA	0x0
  019F    022A    SUBA	0x2A
  01A0    30FA    LDIA	0xFA
  01A1    1903    SZB	0x3,2
  01A2    0229    SUBA	0x29
  01A3    1C03    SNZB	0x3,0
  01A4    29D8    JP	0x1D8
  01A5    1EF0    SNZB	0x70,5
  01A6    29A9    JP	0x1A9
  01A7    3001    LDIA	0x1
  01A8    29AA    JP	0x1AA
  01A9    3000    LDIA	0x0
  01AA    00F5    LD	0x75,A
  01AB    1F70    SNZB	0x70,6
  01AC    29AF    JP	0x1AF
  01AD    3001    LDIA	0x1
  01AE    29B0    JP	0x1B0
  01AF    3000    LDIA	0x0
  01B0    0675    XORA	0x75
  01B1    1903    SZB	0x3,2
  01B2    192B    SZB	0x2B,2
  01B3    29D8    JP	0x1D8
  01B4    1AAB    SZB	0x2B,5
  01B5    29D8    JP	0x1D8
56:               	{
57:               		KeyCnt++;
  01B6    0AA9    INCR	0x29
  01B7    1903    SZB	0x3,2
  01B8    0AAA    INCR	0x2A
58:               		if(KeyCnt>=1750)
  01B9    3006    LDIA	0x6
  01BA    022A    SUBA	0x2A
  01BB    30D6    LDIA	0xD6
  01BC    1903    SZB	0x3,2
  01BD    0229    SUBA	0x29
  01BE    1C03    SNZB	0x3,0
  01BF    29F6    JP	0x1F6
59:               		{
60:               			KeyCnt=1750;
  01C0    30D6    LDIA	0xD6
  01C1    00A9    LD	0x29,A
  01C2    3006    LDIA	0x6
  01C3    00AA    LD	0x2A,A
61:               			LockSta.LockFlag=!LockSta.LockFlag;
  01C4    1003    CLRB	0x3,0
  01C5    1F2B    SNZB	0x2B,6
  01C6    1403    SETB	0x3,0
  01C7    1283    CLRB	0x3,5
  01C8    1303    CLRB	0x3,6
  01C9    1C03    SNZB	0x3,0
  01CA    29CD    JP	0x1CD
  01CB    172B    SETB	0x2B,6
  01CC    29CE    JP	0x1CE
  01CD    132B    CLRB	0x2B,6
62:               			if(LockSta.LockFlag)
  01CE    1F2B    SNZB	0x2B,6
  01CF    29D4    JP	0x1D4
63:               			{
64:               				LockSta.LockStart=0;
  01D0    102B    CLRB	0x2B,0
65:               				LockSta.LockEnd=1;
  01D1    152B    SETB	0x2B,2
66:               				WorkFlag=0;
  01D2    1171    CLRB	0x71,2
67:               			}
  01D3    29F6    JP	0x1F6
68:               			else
69:               			{
70:               				LockSta.UnlockStart=0;
  01D4    11AB    CLRB	0x2B,3
71:               				LockSta.UnlockEnd=1;
  01D5    16AB    SETB	0x2B,5
72:               				WorkFlag=1;
  01D6    1571    SETB	0x71,2
  01D7    29F6    JP	0x1F6
73:               			}
74:               		}
75:               	}
76:               	else if(!KeyPress||KeyInBuf!=KeyPress)
  01D8    1EF0    SNZB	0x70,5
  01D9    29E8    JP	0x1E8
  01DA    1EF0    SNZB	0x70,5
  01DB    29DE    JP	0x1DE
  01DC    3001    LDIA	0x1
  01DD    29DF    JP	0x1DF
  01DE    3000    LDIA	0x0
  01DF    00F5    LD	0x75,A
  01E0    1F70    SNZB	0x70,6
  01E1    29E4    JP	0x1E4
  01E2    3001    LDIA	0x1
  01E3    29E5    JP	0x1E5
  01E4    3000    LDIA	0x0
  01E5    0675    XORA	0x75
  01E6    1903    SZB	0x3,2
  01E7    29F6    JP	0x1F6
77:               	{
78:               		KeyCnt=0;
  01E8    01A9    CLR	0x29
  01E9    01AA    CLR	0x2A
79:               		LockSta.UnlockEnd=0;
  01EA    12AB    CLRB	0x2B,5
80:               		if((LockSta.LockFlag&&WorkFlag)||LockSta.UnlockStart)
  01EB    1F2B    SNZB	0x2B,6
  01EC    29EF    JP	0x1EF
  01ED    1971    SZB	0x71,2
  01EE    29F1    JP	0x1F1
  01EF    1DAB    SNZB	0x2B,3
  01F0    29F4    JP	0x1F4
81:               		{
82:               			LockSta.UnlockStart=0;
  01F1    11AB    CLRB	0x2B,3
83:               			LockSta.UnlockFail=1;
  01F2    162B    SETB	0x2B,4
84:               			WorkFlag=0;
  01F3    1171    CLRB	0x71,2
85:               		}
86:               		if(LockSta.LockStart)
  01F4    182B    SZB	0x2B,0
87:               		{
88:               			LockSta.LockStart=0;
  01F5    102B    CLRB	0x2B,0
89:               		}
90:               	}
91:               	KeyInBuf=KeyPress;
  01F6    1370    CLRB	0x70,6
  01F7    1AF0    SZB	0x70,5
  01F8    1770    SETB	0x70,6
92:               
93:               	if(!PIN_USB)
  01F9    1283    CLRB	0x3,5
  01FA    1303    CLRB	0x3,6
  01FB    1B85    SZB	0x5,7
  01FC    29FF    JP	0x1FF
94:               	{
95:               		USBLink=1;
  01FD    1670    SETB	0x70,4
96:               	}
  01FE    2A00    JP	0x200
97:               	else
98:               	{
99:               		USBLink=0;
  01FF    1270    CLRB	0x70,4
100:              	}
101:              	/*USB判断*/
102:              	if(USBLink&&!IovFlag)
  0200    1A70    SZB	0x70,4
  0201    1A71    SZB	0x71,4
  0202    2A06    JP	0x206
103:              	{
104:              		USBFlag=1;
  0203    15F1    SETB	0x71,3
105:              		LockSta.LockFlag=0;
  0204    132B    CLRB	0x2B,6
106:              	}
  0205    0008    RET
107:              	else if(!USBLink)
  0206    1E70    SNZB	0x70,4
108:              	{
109:              		USBFlag=0;
  0207    11F1    CLRB	0x71,3
  0208    0008    RET
110:              	}
111:              }
112:              
---- C:\Users\Administrator\Desktop\project\K13-01\code\LED.c ----------------------------------------------------------------------
1:                #include "LED.h"
2:                
3:                uint8 NumbArr[10]={0x77,0x24,0x5D,0X6D,0X2E,0X6B,0X7B,0X25,0X7F,0X2F};//数字
4:                uint8 HideNumbArr[11]={0,0x40,0x70,0x78,0x7E,0x7F,0x3F,0X0F,0x07,0X01,0};//自下往上扫描
5:                uint16 OffHideNumbArr[7]={0,0x12,0x5B,0X7F,0x97F,0x2DFF,0x3FFF};
6:                // const uint8 LEDSeg1[16][2]=
7:                // {
8:                //     {1,0},{2,1},{2,0},{3,1},{0,1},{3,0},{4,0},//上到下，左到右排序,左数字
9:                //     {0,2},{1,3},{1,2},{2,3},{0,3},{3,2},{4,2},//上到下，左到右排序,右数字
10:               //     {0,4},{1,4}//感叹号、锁
11:               // };
12:               const uint8 LEDSeg1[16]={1,2,2,3,0,3,4,0,1,1,2,0,3,4,0,1};
13:               uint8 LEDSeg2[16]={0,1,0,1,1,0,0,2,3,2,3,3,2,2,4,4};
14:               uint16 LedIndex=0;
15:               uint8 LEDArrMap[5]={0};
16:               
17:               void LEDScan()
18:               {
19:                   static uint8 LEDScanIndex=0;
20:               
21:                   Pin_LED1_CFG(IN,0);
  02E0    1683    SETB	0x3,5
  02E1    1686    SETB	0x6,5
  02E2    1295    CLRB	0x15,5
22:                   Pin_LED2_CFG(IN,0);
  02E3    1606    SETB	0x6,4
  02E4    1215    CLRB	0x15,4
23:                   Pin_LED3_CFG(IN,0);
  02E5    1586    SETB	0x6,3
  02E6    1195    CLRB	0x15,3
24:                   Pin_LED4_CFG(IN,0);
  02E7    1587    SETB	0x7,3
  02E8    1703    SETB	0x3,6
  02E9    118F    CLRB	0xF,3
25:                   Pin_LED5_CFG(IN,0);
  02EA    1303    CLRB	0x3,6
  02EB    1507    SETB	0x7,2
  02EC    1703    SETB	0x3,6
  02ED    110F    CLRB	0xF,2
  02EE    0000    NOP
  02EF    0000    NOP
26:                   asm("nop");	asm("nop");
27:               
28:                   switch(LEDScanIndex)
  02F0    2B46    JP	0x346
29:                   {
30:                       case 0:
31:                       if(LEDArrMap[0]&0x02) 
  02F1    1CA0    SNZB	0x20,1
  02F2    2AF4    JP	0x2F4
32:                       {
33:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  02F3    2375    CALL	0x375
34:                       }
35:               		if(LEDArrMap[0]&0x04)  
  02F4    1D20    SNZB	0x20,2
  02F5    2AF7    JP	0x2F7
36:                       {
37:                           Pin_LED3_CFG(OUT,0);PIN_LED3=L ;
  02F6    236F    CALL	0x36F
38:                       }
39:               		if(LEDArrMap[0]&0x08) 
  02F7    1DA0    SNZB	0x20,3
  02F8    2AFA    JP	0x2FA
40:                       {
41:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  02F9    2359    CALL	0x359
42:                       }
43:               		if(LEDArrMap[0]&0x10) 
  02FA    1E20    SNZB	0x20,4
  02FB    2AFD    JP	0x2FD
44:                       {
45:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  02FC    2361    CALL	0x361
46:                       }
47:               		Pin_LED1_CFG(OUT,0);PIN_LED1=H ;
  02FD    1683    SETB	0x3,5
  02FE    1286    CLRB	0x6,5
  02FF    1295    CLRB	0x15,5
  0300    1283    CLRB	0x3,5
  0301    1686    SETB	0x6,5
48:                       break;
  0302    2B53    JP	0x353
49:               
50:                       case 1:
51:                       if(LEDArrMap[1]&0x01)
  0303    1C21    SNZB	0x21,0
  0304    2B06    JP	0x306
52:                       {
53:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  0305    2369    CALL	0x369
54:                       } 
55:                       if(LEDArrMap[1]&0x04) 
  0306    1D21    SNZB	0x21,2
  0307    2B09    JP	0x309
56:                       {
57:                           Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  0308    236F    CALL	0x36F
58:                       }
59:                       if(LEDArrMap[1]&0x08) 
  0309    1DA1    SNZB	0x21,3
  030A    2B0C    JP	0x30C
60:                       {
61:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  030B    2359    CALL	0x359
62:                       }
63:                       if(LEDArrMap[1]&0x10)
  030C    1E21    SNZB	0x21,4
  030D    2B0F    JP	0x30F
64:                       {
65:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  030E    2361    CALL	0x361
66:                       } 
67:                       Pin_LED2_CFG(OUT,0); PIN_LED2=H ;
  030F    1683    SETB	0x3,5
  0310    1206    CLRB	0x6,4
  0311    1215    CLRB	0x15,4
  0312    1283    CLRB	0x3,5
  0313    1606    SETB	0x6,4
68:                       break;
  0314    2B53    JP	0x353
69:               
70:                       case 2:
71:                       if(LEDArrMap[2]&0x01) 
  0315    1C22    SNZB	0x22,0
  0316    2B18    JP	0x318
72:                       {
73:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  0317    2369    CALL	0x369
74:                       }
75:               		if(LEDArrMap[2]&0x02) 
  0318    1CA2    SNZB	0x22,1
  0319    2B1B    JP	0x31B
76:                       {
77:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  031A    2375    CALL	0x375
78:                       }
79:               		if(LEDArrMap[2]&0x08) 
  031B    1DA2    SNZB	0x22,3
  031C    2B1E    JP	0x31E
80:                       {
81:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  031D    2359    CALL	0x359
82:                       }
83:               		if(LEDArrMap[2]&0x10) 
  031E    1E22    SNZB	0x22,4
  031F    2B21    JP	0x321
84:                       {
85:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  0320    2361    CALL	0x361
86:                       }
87:               		Pin_LED3_CFG(OUT,0);PIN_LED3=H ;
  0321    1683    SETB	0x3,5
  0322    1186    CLRB	0x6,3
  0323    1195    CLRB	0x15,3
  0324    1283    CLRB	0x3,5
  0325    1586    SETB	0x6,3
88:                       break;
  0326    2B53    JP	0x353
89:               
90:                       case 3:
91:                       if(LEDArrMap[3]&0x01)
  0327    1C23    SNZB	0x23,0
  0328    2B2A    JP	0x32A
92:                       {
93:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  0329    2369    CALL	0x369
94:                       }
95:               		if(LEDArrMap[3]&0x02)
  032A    1CA3    SNZB	0x23,1
  032B    2B2D    JP	0x32D
96:                       {
97:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  032C    2375    CALL	0x375
98:                       }
99:               		if(LEDArrMap[3]&0x04)
  032D    1D23    SNZB	0x23,2
  032E    2B30    JP	0x330
100:                      {
101:                          Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  032F    236F    CALL	0x36F
102:                      }
103:              		Pin_LED4_CFG(OUT,0);PIN_LED4=H ;
  0330    1683    SETB	0x3,5
  0331    1187    CLRB	0x7,3
  0332    1703    SETB	0x3,6
  0333    118F    CLRB	0xF,3
  0334    1283    CLRB	0x3,5
  0335    1303    CLRB	0x3,6
  0336    1587    SETB	0x7,3
104:                      break;
  0337    2B53    JP	0x353
105:              
106:                      case 4:
107:                      if(LEDArrMap[4]&0x01)
  0338    1C24    SNZB	0x24,0
  0339    2B3B    JP	0x33B
108:                      {
109:                          Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  033A    2369    CALL	0x369
110:                      }
111:              		if(LEDArrMap[4]&0x04)
  033B    1D24    SNZB	0x24,2
  033C    2B3E    JP	0x33E
112:                      {
113:                          Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  033D    236F    CALL	0x36F
114:                      }
115:                      Pin_LED5_CFG(OUT,0);PIN_LED5=H ;
  033E    1683    SETB	0x3,5
  033F    1107    CLRB	0x7,2
  0340    1703    SETB	0x3,6
  0341    110F    CLRB	0xF,2
  0342    1283    CLRB	0x3,5
  0343    1303    CLRB	0x3,6
  0344    1507    SETB	0x7,2
116:                  }
  0345    2B53    JP	0x353
  0346    1283    CLRB	0x3,5
  0347    1303    CLRB	0x3,6
  0348    083A    LD	A,0x3A
  0349    0084    LD	0x4,A
  034A    3005    LDIA	0x5
  034B    0204    SUBA	0x4
  034C    1803    SZB	0x3,0
  034D    2B53    JP	0x353
  034E    3007    LDIA	0x7
  034F    008A    LD	0xA,A
  0350    30C1    LDIA	0xC1
  0351    0704    ADDA	0x4
  0352    0082    LD	0x2,A
  0353    3005    LDIA	0x5
117:                  LEDScanIndex++;
  0354    0ABA    INCR	0x3A
118:                  if(LEDScanIndex>=5)
  0355    023A    SUBA	0x3A
  0356    1803    SZB	0x3,0
119:                  {
120:                      LEDScanIndex=0;
  0357    01BA    CLR	0x3A
  0358    0008    RET
121:                  }
122:              }
123:              
124:              void DisplayIcon(uint16 index)
125:              {
126:                  uint8 i=0;
127:                  uint16 Mask=0x01;
  05AE    1283    CLRB	0x3,5
  05AF    01CD    CLR	0x4D
  05B0    0ACD    INCR	0x4D
  05B1    01CE    CLR	0x4E
128:              
129:                  for(i=0;i<16;i++)
  05B2    01CF    CLR	0x4F
130:                  {
131:                      if(index&Mask)
  05B3    084D    LD	A,0x4D
  05B4    0575    ANDA	0x75
  05B5    00F7    LD	0x77,A
  05B6    084E    LD	A,0x4E
  05B7    0576    ANDA	0x76
  05B8    00F8    LD	0x78,A
  05B9    0477    ORA	0x77
132:                      {
133:                          LEDArrMap[LEDSeg1[i]]|=(1<<LEDSeg2[i]);
  05BA    3001    LDIA	0x1
  05BB    00F7    LD	0x77,A
  05BC    1903    SZB	0x3,2
  05BD    2DC6    JP	0x5C6
  05BE    25D7    CALL	0x5D7
  05BF    25E4    CALL	0x5E4
  05C0    274C    CALL	0x74C
  05C1    3E20    ADDIA	0x20
  05C2    0084    LD	0x4,A
  05C3    0878    LD	A,0x78
  05C4    0480    ORR	0x0
134:                      }
  05C5    2DCE    JP	0x5CE
135:                      else
136:                      {
137:                          LEDArrMap[LEDSeg1[i]]&=~(1<<LEDSeg2[i]);
  05C6    25D7    CALL	0x5D7
  05C7    3AFF    XORIA	0xFF
  05C8    25E4    CALL	0x5E4
  05C9    274C    CALL	0x74C
  05CA    3E20    ADDIA	0x20
  05CB    0084    LD	0x4,A
  05CC    0878    LD	A,0x78
  05CD    0580    ANDR	0x0
  05CE    3010    LDIA	0x10
138:                      }
139:                      
140:                      Mask<<=1;
  05CF    1003    CLRB	0x3,0
  05D0    0DCD    RLCR	0x4D
  05D1    0DCE    RLCR	0x4E
  05D2    0ACF    INCR	0x4F
  05D3    024F    SUBA	0x4F
  05D4    1803    SZB	0x3,0
  05D5    0008    RET
  05D6    2DB3    JP	0x5B3
141:                  }
142:              }
143:              
144:              void DisplayPro()
145:              {
146:                  LedIndex=0;
  07A3    1683    SETB	0x3,5
  07A4    01D9    CLR	0x59
  07A5    01DA    CLR	0x5A
147:                  WorkLedPro();
  07A6    237B    CALL	0x37B
148:                  USBLedPro();
  07A7    2407    CALL	0x407
149:                  LockPro();
  07A8    24D7    CALL	0x4D7
150:                  ErrPro();
  07A9    2762    CALL	0x762
151:                  DisplayIcon(LedIndex);
  07AA    1683    SETB	0x3,5
  07AB    085A    LD	A,0x5A
  07AC    00F6    LD	0x76,A
  07AD    0859    LD	A,0x59
  07AE    00F5    LD	0x75,A
  07AF    2DAE    JP	0x5AE
152:              }
153:              
154:              void USBLedPro()
155:              {
156:                  static uint8 index=0;
157:                  static uint8 cnt=0;
158:              
159:                  if(USBFlag&&!WorkFlag&&!OnOffFlag)//充电正常
  0407    19F1    SZB	0x71,3
  0408    1971    SZB	0x71,2
  0409    2C5E    JP	0x45E
  040A    1BF0    SZB	0x70,7
  040B    2C5E    JP	0x45E
  040C    3028    LDIA	0x28
160:                  {
161:                      cnt++;
  040D    1283    CLRB	0x3,5
  040E    0AB8    INCR	0x38
162:                      if(cnt>=40)
  040F    0238    SUBA	0x38
  0410    1C03    SNZB	0x3,0
  0411    2C18    JP	0x418
  0412    300B    LDIA	0xB
163:                      {
164:                          cnt=0;
  0413    01B8    CLR	0x38
165:                          index++;
  0414    0AB9    INCR	0x39
166:                          if(index>=11)
  0415    0239    SUBA	0x39
  0416    1803    SZB	0x3,0
167:                          {
168:                              index=0;
  0417    01B9    CLR	0x39
169:                          }
170:                      }
171:                      if(BatPercent<99)
  0418    3063    LDIA	0x63
  0419    0246    SUBA	0x46
172:                      {
173:                          LedIndex=NumbArr[BatPercent/10];
  041A    300A    LDIA	0xA
  041B    1803    SZB	0x3,0
  041C    2C47    JP	0x447
  041D    00F5    LD	0x75,A
  041E    0846    LD	A,0x46
  041F    26E4    CALL	0x6E4
174:                          LedIndex|=((uint16)NumbArr[BatPercent%10]&~HideNumbArr[index])<<7;
  0420    2462    CALL	0x462
  0421    26C8    CALL	0x6C8
  0422    246E    CALL	0x46E
  0423    0839    LD	A,0x39
  0424    3EBE    ADDIA	0xBE
  0425    0084    LD	0x4,A
  0426    0900    COMA	0x0
  0427    054D    ANDA	0x4D
  0428    00CE    LD	0x4E,A
  0429    3007    LDIA	0x7
  042A    01CF    CLR	0x4F
  042B    00FF    LD	0x7F,A
  042C    1003    CLRB	0x3,0
  042D    0DCE    RLCR	0x4E
  042E    0DCF    RLCR	0x4F
  042F    0BFF    SZDECR	0x7F
  0430    2C2C    JP	0x42C
  0431    084E    LD	A,0x4E
  0432    1683    SETB	0x3,5
  0433    04D9    ORR	0x59
  0434    1283    CLRB	0x3,5
  0435    084F    LD	A,0x4F
  0436    1683    SETB	0x3,5
  0437    04DA    ORR	0x5A
175:                          LedIndex&=~HideNumbArr[index];
  0438    1283    CLRB	0x3,5
  0439    0839    LD	A,0x39
  043A    3EBE    ADDIA	0xBE
  043B    0084    LD	0x4,A
  043C    0900    COMA	0x0
  043D    00CD    LD	0x4D,A
  043E    01CE    CLR	0x4E
  043F    09CE    COMR	0x4E
  0440    1683    SETB	0x3,5
  0441    05D9    ANDR	0x59
  0442    1283    CLRB	0x3,5
  0443    084E    LD	A,0x4E
  0444    1683    SETB	0x3,5
  0445    05DA    ANDR	0x5A
176:                      }
  0446    0008    RET
177:                      else
178:                      {
179:                          index=0;
  0447    01B9    CLR	0x39
180:                          LedIndex=NumbArr[BatPercent/10];
  0448    00F5    LD	0x75,A
  0449    0846    LD	A,0x46
  044A    26E4    CALL	0x6E4
181:                          LedIndex|=NumbArr[BatPercent%10]<<7;
  044B    2462    CALL	0x462
  044C    26C8    CALL	0x6C8
  044D    246E    CALL	0x46E
  044E    3007    LDIA	0x7
  044F    01CE    CLR	0x4E
  0450    00FF    LD	0x7F,A
  0451    1003    CLRB	0x3,0
  0452    0DCD    RLCR	0x4D
  0453    0DCE    RLCR	0x4E
  0454    0BFF    SZDECR	0x7F
  0455    2C51    JP	0x451
  0456    084D    LD	A,0x4D
  0457    1683    SETB	0x3,5
  0458    04D9    ORR	0x59
  0459    1283    CLRB	0x3,5
  045A    084E    LD	A,0x4E
  045B    1683    SETB	0x3,5
  045C    04DA    ORR	0x5A
  045D    0008    RET
182:                      }
183:                      
184:                  }
185:                  else
186:                  {
187:                      index=0;
  045E    1283    CLRB	0x3,5
  045F    01B9    CLR	0x39
188:                      cnt=0;
  0460    01B8    CLR	0x38
  0461    0008    RET
189:                  }
190:              }
191:              
192:              void WorkLedPro()
193:              {
194:                  static int8 LedSwitchCnt=0;
195:                  static bit LedSwitchFlag=0;
196:                  static int8 index=0;
197:                  static uint8 cnt=0;
198:                  static bit dir=0;
199:                  if(WorkFlag&&!LockSta.LockStart&&!OnOffFlag&&!LockSta.LockFlag)
  037B    1D71    SNZB	0x71,2
  037C    2BA5    JP	0x3A5
  037D    1283    CLRB	0x3,5
  037E    1C2B    SNZB	0x2B,0
  037F    1BF0    SZB	0x70,7
  0380    2BA5    JP	0x3A5
  0381    1B2B    SZB	0x2B,6
  0382    2BA5    JP	0x3A5
200:                  {
201:                      if(BatPercent<=10)
  0383    300B    LDIA	0xB
  0384    0246    SUBA	0x46
  0385    1803    SZB	0x3,0
  0386    2B90    JP	0x390
  0387    3028    LDIA	0x28
202:                      {
203:                          LedSwitchCnt++;
  0388    0AB7    INCR	0x37
204:                          if(LedSwitchCnt>=40)
  0389    0237    SUBA	0x37
  038A    1C03    SNZB	0x3,0
  038B    2B92    JP	0x392
  038C    3008    LDIA	0x8
205:                          {
206:                              LedSwitchCnt=0;
  038D    01B7    CLR	0x37
207:                              LedSwitchFlag=!LedSwitchFlag;
  038E    06F0    XORR	0x70
  038F    2B92    JP	0x392
208:                          }
209:                      }
210:                      else
211:                      {
212:                          LedSwitchCnt=0;
  0390    01B7    CLR	0x37
213:                          LedSwitchFlag=1;
  0391    15F0    SETB	0x70,3
214:                      }
215:                      if(LedSwitchFlag)
  0392    1DF0    SNZB	0x70,3
  0393    0008    RET
216:                      {
217:                          LedIndex|=NumbArr[BatPercent/10];
  0394    300A    LDIA	0xA
  0395    00F5    LD	0x75,A
  0396    0846    LD	A,0x46
  0397    26E4    CALL	0x6E4
  0398    3EC9    ADDIA	0xC9
  0399    0084    LD	0x4,A
  039A    1383    CLRB	0x3,7
  039B    0800    LD	A,0x0
  039C    1683    SETB	0x3,5
  039D    04D9    ORR	0x59
218:                          LedIndex|=(uint16)NumbArr[BatPercent%10]<<7;
  039E    300A    LDIA	0xA
  039F    00F5    LD	0x75,A
  03A0    1283    CLRB	0x3,5
  03A1    0846    LD	A,0x46
  03A2    26C8    CALL	0x6C8
  03A3    23E3    CALL	0x3E3
  03A4    0008    RET
219:                      }
220:                  }
221:                  else if(OnOffFlag)
  03A5    1FF0    SNZB	0x70,7
  03A6    0008    RET
  03A7    3028    LDIA	0x28
222:                  {
223:                      cnt++;
  03A8    1283    CLRB	0x3,5
  03A9    0AB5    INCR	0x35
224:                      if(cnt>=40)
  03AA    0235    SUBA	0x35
  03AB    1C03    SNZB	0x3,0
  03AC    2BBB    JP	0x3BB
  03AD    3007    LDIA	0x7
225:                      {
226:                          cnt=0;
  03AE    01B5    CLR	0x35
227:                          index++;
  03AF    0AB6    INCR	0x36
228:                          if(index>=7)
  03B0    0236    SUBA	0x36
  03B1    1C03    SNZB	0x3,0
  03B2    2BBB    JP	0x3BB
229:                          {
230:                              if(dir)
  03B3    1D70    SNZB	0x70,2
  03B4    2BB8    JP	0x3B8
231:                              {
232:                                  OnOffFlag=0;
  03B5    13F0    CLRB	0x70,7
233:                                  WorkMin=0;
  03B6    01FA    CLR	0x7A
  03B7    0008    RET
234:                                  return;
235:                              }
236:                              dir=!dir;
  03B8    3004    LDIA	0x4
  03B9    06F0    XORR	0x70
237:                              index=0;
  03BA    01B6    CLR	0x36
238:                          }
239:                      }
240:                      if(!dir)
  03BB    1970    SZB	0x70,2
  03BC    2BCA    JP	0x3CA
241:                      {
242:                          LedIndex=NumbArr[BatPercent/10];
  03BD    300A    LDIA	0xA
  03BE    00F5    LD	0x75,A
  03BF    0846    LD	A,0x46
  03C0    26E4    CALL	0x6E4
243:                          LedIndex|=(uint16)NumbArr[BatPercent%10]<<7;
  03C1    2462    CALL	0x462
  03C2    26C8    CALL	0x6C8
  03C3    23E3    CALL	0x3E3
244:                          LedIndex&=~OffHideNumbArr[index];
  03C4    1283    CLRB	0x3,5
  03C5    1003    CLRB	0x3,0
  03C6    0D36    RLCA	0x36
  03C7    3EB0    ADDIA	0xB0
  03C8    0084    LD	0x4,A
245:                      }
  03C9    2BF8    JP	0x3F8
246:                      else
247:                      {
248:                          LedIndex=NumbArr[WorkMin/10];
  03CA    300A    LDIA	0xA
  03CB    00F5    LD	0x75,A
  03CC    087A    LD	A,0x7A
  03CD    26E4    CALL	0x6E4
  03CE    3EC9    ADDIA	0xC9
  03CF    0084    LD	0x4,A
  03D0    1383    CLRB	0x3,7
  03D1    0800    LD	A,0x0
  03D2    1683    SETB	0x3,5
  03D3    00D9    LD	0x59,A
  03D4    300A    LDIA	0xA
  03D5    01DA    CLR	0x5A
249:                          LedIndex|=(uint16)NumbArr[WorkMin%10]<<7;
  03D6    00F5    LD	0x75,A
  03D7    087A    LD	A,0x7A
  03D8    26C8    CALL	0x6C8
  03D9    23E3    CALL	0x3E3
250:                          LedIndex&=~OffHideNumbArr[6-index];
  03DA    30FE    LDIA	0xFE
  03DB    00F5    LD	0x75,A
  03DC    1283    CLRB	0x3,5
  03DD    0836    LD	A,0x36
  03DE    2795    CALL	0x795
  03DF    3EBC    ADDIA	0xBC
  03E0    0084    LD	0x4,A
  03E1    1383    CLRB	0x3,7
  03E2    2BF8    JP	0x3F8
251:                      }
252:                  }
253:              }
254:              
255:              void LockPro()
256:              {
257:                  static uint8 SwitchCnt=0,LockSwitchCnt=0;
258:                  static uint8 Ledcnt=0;
259:                  static bit LedSwitchFlag=0;
260:                  if(!USBFlag)
  04D7    19F1    SZB	0x71,3
  04D8    0008    RET
261:                  {
262:                      if(LockSta.LockStart||LockSta.UnlockStart)
  04D9    1283    CLRB	0x3,5
  04DA    182B    SZB	0x2B,0
  04DB    2CDE    JP	0x4DE
  04DC    1DAB    SNZB	0x2B,3
  04DD    2D06    JP	0x506
  04DE    3064    LDIA	0x64
263:                      {
264:                          SwitchCnt++;
  04DF    0AB4    INCR	0x34
265:                          if(SwitchCnt>=100)
  04E0    0234    SUBA	0x34
  04E1    1C03    SNZB	0x3,0
  04E2    2CE8    JP	0x4E8
266:                          {
267:                              SwitchCnt=0;
  04E3    01B4    CLR	0x34
268:                              if(LockNumb>0)
  04E4    083C    LD	A,0x3C
  04E5    1903    SZB	0x3,2
  04E6    2CE8    JP	0x4E8
269:                              {
270:                                  LockNumb--;
  04E7    03BC    DECR	0x3C
271:                              }
272:                          }
273:                          LedIndex=NumbArr[0];
  04E8    1683    SETB	0x3,5
  04E9    0849    LD	A,0x49
  04EA    00D9    LD	0x59,A
  04EB    01DA    CLR	0x5A
274:                          LedIndex|=(uint16)NumbArr[LockNumb+1]<<7;
  04EC    1283    CLRB	0x3,5
  04ED    083C    LD	A,0x3C
  04EE    3ECA    ADDIA	0xCA
  04EF    0084    LD	0x4,A
  04F0    1383    CLRB	0x3,7
  04F1    0800    LD	A,0x0
  04F2    00F5    LD	0x75,A
  04F3    3007    LDIA	0x7
  04F4    01F6    CLR	0x76
  04F5    00FF    LD	0x7F,A
  04F6    1003    CLRB	0x3,0
  04F7    0DF5    RLCR	0x75
  04F8    0DF6    RLCR	0x76
  04F9    0BFF    SZDECR	0x7F
  04FA    2CF6    JP	0x4F6
  04FB    0875    LD	A,0x75
  04FC    1683    SETB	0x3,5
  04FD    04D9    ORR	0x59
  04FE    0876    LD	A,0x76
  04FF    04DA    ORR	0x5A
275:                          if(LockSta.UnlockStart)
  0500    1283    CLRB	0x3,5
  0501    1DAB    SNZB	0x2B,3
  0502    2D07    JP	0x507
276:                          {
277:                              LedIndex|=iconLock;
  0503    1683    SETB	0x3,5
  0504    17DA    SETB	0x5A,7
  0505    2D07    JP	0x507
278:                          }
279:                      }
280:                      else
281:                      {
282:                          SwitchCnt=0;
  0506    01B4    CLR	0x34
283:                      }
284:                      if(LockSta.LockEnd||LockSta.UnlockFail)
  0507    1283    CLRB	0x3,5
  0508    192B    SZB	0x2B,2
  0509    2D0C    JP	0x50C
  050A    1E2B    SNZB	0x2B,4
  050B    2D21    JP	0x521
  050C    3023    LDIA	0x23
285:                      {
286:                          LockSwitchCnt++;
  050D    0AB3    INCR	0x33
287:                          if(LockSwitchCnt>=35)
  050E    0233    SUBA	0x33
  050F    1C03    SNZB	0x3,0
  0510    2D1D    JP	0x51D
  0511    3002    LDIA	0x2
288:                          {
289:                              LockSwitchCnt=0;
  0512    01B3    CLR	0x33
290:                              LedSwitchFlag=!LedSwitchFlag;
  0513    06F0    XORR	0x70
291:                              if(!LedSwitchFlag)
  0514    18F0    SZB	0x70,1
  0515    2D1D    JP	0x51D
  0516    3004    LDIA	0x4
292:                              {
293:                                  Ledcnt++;
  0517    0AB2    INCR	0x32
294:                                  if(Ledcnt>=4)
  0518    0232    SUBA	0x32
  0519    1C03    SNZB	0x3,0
  051A    2D1D    JP	0x51D
295:                                  {
296:                                      LockSta.LockEnd=0;
  051B    112B    CLRB	0x2B,2
297:                                      LockSta.UnlockFail=0;
  051C    122B    CLRB	0x2B,4
298:                                  }
299:                              }
300:                          }
301:                          if(LedSwitchFlag)
  051D    1CF0    SNZB	0x70,1
  051E    0008    RET
302:                          {
303:                              LedIndex=iconLock;
  051F    3080    LDIA	0x80
  0520    2F74    JP	0x774
304:                          }
305:                      }
306:                      else
307:                      {
308:                          Ledcnt=0;
  0521    01B2    CLR	0x32
309:                          LockSwitchCnt=0;
  0522    01B3    CLR	0x33
  0523    0008    RET
310:                      }
311:                  }
312:              }
313:              
314:              void ErrPro()
315:              {
316:                  static uint8 SwitchCnt=0;
317:                  static bit LedSwitchFlag=0;
318:                  if(IovFlag)
  0762    1E71    SNZB	0x71,4
  0763    2F71    JP	0x771
  0764    3023    LDIA	0x23
319:                  {
320:                      SwitchCnt++;
  0765    1283    CLRB	0x3,5
  0766    0AB1    INCR	0x31
321:                      if(SwitchCnt>=35)
  0767    0231    SUBA	0x31
  0768    1C03    SNZB	0x3,0
  0769    2F6D    JP	0x76D
  076A    3001    LDIA	0x1
322:                      {
323:                          SwitchCnt=0;
  076B    01B1    CLR	0x31
324:                          LedSwitchFlag=!LedSwitchFlag;
  076C    06F0    XORR	0x70
325:              
326:                      }
327:                      if(LedSwitchFlag)
  076D    1C70    SNZB	0x70,0
  076E    0008    RET
328:                      {
329:                          LedIndex=iconErr;
  076F    3040    LDIA	0x40
  0770    2F74    JP	0x774
330:                      }
331:                  }
332:                  else
333:                  {
334:                      SwitchCnt=0;
  0771    1283    CLRB	0x3,5
  0772    01B1    CLR	0x31
  0773    0008    RET
335:                  }
336:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul8.c ----------------------------------------------------------------------
1:                // 8 x 8 bit multiplication with 8 bit result
2:                
3:                unsigned char
4:                __bmul(unsigned char multiplier, unsigned char multiplicand)
  0795    00F7    LD	0x77,A
  0796    01F6    CLR	0x76
  0797    0875    LD	A,0x75
  0798    1877    SZB	0x77,0
  0799    07F6    ADDR	0x76
  079A    1003    CLRB	0x3,0
  079B    0DF5    RLCR	0x75
  079C    1003    CLRB	0x3,0
  079D    0CF7    RRCR	0x77
  079E    0877    LD	A,0x77
  079F    1D03    SNZB	0x3,2
  07A0    2F97    JP	0x797
  07A1    0876    LD	A,0x76
  07A2    0008    RET
5:                {
6:                	unsigned char product = 0;
7:                
8:                #if defined(__OPTIMIZE_SPEED__)
9:                
10:               	if(multiplier & 0x01)
11:               		product = (product + multiplicand) & 0xff;
12:               	multiplicand <<= 1;
13:               
14:               	if(multiplier & 0x02)
15:               		product = (product + multiplicand) & 0xff;
16:               	multiplicand <<= 1;
17:               
18:               	if(multiplier & 0x04)
19:               		product = (product + multiplicand) & 0xff;
20:               	multiplicand <<= 1;
21:               
22:               	if(multiplier & 0x08)
23:               		product = (product + multiplicand) & 0xff;
24:               	multiplicand <<= 1;
25:               
26:               	if(multiplier & 0x10)
27:               		product = (product + multiplicand) & 0xff;
28:               	multiplicand <<= 1;
29:               
30:               	if(multiplier & 0x20)
31:               		product = (product + multiplicand) & 0xff;
32:               	multiplicand <<= 1;
33:               
34:               	if(multiplier & 0x40)
35:               		product = (product + multiplicand) & 0xff;
36:               	multiplicand <<= 1;
37:               
38:               	if(multiplier & 0x80)
39:               		product = (product + multiplicand) & 0xff;
40:               
41:               #else
42:               	do {
43:               		if(multiplier & 1)
44:               			product += multiplicand;
45:               		multiplicand <<= 1;
46:               		multiplier >>= 1;
47:               	} while(multiplier != 0);
48:               
49:               #endif
50:               	return product;
51:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  06C8    00F7    LD	0x77,A
  06C9    3008    LDIA	0x8
  06CA    00F8    LD	0x78,A
  06CB    01F9    CLR	0x79
  06CC    0877    LD	A,0x77
  06CD    00F6    LD	0x76,A
  06CE    3007    LDIA	0x7
  06CF    1003    CLRB	0x3,0
  06D0    0CF6    RRCR	0x76
  06D1    3EFF    ADDIA	0xFF
  06D2    1003    CLRB	0x3,0
  06D3    1D03    SNZB	0x3,2
  06D4    2ED0    JP	0x6D0
  06D5    0D79    RLCA	0x79
  06D6    0476    ORA	0x76
  06D7    00F9    LD	0x79,A
  06D8    1003    CLRB	0x3,0
  06D9    0DF7    RLCR	0x77
  06DA    0875    LD	A,0x75
  06DB    0279    SUBA	0x79
  06DC    1C03    SNZB	0x3,0
  06DD    2EE0    JP	0x6E0
  06DE    0875    LD	A,0x75
  06DF    02F9    SUBR	0x79
  06E0    0BF8    SZDECR	0x78
  06E1    2ECC    JP	0x6CC
  06E2    0879    LD	A,0x79
  06E3    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  06E4    00F6    LD	0x76,A
  06E5    01F8    CLR	0x78
  06E6    0875    LD	A,0x75
  06E7    1903    SZB	0x3,2
  06E8    2EFD    JP	0x6FD
  06E9    01F7    CLR	0x77
  06EA    0AF7    INCR	0x77
  06EB    1BF5    SZB	0x75,7
  06EC    2EF0    JP	0x6F0
  06ED    1003    CLRB	0x3,0
  06EE    0DF5    RLCR	0x75
  06EF    2EEA    JP	0x6EA
  06F0    1003    CLRB	0x3,0
  06F1    0DF8    RLCR	0x78
  06F2    0875    LD	A,0x75
  06F3    0276    SUBA	0x76
  06F4    1C03    SNZB	0x3,0
  06F5    2EFA    JP	0x6FA
  06F6    0875    LD	A,0x75
  06F7    02F6    SUBR	0x76
  06F8    1478    SETB	0x78,0
  06F9    1003    CLRB	0x3,0
  06FA    0CF5    RRCR	0x75
  06FB    0BF7    SZDECR	0x77
  06FC    2EF0    JP	0x6F0
  06FD    0878    LD	A,0x78
  06FE    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul32.c ----------------------------------------------------------------------
1:                // 32 x 32 bit multiplication with 32 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned long
15:               __lmul(unsigned long multiplier, unsigned long multiplicand)
  061C    01F5    CLR	0x75
  061D    01F6    CLR	0x76
  061E    01F7    CLR	0x77
  061F    01F8    CLR	0x78
  0620    1C4D    SNZB	0x4D,0
  0621    2E36    JP	0x636
  0622    0851    LD	A,0x51
  0623    07F5    ADDR	0x75
  0624    0852    LD	A,0x52
  0625    1103    CLRB	0x3,2
  0626    1803    SZB	0x3,0
  0627    3E01    ADDIA	0x1
  0628    1D03    SNZB	0x3,2
  0629    07F6    ADDR	0x76
  062A    0853    LD	A,0x53
  062B    1103    CLRB	0x3,2
  062C    1803    SZB	0x3,0
  062D    3E01    ADDIA	0x1
  062E    1D03    SNZB	0x3,2
  062F    07F7    ADDR	0x77
  0630    0854    LD	A,0x54
  0631    1103    CLRB	0x3,2
  0632    1803    SZB	0x3,0
  0633    3E01    ADDIA	0x1
  0634    1D03    SNZB	0x3,2
  0635    07F8    ADDR	0x78
  0636    1003    CLRB	0x3,0
  0637    0DD1    RLCR	0x51
  0638    0DD2    RLCR	0x52
  0639    0DD3    RLCR	0x53
  063A    0DD4    RLCR	0x54
  063B    1003    CLRB	0x3,0
  063C    0CD0    RRCR	0x50
  063D    0CCF    RRCR	0x4F
  063E    0CCE    RRCR	0x4E
  063F    0CCD    RRCR	0x4D
  0640    0850    LD	A,0x50
  0641    044F    ORA	0x4F
  0642    044E    ORA	0x4E
  0643    044D    ORA	0x4D
  0644    1D03    SNZB	0x3,2
  0645    2E20    JP	0x620
  0646    0878    LD	A,0x78
  0647    00D0    LD	0x50,A
  0648    0877    LD	A,0x77
  0649    00CF    LD	0x4F,A
  064A    0876    LD	A,0x76
  064B    00CE    LD	0x4E,A
  064C    0875    LD	A,0x75
  064D    00CD    LD	0x4D,A
  064E    0008    RET
16:               {
17:               	unsigned long product;
18:               
19:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:               #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:               #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:               
24:               #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:               	{
26:               
27:               #define USE_SHRINK
28:               
29:               /*
30:               a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                            a  b  c  d
32:               *            e  f  g  h
33:               -----------------------
34:                          |         dh
35:                          |      ch  0
36:                          |   bh  0  0
37:                          |ah  0  0  0
38:                          |      dg  0
39:                          |   cg  0  0
40:                          |bg  0  0  0
41:                        ag| 0  0  0  0 (we ignore this intermediate product
42:                                        because it does not affect the low 32 bits of the result)
43:                          |   df  0  0
44:                          |cf  0  0  0
45:                        bf| 0  0  0  0 (ignore)
46:                     af  0| 0  0  0  0 (ignore)
47:                          |de  0  0  0
48:                        ce| 0  0  0  0 (ignore)
49:                     be  0| 0  0  0  0 (ignore)
50:               +  ae  0  0| 0  0  0  0 (ignore)
51:               =======================
52:                */
53:               		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:               
55:               #if defined(USE_MASKS)
56:               		product += ((unsigned long)
57:               			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:               			     +
59:               			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:               			<< 8;
61:               
62:               		product += ((unsigned long)
63:               			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:               			    +
65:               			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:               			    +
67:               			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:               			<< 16;
69:               
70:               		/* cast to smaller type to avoid adding high bits just to discard */
71:               		product += ((unsigned long)
72:               			    (unsigned char)
73:               			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:               			    +
75:               			    (unsigned char)
76:               			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:               			    +
78:               			    (unsigned char)
79:               			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:               			    +
81:               			    (unsigned char)
82:               			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:               			<< 24;
84:               
85:               #elif defined(USE_SHRINK)
86:               		/* add direct to upper bytes, rather than shift and add all bytes */
87:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:               			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:               			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:               
92:               
93:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:               			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:               			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:               			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:               
100:              		*(((unsigned char*)&product)+3) +=
101:              			(unsigned char)
102:              			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:              		*(((unsigned char*)&product)+3) +=
104:              			(unsigned char)
105:              			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:              		*(((unsigned char*)&product)+3) +=
107:              			(unsigned char)
108:              			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:              		*(((unsigned char*)&product)+3) +=
110:              			(unsigned char)
111:              			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:              
113:              #else
114:              #error No method chosen
115:              #endif
116:              	}
117:              #else
118:              
119:              	product = 0;
120:              	do {
121:              		if(multiplier & 1)
122:              			product += multiplicand;
123:              		multiplicand <<= 1;
124:              		multiplier >>= 1;
125:              	} while(multiplier != 0);
126:              
127:              #endif
128:              	return product;
129:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lldiv.c ----------------------------------------------------------------------
1:                // long unsigned unsigned division
2:                
3:                unsigned long int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lldiv(unsigned long int divisor, unsigned long int dividend)
  0524    01DD    CLR	0x5D
  0525    01DE    CLR	0x5E
  0526    01DF    CLR	0x5F
  0527    01E0    CLR	0x60
  0528    0858    LD	A,0x58
  0529    0457    ORA	0x57
  052A    0456    ORA	0x56
  052B    0455    ORA	0x55
  052C    1903    SZB	0x3,2
  052D    2D63    JP	0x563
  052E    01E1    CLR	0x61
  052F    0AE1    INCR	0x61
  0530    1BD8    SZB	0x58,7
  0531    2D38    JP	0x538
  0532    1003    CLRB	0x3,0
  0533    0DD5    RLCR	0x55
  0534    0DD6    RLCR	0x56
  0535    0DD7    RLCR	0x57
  0536    0DD8    RLCR	0x58
  0537    2D2F    JP	0x52F
  0538    1003    CLRB	0x3,0
  0539    0DDD    RLCR	0x5D
  053A    0DDE    RLCR	0x5E
  053B    0DDF    RLCR	0x5F
  053C    0DE0    RLCR	0x60
  053D    0858    LD	A,0x58
  053E    025C    SUBA	0x5C
  053F    1D03    SNZB	0x3,2
  0540    2D4B    JP	0x54B
  0541    0857    LD	A,0x57
  0542    025B    SUBA	0x5B
  0543    1D03    SNZB	0x3,2
  0544    2D4B    JP	0x54B
  0545    0856    LD	A,0x56
  0546    025A    SUBA	0x5A
  0547    1D03    SNZB	0x3,2
  0548    2D4B    JP	0x54B
  0549    0855    LD	A,0x55
  054A    0259    SUBA	0x59
  054B    1C03    SNZB	0x3,0
  054C    2D5D    JP	0x55D
  054D    0855    LD	A,0x55
  054E    02D9    SUBR	0x59
  054F    0856    LD	A,0x56
  0550    1C03    SNZB	0x3,0
  0551    0F56    SZINCA	0x56
  0552    02DA    SUBR	0x5A
  0553    0857    LD	A,0x57
  0554    1C03    SNZB	0x3,0
  0555    0F57    SZINCA	0x57
  0556    02DB    SUBR	0x5B
  0557    0858    LD	A,0x58
  0558    1C03    SNZB	0x3,0
  0559    0F58    SZINCA	0x58
  055A    02DC    SUBR	0x5C
  055B    145D    SETB	0x5D,0
  055C    1003    CLRB	0x3,0
  055D    0CD8    RRCR	0x58
  055E    0CD7    RRCR	0x57
  055F    0CD6    RRCR	0x56
  0560    0CD5    RRCR	0x55
  0561    0BE1    SZDECR	0x61
  0562    2D38    JP	0x538
  0563    0860    LD	A,0x60
  0564    00D8    LD	0x58,A
  0565    085F    LD	A,0x5F
  0566    00D7    LD	0x57,A
  0567    085E    LD	A,0x5E
  0568    00D6    LD	0x56,A
  0569    085D    LD	A,0x5D
  056A    00D5    LD	0x55,A
  056B    0008    RET
7:                #else
8:                __lldiv(unsigned long int dividend, unsigned long int divisor)
9:                #endif
10:               {
11:               	unsigned long int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x80000000UL) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\even.c ----------------------------------------------------------------------
1:                #include "even.h"
2:                
3:                uint8 cnt2ms=0;
4:                uint8 cnt10ms=0;
5:                bit time2ms=0;
6:                bit time10ms=0;
7:                
8:                void interrupt Isr_Timer()
9:                {
10:                   TMR2IF = 0;
  06FF    1283    CLRB	0x3,5
  0700    1303    CLRB	0x3,6
  0701    108C    CLRB	0xC,1
  0702    300A    LDIA	0xA
11:                   cnt2ms++;
  0703    0ABF    INCR	0x3F
12:                   cnt10ms++;
  0704    0ABE    INCR	0x3E
13:                   if(cnt2ms>=10)
  0705    023F    SUBA	0x3F
  0706    1C03    SNZB	0x3,0
  0707    2F0B    JP	0x70B
14:                   {
15:                       LEDScan();
  0708    22E0    CALL	0x2E0
16:                       cnt2ms=0;
  0709    01BF    CLR	0x3F
17:                       time2ms=1;
  070A    14F1    SETB	0x71,1
18:                   }
19:                   if(cnt10ms>=50)
  070B    3032    LDIA	0x32
  070C    023E    SUBA	0x3E
  070D    1C03    SNZB	0x3,0
  070E    2F11    JP	0x711
20:                   {
21:                       cnt10ms=0;
  070F    01BE    CLR	0x3E
22:                       time10ms=1;
  0710    1471    SETB	0x71,0
  0711    0874    LD	A,0x74
  0712    008A    LD	0xA,A
  0713    0873    LD	A,0x73
  0714    0084    LD	0x4,A
  0715    0E72    SWAPA	0x72
  0716    0083    LD	0x3,A
  0717    0EFE    SWAPR	0x7E
  0718    0E7E    SWAPA	0x7E
  0719    0009    RETI
23:                   }
24:               }
25:               
26:               
27:               
28:               
29:               
30:               
31:               
32:               
33:               
34:               
35:               
36:               
---- stringtab ------------------------------------------------------------------
  074C    3007    LDIA	0x7
  074D    008A    LD	0xA,A
  074E    0804    LD	A,0x4
  074F    0A84    INCR	0x4
  0750    0782    ADDR	0x2
  0751    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    30D3    LDIA	0xD3
  000E    1383    CLRB	0x3,7
  000F    00FD    LD	0x7D,A
  0010    3005    LDIA	0x5
  0011    00FE    LD	0x7E,A
  0012    30E9    LDIA	0xE9
  0013    00FF    LD	0x7F,A
  0014    30A0    LDIA	0xA0
  0015    0084    LD	0x4,A
  0016    277C    CALL	0x77C
  0017    30D3    LDIA	0xD3
  0018    0084    LD	0x4,A
  0019    30DB    LDIA	0xDB
  001A    27B9    CALL	0x7B9
  001B    3020    LDIA	0x20
  001C    0084    LD	0x4,A
  001D    304D    LDIA	0x4D
  001E    27B9    CALL	0x7B9
  001F    01FA    CLR	0x7A
  0020    01F0    CLR	0x70
  0021    01F1    CLR	0x71
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F2    LD	0x72,A
  0007    0804    LD	A,0x4
  0008    00F3    LD	0x73,A
  0009    080A    LD	A,0xA
  000A    00F4    LD	0x74,A
  000B    2EFF    JP	0x6FF
---- common_function ------------------------------------------------------------------
  0001    2D6D    JP	0x56D
  0002    2D72    JP	0x572
  0003    2D77    JP	0x577
  0022    0183    CLR	0x3
  0023    2FC6    JP	0x7C6
  010E    0084    LD	0x4,A
  010F    1383    CLRB	0x3,7
  0110    0800    LD	A,0x0
  0111    00E3    LD	0x63,A
  0112    0A84    INCR	0x4
  0113    0800    LD	A,0x0
  0114    00E4    LD	0x64,A
  0115    0863    LD	A,0x63
  0116    00D5    LD	0x55,A
  0117    0864    LD	A,0x64
  0118    00D6    LD	0x56,A
  0119    01D7    CLR	0x57
  011A    01D8    CLR	0x58
  011B    0828    LD	A,0x28
  011C    00D0    LD	0x50,A
  011D    0827    LD	A,0x27
  011E    00CF    LD	0x4F,A
  011F    0826    LD	A,0x26
  0120    00CE    LD	0x4E,A
  0121    0825    LD	A,0x25
  0122    00CD    LD	0x4D,A
  0123    0008    RET
  0124    0863    LD	A,0x63
  0125    07A5    ADDR	0x25
  0126    0864    LD	A,0x64
  0127    1103    CLRB	0x3,2
  0128    1803    SZB	0x3,0
  0129    3E01    ADDIA	0x1
  012A    1D03    SNZB	0x3,2
  012B    07A6    ADDR	0x26
  012C    0865    LD	A,0x65
  012D    1103    CLRB	0x3,2
  012E    1803    SZB	0x3,0
  012F    3E01    ADDIA	0x1
  0130    1D03    SNZB	0x3,2
  0131    07A7    ADDR	0x27
  0132    0866    LD	A,0x66
  0133    1103    CLRB	0x3,2
  0134    0008    RET
  0135    0843    LD	A,0x43
  0136    0084    LD	0x4,A
  0137    3003    LDIA	0x3
  0138    0204    SUBA	0x4
  0139    0008    RET
  0209    0AA9    INCR	0x29
  020A    1903    SZB	0x3,2
  020B    0AAA    INCR	0x2A
  020C    3000    LDIA	0x0
  020D    022A    SUBA	0x2A
  020E    0008    RET
  02CF    0840    LD	A,0x40
  02D0    00D0    LD	0x50,A
  02D1    01D1    CLR	0x51
  02D2    0851    LD	A,0x51
  02D3    0254    SUBA	0x54
  02D4    1D03    SNZB	0x3,2
  02D5    2AD8    JP	0x2D8
  02D6    0850    LD	A,0x50
  02D7    0253    SUBA	0x53
  02D8    0840    LD	A,0x40
  02D9    0008    RET
  02DA    07D3    ADDR	0x53
  02DB    1803    SZB	0x3,0
  02DC    0AD4    INCR	0x54
  02DD    30FE    LDIA	0xFE
  02DE    07D4    ADDR	0x54
  02DF    0008    RET
  0359    1683    SETB	0x3,5
  035A    1187    CLRB	0x7,3
  035B    1703    SETB	0x3,6
  035C    118F    CLRB	0xF,3
  035D    1283    CLRB	0x3,5
  035E    1303    CLRB	0x3,6
  035F    1187    CLRB	0x7,3
  0360    0008    RET
  0361    1683    SETB	0x3,5
  0362    1107    CLRB	0x7,2
  0363    1703    SETB	0x3,6
  0364    110F    CLRB	0xF,2
  0365    1283    CLRB	0x3,5
  0366    1303    CLRB	0x3,6
  0367    1107    CLRB	0x7,2
  0368    0008    RET
  0369    1683    SETB	0x3,5
  036A    1286    CLRB	0x6,5
  036B    1295    CLRB	0x15,5
  036C    1283    CLRB	0x3,5
  036D    1286    CLRB	0x6,5
  036E    0008    RET
  036F    1683    SETB	0x3,5
  0370    1186    CLRB	0x6,3
  0371    1195    CLRB	0x15,3
  0372    1283    CLRB	0x3,5
  0373    1186    CLRB	0x6,3
  0374    0008    RET
  0375    1683    SETB	0x3,5
  0376    1206    CLRB	0x6,4
  0377    1215    CLRB	0x15,4
  0378    1283    CLRB	0x3,5
  0379    1206    CLRB	0x6,4
  037A    0008    RET
  03E3    3EC9    ADDIA	0xC9
  03E4    0084    LD	0x4,A
  03E5    0800    LD	A,0x0
  03E6    1283    CLRB	0x3,5
  03E7    00CD    LD	0x4D,A
  03E8    3007    LDIA	0x7
  03E9    01CE    CLR	0x4E
  03EA    00FF    LD	0x7F,A
  03EB    1003    CLRB	0x3,0
  03EC    0DCD    RLCR	0x4D
  03ED    0DCE    RLCR	0x4E
  03EE    0BFF    SZDECR	0x7F
  03EF    2BEB    JP	0x3EB
  03F0    084D    LD	A,0x4D
  03F1    1683    SETB	0x3,5
  03F2    04D9    ORR	0x59
  03F3    1283    CLRB	0x3,5
  03F4    084E    LD	A,0x4E
  03F5    1683    SETB	0x3,5
  03F6    04DA    ORR	0x5A
  03F7    0008    RET
  03F8    0800    LD	A,0x0
  03F9    00CD    LD	0x4D,A
  03FA    0A84    INCR	0x4
  03FB    0800    LD	A,0x0
  03FC    00CE    LD	0x4E,A
  03FD    09CD    COMR	0x4D
  03FE    09CE    COMR	0x4E
  03FF    084D    LD	A,0x4D
  0400    1683    SETB	0x3,5
  0401    05D9    ANDR	0x59
  0402    1283    CLRB	0x3,5
  0403    084E    LD	A,0x4E
  0404    1683    SETB	0x3,5
  0405    05DA    ANDR	0x5A
  0406    0008    RET
  0462    3EC9    ADDIA	0xC9
  0463    0084    LD	0x4,A
  0464    1383    CLRB	0x3,7
  0465    0800    LD	A,0x0
  0466    1683    SETB	0x3,5
  0467    00D9    LD	0x59,A
  0468    300A    LDIA	0xA
  0469    01DA    CLR	0x5A
  046A    00F5    LD	0x75,A
  046B    1283    CLRB	0x3,5
  046C    0846    LD	A,0x46
  046D    0008    RET
  046E    3EC9    ADDIA	0xC9
  046F    0084    LD	0x4,A
  0470    0800    LD	A,0x0
  0471    1283    CLRB	0x3,5
  0472    00CD    LD	0x4D,A
  0473    0008    RET
  04D1    00F5    LD	0x75,A
  04D2    3064    LDIA	0x64
  04D3    01F6    CLR	0x76
  04D4    00F7    LD	0x77,A
  04D5    01F8    CLR	0x78
  04D6    0008    RET
  05D7    084F    LD	A,0x4F
  05D8    3EA0    ADDIA	0xA0
  05D9    0084    LD	0x4,A
  05DA    1383    CLRB	0x3,7
  05DB    0A00    INCA	0x0
  05DC    2DDF    JP	0x5DF
  05DD    1003    CLRB	0x3,0
  05DE    0DF7    RLCR	0x77
  05DF    3EFF    ADDIA	0xFF
  05E0    1D03    SNZB	0x3,2
  05E1    2DDD    JP	0x5DD
  05E2    0877    LD	A,0x77
  05E3    0008    RET
  05E4    00F8    LD	0x78,A
  05E5    084F    LD	A,0x4F
  05E6    3E01    ADDIA	0x1
  05E7    0084    LD	0x4,A
  05E8    0008    RET
  05E9    3400    RET	0x0
  05EA    3401    RET	0x1
  05EB    3400    RET	0x0
  05EC    3401    RET	0x1
  05ED    3401    RET	0x1
  05EE    3400    RET	0x0
  05EF    3400    RET	0x0
  05F0    3402    RET	0x2
  05F1    3403    RET	0x3
  05F2    3402    RET	0x2
  05F3    3403    RET	0x3
  05F4    3403    RET	0x3
  05F5    3402    RET	0x2
  05F6    3402    RET	0x2
  05F7    3404    RET	0x4
  05F8    3404    RET	0x4
  05F9    3400    RET	0x0
  05FA    3400    RET	0x0
  05FB    3412    RET	0x12
  05FC    3400    RET	0x0
  05FD    345B    RET	0x5B
  05FE    3400    RET	0x0
  05FF    347F    RET	0x7F
  0600    3400    RET	0x0
  0601    347F    RET	0x7F
  0602    3409    RET	0x9
  0603    34FF    RET	0xFF
  0604    342D    RET	0x2D
  0605    34FF    RET	0xFF
  0606    343F    RET	0x3F
  0607    3400    RET	0x0
  0608    3440    RET	0x40
  0609    3470    RET	0x70
  060A    3478    RET	0x78
  060B    347E    RET	0x7E
  060C    347F    RET	0x7F
  060D    343F    RET	0x3F
  060E    340F    RET	0xF
  060F    3407    RET	0x7
  0610    3401    RET	0x1
  0611    3400    RET	0x0
  0612    3477    RET	0x77
  0613    3424    RET	0x24
  0614    345D    RET	0x5D
  0615    346D    RET	0x6D
  0616    342E    RET	0x2E
  0617    346B    RET	0x6B
  0618    347B    RET	0x7B
  0619    3425    RET	0x25
  061A    347F    RET	0x7F
  061B    342F    RET	0x2F
  06C3    3064    LDIA	0x64
  06C4    1283    CLRB	0x3,5
  06C5    1303    CLRB	0x3,6
  06C6    023D    SUBA	0x3D
  06C7    0008    RET
  0752    3401    RET	0x1
  0753    3402    RET	0x2
  0754    3402    RET	0x2
  0755    3403    RET	0x3
  0756    3400    RET	0x0
  0757    3403    RET	0x3
  0758    3404    RET	0x4
  0759    3400    RET	0x0
  075A    3401    RET	0x1
  075B    3401    RET	0x1
  075C    3402    RET	0x2
  075D    3400    RET	0x0
  075E    3403    RET	0x3
  075F    3404    RET	0x4
  0760    3400    RET	0x0
  0761    3401    RET	0x1
  0774    1683    SETB	0x3,5
  0775    01D9    CLR	0x59
  0776    00DA    LD	0x5A,A
  0777    0008    RET
  0778    087E    LD	A,0x7E
  0779    008A    LD	0xA,A
  077A    087F    LD	A,0x7F
  077B    0082    LD	0x2,A
  077C    2778    CALL	0x778
  077D    0080    LD	0x0,A
  077E    0A84    INCR	0x4
  077F    0804    LD	A,0x4
  0780    067D    XORA	0x7D
  0781    1903    SZB	0x3,2
  0782    3400    RET	0x0
  0783    0AFF    INCR	0x7F
  0784    1903    SZB	0x3,2
  0785    0AFE    INCR	0x7E
  0786    2F7C    JP	0x77C
  07B9    0064    CLRWDT
  07BA    0180    CLR	0x0
  07BB    0A84    INCR	0x4
  07BC    0604    XORA	0x4
  07BD    1903    SZB	0x3,2
  07BE    3400    RET	0x0
  07BF    0604    XORA	0x4
  07C0    2FBA    JP	0x7BA
  07C1    2AF1    JP	0x2F1
  07C2    2B03    JP	0x303
  07C3    2B15    JP	0x315
  07C4    2B27    JP	0x327
  07C5    2B38    JP	0x338
  07CA    28CB    JP	0xCB
  07CB    28D3    JP	0xD3
  07CC    28DD    JP	0xDD
