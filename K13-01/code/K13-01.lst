---- C:\Users\Administrator\Desktop\project\K13-01\code\main.c ----------------------------------------------------------------------
1:                #include "K13-01.h"
2:                
3:                void main()
4:                {
5:                    SystemInit();
  07D9    27C3    CALL	0x7C3
6:                    while (1)
7:                    {
8:                        Apply();
  07DA    268B    CALL	0x68B
  07DB    0064    CLRWDT
  07DC    2FDA    JP	0x7DA
9:                        asm("clrwdt");
10:                   }
11:               }
12:               
---- C:\Users\Administrator\Desktop\project\K13-01\code\K13-01.c ----------------------------------------------------------------------
1:                #include "K13-01.h"
2:                
3:                bit SystemONFlag=0;
4:                uint8 VarPowerUpCount=0;
5:                
6:                uint8 BatPercent=0;
7:                
8:                uint8 WorkMin=0;
9:                
10:               uint8 LockNumb=0;
11:               
12:               TYPE_UNION_LockSta LockSta;
13:               
14:               bit OnOffFlag=0;
15:               bit WorkFlag=0;
16:               bit IovFlag=0;
17:               bit LedIovFlag=0;
18:               bit LowBatFlag=0;
19:               bit USBFlag=0;  
20:               bit LEDWorkFlag=0;
21:               
22:               uint8 Sec1sCnt=0;
23:               uint8 BatAddTime=240;
24:               uint8 BatDecTime=210;
25:               
26:               void Apply()
27:               {
28:                   if(time2ms)
  068B    1D71    SNZB	0x71,2
  068C    2E91    JP	0x691
29:                   {
30:                       time2ms=0;
  068D    1171    CLRB	0x71,2
31:                       if(SystemONFlag)
  068E    1C72    SNZB	0x72,0
  068F    2E91    JP	0x691
32:                       {
33:                           KeyScan();
  0690    2030    CALL	0x30
34:                       }
35:                   }
36:                   if(time10ms)
  0691    1CF1    SNZB	0x71,1
  0692    0008    RET
37:                   {
38:                       time10ms=0;
  0693    10F1    CLRB	0x71,1
39:                       if(SystemONFlag==0&&VarPowerUpCount<100)
  0694    1872    SZB	0x72,0
  0695    2E9C    JP	0x69C
  0696    26AF    CALL	0x6AF
  0697    1803    SZB	0x3,0
  0698    2E9C    JP	0x69C
40:                       {
41:                           VarPowerUpCount++;
  0699    0ABC    INCR	0x3C
42:                           ADCPro();
  069A    24AB    CALL	0x4AB
43:                       }
  069B    2EA1    JP	0x6A1
44:                       else if(VarPowerUpCount>=100)
  069C    26AF    CALL	0x6AF
  069D    1C03    SNZB	0x3,0
  069E    2EA1    JP	0x6A1
45:                       {
46:                           SystemONFlag=1;
  069F    1472    SETB	0x72,0
47:                           VarPowerUpCount=0;
  06A0    01BC    CLR	0x3C
48:                       }
49:                       /*上电完成*/
50:                       if(SystemONFlag)
  06A1    1C72    SNZB	0x72,0
  06A2    2EA7    JP	0x6A7
51:                       {
52:                           ADCPro();
  06A3    24AB    CALL	0x4AB
53:                           Motor();
  06A4    23E5    CALL	0x3E5
54:                           DisplayPro(); 
  06A5    27B8    CALL	0x7B8
55:                           #ifndef DEBUGFlag
56:                           SystemSleep(); 
  06A6    2585    CALL	0x585
  06A7    3064    LDIA	0x64
57:                           #endif
58:                       }
59:                       Sec1sCnt++;
  06A8    1303    CLRB	0x3,6
  06A9    0ABA    INCR	0x3A
60:                       if(Sec1sCnt>=100)
  06AA    023A    SUBA	0x3A
  06AB    1C03    SNZB	0x3,0
  06AC    0008    RET
61:                       {
62:                           Sec1sCnt=0;
  06AD    01BA    CLR	0x3A
63:                           Sec1sPro();
  06AE    291C    JP	0x11C
64:                       }
65:                   }
66:               }
67:               
68:               void SystemSleep()
69:               {
70:                   static uint16 SleepCnt=0;
71:                   if(WorkFlag||OnOffFlag||USBFlag||KeyPress)
  0585    1E71    SNZB	0x71,4
  0586    1BF0    SZB	0x70,7
  0587    2D8C    JP	0x58C
  0588    19F1    SZB	0x71,3
  0589    2D8C    JP	0x58C
  058A    1C71    SNZB	0x71,0
  058B    2D8F    JP	0x58F
72:                   {
73:                       SleepCnt=0;
  058C    01AA    CLR	0x2A
  058D    01AB    CLR	0x2B
74:                   }
  058E    0008    RET
75:                   else
76:                   {
77:                       SleepCnt++;
  058F    0AAA    INCR	0x2A
  0590    1903    SZB	0x3,2
  0591    0AAB    INCR	0x2B
78:                       if(SleepCnt>=1000)
  0592    3003    LDIA	0x3
  0593    022B    SUBA	0x2B
  0594    30E8    LDIA	0xE8
  0595    1903    SZB	0x3,2
  0596    022A    SUBA	0x2A
  0597    1C03    SNZB	0x3,0
  0598    0008    RET
79:                       {
80:                           LEDWorkFlag=0;
  0599    1370    CLRB	0x70,6
81:                           SleepCnt=0;
  059A    01AA    CLR	0x2A
  059B    01AB    CLR	0x2B
  059C    0064    CLRWDT
82:                           asm("clrwdt");
83:                           INTCON=0;
  059D    018B    CLR	0xB
84:                           PIE1 = 0;
  059E    1683    SETB	0x3,5
  059F    1303    CLRB	0x3,6
  05A0    018C    CLR	0xC
85:                           PIE2 = 0;	
  05A1    018D    CLR	0xD
86:                           PIR1 = 0;
  05A2    1283    CLRB	0x3,5
  05A3    018C    CLR	0xC
87:                           ADCON0	= 0;
  05A4    019F    CLR	0x1F
88:               
89:                           TRISA =0X00;
  05A5    1683    SETB	0x3,5
90:               	        TRISB =0X00;
91:                           TRISC =0x00;
92:                           WPUA = 0xFF;
93:                           WPUB = 0xFF;
94:                           WPUC = 0xFF;
  05A6    26CF    CALL	0x6CF
95:                           PORTA =	0;			//初始端口配置为输出低；
  05A7    1283    CLRB	0x3,5
  05A8    1303    CLRB	0x3,6
  05A9    0185    CLR	0x5
96:                           PORTB = 0;
  05AA    0186    CLR	0x6
97:                           PORTC = 0;
  05AB    0187    CLR	0x7
98:                           PIN_BAT=H;
  05AC    1485    SETB	0x5,1
99:                           PIN_IOV=H;
  05AD    1505    SETB	0x5,2
100:                          PIN_GND=H;
  05AE    1405    SETB	0x5,0
101:                          PIN_EN =L;
  05AF    1285    CLRB	0x5,5
102:                          Pin_KEY_CFG(1,1);
  05B0    1683    SETB	0x3,5
  05B1    1706    SETB	0x6,6
  05B2    1715    SETB	0x15,6
103:                          Pin_USB_CFG(1,1);
  05B3    1786    SETB	0x6,7
  05B4    1795    SETB	0x15,7
104:              
105:                          WDT_OFF();
  05B5    1283    CLRB	0x3,5
  05B6    1703    SETB	0x3,6
  05B7    0185    CLR	0x5
106:                          RBIE=1;
  05B8    158B    SETB	0xB,3
107:                          IOCB=0xC0;
  05B9    30C0    LDIA	0xC0
  05BA    1683    SETB	0x3,5
  05BB    1303    CLRB	0x3,6
  05BC    0096    LD	0x16,A
108:                          OSCCON=0X01;
  05BD    3001    LDIA	0x1
  05BE    008F    LD	0xF,A
109:                          RBIF = 0;
  05BF    100B    CLRB	0xB,0
110:                          PORTB;
  05C0    1283    CLRB	0x3,5
  05C1    0806    LD	A,0x6
  05C2    0063    STOP
  05C3    0000    NOP
111:                          asm("sleep");
112:              		    asm("nop");
113:                          SystemInit();
  05C4    2FC3    JP	0x7C3
114:                      }
115:                  }
116:              }
117:              
118:              void SystemInit()
  07C3    0000    NOP
  07C4    0064    CLRWDT
119:              {
120:                  asm("nop");
121:              	asm("clrwdt");
122:                  GPIOInit();
  07C5    26B4    CALL	0x6B4
123:                  TimerInit();
  07C6    279C    CALL	0x79C
124:                  WDT_ON();
  07C7    3001    LDIA	0x1
  07C8    1283    CLRB	0x3,5
  07C9    1703    SETB	0x3,6
  07CA    0085    LD	0x5,A
  07CB    0008    RET
125:              }
126:              
127:              void GPIOInit()
128:              {
129:                  RBPU=0;
  06B4    1683    SETB	0x3,5
  06B5    1303    CLRB	0x3,6
  06B6    1381    CLRB	0x1,7
130:              	/*全配置成输出*/
131:              	TRISA =0X00;
132:              	TRISB =0X00;
133:              	TRISC =0X00;
134:              	//TRISE =0X00; 
135:              
136:                  /*全部设置上拉，输出会自动断开上拉*/
137:              	WPUA  =0XFF;
138:              	WPUB  =0XFF;
139:              	WPUC  =0XFF;
  06B7    26CF    CALL	0x6CF
140:              	//WPUE  =0XFF;
141:              
142:                  /*默认输出0*/
143:              	PORTA =	0X80;
  06B8    3080    LDIA	0x80
  06B9    1283    CLRB	0x3,5
  06BA    1303    CLRB	0x3,6
  06BB    0085    LD	0x5,A
144:              	PORTB = 0X80;
  06BC    0086    LD	0x6,A
145:              	PORTC = 0;
  06BD    0187    CLR	0x7
146:              	//PORTE = 0;
147:              
148:              	PIN_EN =true;
  06BE    1685    SETB	0x5,5
149:                  RBPU=0;
  06BF    1683    SETB	0x3,5
  06C0    1381    CLRB	0x1,7
150:                  Pin_KEY_CFG(IN,1);
  06C1    1706    SETB	0x6,6
  06C2    1715    SETB	0x15,6
151:                  Pin_USB_CFG(IN,1);
  06C3    1786    SETB	0x6,7
  06C4    1795    SETB	0x15,7
152:              	
153:              	Pin_BAT_CFG(1,0); ANS1=1; //AN1配置为模拟输入；
  06C5    1485    SETB	0x5,1
  06C6    1703    SETB	0x3,6
  06C7    108E    CLRB	0xE,1
  06C8    1488    SETB	0x8,1
154:              	Pin_IOV_CFG(1,0); ANS2=1; //AN2配置为模拟输入；
  06C9    1303    CLRB	0x3,6
  06CA    1505    SETB	0x5,2
  06CB    1703    SETB	0x3,6
  06CC    110E    CLRB	0xE,2
  06CD    1508    SETB	0x8,2
  06CE    0008    RET
155:                  //Pin_Vin_CFG(1,0); ANS9=1;//AN9配置为模拟输入；
156:              }
157:              
158:              void TimerInit()
159:              {
160:                  // OSCCON=0X71;		//晶振配置为8M,内部
161:              	// INTCON=0B11000000;	//使能全局中断，外设中断
162:              	// PIE1=0B00000001;	//TIMER1溢出中断
163:                  // TMR1IF = 0;
164:              	// TMR1IE = 1;	
165:                  // TMR1H=0xFC;
166:                  // TMR1L=0x18;         //设置定时器1计时1ms
167:                  // T1CON = 0X01; //预分配4倍,使能定时器1
168:              
169:              	OSCCON=0X61;		//晶振配置为4M,内部
  079C    3061    LDIA	0x61
  079D    1303    CLRB	0x3,6
  079E    008F    LD	0xF,A
170:              	INTCON=0B11000000;	//使能全局中断，外设中断
  079F    30C0    LDIA	0xC0
  07A0    008B    LD	0xB,A
171:              	PIE1=0B00000010;	//TIMER2匹配中断
  07A1    3002    LDIA	0x2
  07A2    008C    LD	0xC,A
172:              	T2CON=0B00000100;	//使能TIMER2
  07A3    3004    LDIA	0x4
  07A4    1283    CLRB	0x3,5
  07A5    0092    LD	0x12,A
173:              	PR2	= 200;			//TIMER时钟为Fosc/4; 200us进一次中断
  07A6    30C8    LDIA	0xC8
  07A7    1683    SETB	0x3,5
  07A8    0092    LD	0x12,A
  07A9    0008    RET
174:              }
---- C:\Users\Administrator\Desktop\project\K13-01\code\ADC.c ----------------------------------------------------------------------
1:                #include "ADC.h"
2:                
3:                uint8 ADCState=0;
4:                uint16 ADCVal[3]={0};//bg、current、Vbat
5:                uint32 ADsum=0;
6:                uint8 ADcnt=0;
7:                
8:                uint8 CurrentCnt=0;
9:                
10:               void ADCPro()
11:               {
12:                   switch (ADCState)
  04AB    2CBB    JP	0x4BB
13:                   {
14:                       case 0://内部参考电压采样
15:                       ADCRead(AD_BG,ADCVal);
  04AC    3045    LDIA	0x45
  04AD    00E0    LD	0x60,A
  04AE    300F    LDIA	0xF
  04AF    21ED    CALL	0x1ED
16:                       break;
  04B0    2CC3    JP	0x4C3
17:               
18:                       case 1://过流采样
19:                       ADCRead(AD_AN2,ADCVal+1);
  04B1    3047    LDIA	0x47
  04B2    00E0    LD	0x60,A
  04B3    3002    LDIA	0x2
  04B4    21ED    CALL	0x1ED
20:                       break;
  04B5    2CC3    JP	0x4C3
21:               
22:                       case 2://电池电压采样
23:                       ADCRead(AD_AN1,ADCVal+2);
  04B6    3049    LDIA	0x49
  04B7    00E0    LD	0x60,A
  04B8    3001    LDIA	0x1
  04B9    21ED    CALL	0x1ED
24:                       break;
  04BA    2CC3    JP	0x4C3
  04BB    22B5    CALL	0x2B5
  04BC    1803    SZB	0x3,0
  04BD    2CC3    JP	0x4C3
  04BE    3000    LDIA	0x0
  04BF    008A    LD	0xA,A
  04C0    3001    LDIA	0x1
  04C1    0704    ADDA	0x4
  04C2    0082    LD	0x2,A
25:                   }
26:                   if(SystemONFlag==0)
  04C3    1872    SZB	0x72,0
  04C4    2CDA    JP	0x4DA
27:                   {
28:                       if(ADCVal[2]<BAT_3V2) 
  04C5    3000    LDIA	0x0
  04C6    024A    SUBA	0x4A
  04C7    3086    LDIA	0x86
  04C8    1903    SZB	0x3,2
  04C9    0249    SUBA	0x49
  04CA    1803    SZB	0x3,0
  04CB    2CCE    JP	0x4CE
29:                       {
30:                           BatPercent=0; 
  04CC    01C4    CLR	0x44
31:                       }
  04CD    2CDA    JP	0x4DA
32:                       else if(ADCVal[2]>BAT_4V2)
  04CE    3000    LDIA	0x0
  04CF    024A    SUBA	0x4A
  04D0    30B0    LDIA	0xB0
  04D1    1903    SZB	0x3,2
  04D2    0249    SUBA	0x49
  04D3    1C03    SNZB	0x3,0
  04D4    2CD7    JP	0x4D7
33:                       {
34:                           BatPercent=99; 
  04D5    3063    LDIA	0x63
  04D6    2CD9    JP	0x4D9
35:                       }
36:                       else
37:                       {
38:                           BatPercent=ADCVal[2]-BAT_3V0;
  04D7    0849    LD	A,0x49
  04D8    3E83    ADDIA	0x83
  04D9    00C4    LD	0x44,A
39:                       }
40:                   }
41:                   if(ADCVal[2]<BAT_3V0)
  04DA    3000    LDIA	0x0
  04DB    024A    SUBA	0x4A
  04DC    307D    LDIA	0x7D
  04DD    1903    SZB	0x3,2
  04DE    0249    SUBA	0x49
  04DF    1803    SZB	0x3,0
  04E0    2CE3    JP	0x4E3
42:                   {
43:                       LowBatFlag=1;
  04E1    17F1    SETB	0x71,7
44:                   }
  04E2    2CE4    JP	0x4E4
45:                   else
46:                   {
47:                       LowBatFlag=0;
  04E3    13F1    CLRB	0x71,7
48:                   }
49:                   if(ADCVal[1]>VOLTAGE07V)
  04E4    3000    LDIA	0x0
  04E5    0248    SUBA	0x48
  04E6    301E    LDIA	0x1E
  04E7    1903    SZB	0x3,2
  04E8    0247    SUBA	0x47
  04E9    1C03    SNZB	0x3,0
  04EA    2CF7    JP	0x4F7
  04EB    30C8    LDIA	0xC8
50:                   {
51:                       CurrentCnt++;
  04EC    0AC0    INCR	0x40
52:                       if(CurrentCnt>=200)
  04ED    0240    SUBA	0x40
  04EE    1C03    SNZB	0x3,0
  04EF    0008    RET
53:                       {
54:                           CurrentCnt=200;
  04F0    30C8    LDIA	0xC8
  04F1    00C0    LD	0x40,A
55:                           IovFlag=1;
  04F2    1771    SETB	0x71,6
56:                           LedIovFlag=1;
  04F3    16F1    SETB	0x71,5
57:                           WorkFlag=0;
  04F4    1271    CLRB	0x71,4
58:                           WorkMin=0;
  04F5    01C3    CLR	0x43
  04F6    0008    RET
59:                       }
60:                   }
61:                   else
62:                   {
63:                       CurrentCnt=0;
  04F7    01C0    CLR	0x40
64:                       IovFlag=0;
  04F8    1371    CLRB	0x71,6
  04F9    0008    RET
65:                   }
66:               }
67:               
68:               void Sec1sPro()
69:               {
70:                   static uint8 ActualPercent=0;
71:                   uint8 PercentErr=0;
72:                   uint16 TempPercent=0;
  011C    01D1    CLR	0x51
  011D    01D2    CLR	0x52
73:               
74:                   /*充电数字增加时间*/
75:                   if(USBFlag)
  011E    1DF1    SNZB	0x71,3
  011F    297B    JP	0x17B
76:                   {
77:                       if(ADCVal[2]<BAT_3V3) 
  0120    3000    LDIA	0x0
  0121    024A    SUBA	0x4A
  0122    308A    LDIA	0x8A
  0123    1903    SZB	0x3,2
  0124    0249    SUBA	0x49
  0125    1803    SZB	0x3,0
  0126    2929    JP	0x129
78:                       {
79:                           TempPercent=0; 
  0127    01D1    CLR	0x51
  0128    2932    JP	0x132
80:                       }
81:                       else if(ADCVal[2]>BAT_4V2)
  0129    3000    LDIA	0x0
  012A    024A    SUBA	0x4A
  012B    30B0    LDIA	0xB0
  012C    1903    SZB	0x3,2
  012D    0249    SUBA	0x49
  012E    1C03    SNZB	0x3,0
  012F    2934    JP	0x134
82:                       {
83:                           TempPercent=99; 
  0130    3063    LDIA	0x63
  0131    00D1    LD	0x51,A
  0132    01D2    CLR	0x52
84:                       }
  0133    2950    JP	0x150
85:                       else
86:                       {
87:                           TempPercent=ADCVal[2]-BAT_3V3;
  0134    084A    LD	A,0x4A
  0135    00D2    LD	0x52,A
  0136    0849    LD	A,0x49
  0137    00D1    LD	0x51,A
  0138    3076    LDIA	0x76
  0139    21E7    CALL	0x1E7
88:                           TempPercent=TempPercent*4/3;
  013A    3003    LDIA	0x3
  013B    00F6    LD	0x76,A
  013C    01F7    CLR	0x77
  013D    0852    LD	A,0x52
  013E    00CF    LD	0x4F,A
  013F    0851    LD	A,0x51
  0140    00CE    LD	0x4E,A
  0141    1003    CLRB	0x3,0
  0142    0DCE    RLCR	0x4E
  0143    0DCF    RLCR	0x4F
  0144    1003    CLRB	0x3,0
  0145    0DCE    RLCR	0x4E
  0146    0DCF    RLCR	0x4F
  0147    084E    LD	A,0x4E
  0148    00F8    LD	0x78,A
  0149    084F    LD	A,0x4F
  014A    00F9    LD	0x79,A
  014B    2661    CALL	0x661
  014C    0877    LD	A,0x77
  014D    00D2    LD	0x52,A
  014E    0876    LD	A,0x76
  014F    00D1    LD	0x51,A
89:                       }
90:                       if(ActualPercent>TempPercent)
91:                       {
92:                           if(ActualPercent)
  0150    21DC    CALL	0x1DC
  0151    1803    SZB	0x3,0
  0152    2957    JP	0x157
  0153    1903    SZB	0x3,2
  0154    2966    JP	0x166
93:                           {
94:                               ActualPercent--;
  0155    03BF    DECR	0x3F
  0156    2966    JP	0x166
95:                           }
96:                       }
97:                       else if(ActualPercent<TempPercent)
  0157    00CE    LD	0x4E,A
  0158    01CF    CLR	0x4F
  0159    0852    LD	A,0x52
  015A    024F    SUBA	0x4F
  015B    1D03    SNZB	0x3,2
  015C    295F    JP	0x15F
  015D    0851    LD	A,0x51
  015E    024E    SUBA	0x4E
  015F    1803    SZB	0x3,0
  0160    2966    JP	0x166
98:                       {
99:                           if(ActualPercent<99)
  0161    3063    LDIA	0x63
  0162    023F    SUBA	0x3F
  0163    1803    SZB	0x3,0
  0164    2966    JP	0x166
100:                          {
101:                              ActualPercent++;
  0165    0ABF    INCR	0x3F
102:                          }
103:                      }
104:                      if(ActualPercent>BatPercent)
  0166    083F    LD	A,0x3F
  0167    0244    SUBA	0x44
  0168    1803    SZB	0x3,0
  0169    2979    JP	0x179
105:                      {
106:                          PercentErr=ActualPercent-BatPercent;
  016A    0844    LD	A,0x44
  016B    023F    SUBA	0x3F
  016C    00D0    LD	0x50,A
107:                          if(PercentErr<5)
  016D    3005    LDIA	0x5
  016E    0250    SUBA	0x50
  016F    1803    SZB	0x3,0
  0170    2977    JP	0x177
108:                          {
109:                              BatAddTime=90-15*PercentErr;
  0171    30F1    LDIA	0xF1
  0172    00F6    LD	0x76,A
  0173    0850    LD	A,0x50
  0174    27AA    CALL	0x7AA
  0175    3E5A    ADDIA	0x5A
  0176    297A    JP	0x17A
110:                          }
111:                          else
112:                          {
113:                              BatAddTime=15;
  0177    300F    LDIA	0xF
  0178    297A    JP	0x17A
114:                          }
115:                      }
116:                      else
117:                      {
118:                          BatAddTime=240;
  0179    30F0    LDIA	0xF0
  017A    00EB    LD	0x6B,A
119:                      }
120:                  }
121:              
122:                  /*工作数字减少时间*/
123:                  if(WorkFlag)
  017B    1E71    SNZB	0x71,4
  017C    29D9    JP	0x1D9
124:                  {
125:                      if(ADCVal[2]<BAT_3V2) 
  017D    3000    LDIA	0x0
  017E    024A    SUBA	0x4A
  017F    3086    LDIA	0x86
  0180    1903    SZB	0x3,2
  0181    0249    SUBA	0x49
  0182    1803    SZB	0x3,0
  0183    2986    JP	0x186
126:                      {
127:                          TempPercent=0; 
  0184    01D1    CLR	0x51
  0185    298F    JP	0x18F
128:                      }
129:                      else if(ADCVal[2]>BAT_4V0)
  0186    3000    LDIA	0x0
  0187    024A    SUBA	0x4A
  0188    30A8    LDIA	0xA8
  0189    1903    SZB	0x3,2
  018A    0249    SUBA	0x49
  018B    1C03    SNZB	0x3,0
  018C    2991    JP	0x191
130:                      {
131:                          TempPercent=99; 
  018D    3063    LDIA	0x63
  018E    00D1    LD	0x51,A
  018F    01D2    CLR	0x52
132:                      }
  0190    2997    JP	0x197
133:                      else
134:                      {
135:                          TempPercent=ADCVal[2]-BAT_3V2;
  0191    084A    LD	A,0x4A
  0192    00D2    LD	0x52,A
  0193    0849    LD	A,0x49
  0194    00D1    LD	0x51,A
  0195    307A    LDIA	0x7A
  0196    21E7    CALL	0x1E7
136:                      }
137:                      if(TempPercent>=33)
  0197    3000    LDIA	0x0
  0198    0252    SUBA	0x52
  0199    3021    LDIA	0x21
  019A    1903    SZB	0x3,2
  019B    0251    SUBA	0x51
  019C    1C03    SNZB	0x3,0
  019D    29AB    JP	0x1AB
138:                      {
139:                          TempPercent=33+(ADCVal[2]-BAT_3V6)*2; 
  019E    084A    LD	A,0x4A
  019F    00D2    LD	0x52,A
  01A0    0849    LD	A,0x49
  01A1    00D1    LD	0x51,A
  01A2    30F5    LDIA	0xF5
  01A3    1003    CLRB	0x3,0
  01A4    0DD1    RLCR	0x51
  01A5    0DD2    RLCR	0x52
  01A6    07D1    ADDR	0x51
  01A7    1803    SZB	0x3,0
  01A8    0AD2    INCR	0x52
  01A9    30FE    LDIA	0xFE
  01AA    07D2    ADDR	0x52
140:                      }
141:                      if(ActualPercent>TempPercent)
142:                      {
143:                          if(ActualPercent)
  01AB    21DC    CALL	0x1DC
  01AC    1803    SZB	0x3,0
  01AD    29B2    JP	0x1B2
  01AE    1903    SZB	0x3,2
  01AF    29C1    JP	0x1C1
144:                          {
145:                              ActualPercent--;
  01B0    03BF    DECR	0x3F
  01B1    29C1    JP	0x1C1
146:                          }
147:                      }
148:                      else if(ActualPercent<TempPercent)
  01B2    00CE    LD	0x4E,A
  01B3    01CF    CLR	0x4F
  01B4    0852    LD	A,0x52
  01B5    024F    SUBA	0x4F
  01B6    1D03    SNZB	0x3,2
  01B7    29BA    JP	0x1BA
  01B8    0851    LD	A,0x51
  01B9    024E    SUBA	0x4E
  01BA    1803    SZB	0x3,0
  01BB    29C1    JP	0x1C1
149:                      {
150:                          if(ActualPercent<99)
  01BC    3063    LDIA	0x63
  01BD    023F    SUBA	0x3F
  01BE    1803    SZB	0x3,0
  01BF    29C1    JP	0x1C1
151:                          {
152:                              ActualPercent++;
  01C0    0ABF    INCR	0x3F
153:                          }
154:                      }
155:                      if(ActualPercent<BatPercent)
  01C1    0844    LD	A,0x44
  01C2    023F    SUBA	0x3F
  01C3    1803    SZB	0x3,0
  01C4    29D9    JP	0x1D9
156:                      {
157:                          PercentErr=BatPercent-ActualPercent;
  01C5    083F    LD	A,0x3F
  01C6    0244    SUBA	0x44
  01C7    00D0    LD	0x50,A
158:                          if(PercentErr<5&&ActualPercent)
  01C8    3005    LDIA	0x5
  01C9    0250    SUBA	0x50
  01CA    1803    SZB	0x3,0
  01CB    29D6    JP	0x1D6
  01CC    083F    LD	A,0x3F
  01CD    1903    SZB	0x3,2
  01CE    29D6    JP	0x1D6
159:                          {
160:                              BatDecTime=75-15*PercentErr;
  01CF    30F1    LDIA	0xF1
  01D0    00F6    LD	0x76,A
  01D1    0850    LD	A,0x50
  01D2    27AA    CALL	0x7AA
  01D3    3E4B    ADDIA	0x4B
  01D4    00EA    LD	0x6A,A
161:                          }
  01D5    0008    RET
162:                          else
163:                          {
164:                              BatDecTime=8;
  01D6    3008    LDIA	0x8
  01D7    00EA    LD	0x6A,A
  01D8    0008    RET
165:                          }
166:                      }
167:                      else
168:                      {
169:                          BatDecTime=210;
  01D9    30D2    LDIA	0xD2
  01DA    00EA    LD	0x6A,A
  01DB    0008    RET
170:                      }
171:                  }
172:                  else
173:                  {
174:                      BatDecTime=210;
175:                  }
176:              }
177:              
178:              void ADCRead(uint8 ch,uint16 *Val)
  01ED    1683    SETB	0x3,5
  01EE    00CF    LD	0x4F,A
179:              {
180:              	uint16 ad_temp,AD_H,AD_L;
181:              
182:              	if(ADSample(ch))
  01EF    275E    CALL	0x75E
  01F0    3A00    XORIA	0x0
  01F1    1903    SZB	0x3,2
  01F2    0008    RET
183:              	{
184:                      AD_H=ADRESH;
  01F3    081E    LD	A,0x1E
  01F4    1683    SETB	0x3,5
  01F5    00D0    LD	0x50,A
  01F6    01D1    CLR	0x51
185:                      AD_L=ADRESL;
  01F7    081E    LD	A,0x1E
  01F8    00D2    LD	0x52,A
  01F9    01D3    CLR	0x53
186:              		ad_temp=(AD_H<<4)|(AD_L>>4);  //12位ad
  01FA    0851    LD	A,0x51
  01FB    1283    CLRB	0x3,5
  01FC    00E2    LD	0x62,A
  01FD    1683    SETB	0x3,5
  01FE    0850    LD	A,0x50
  01FF    1283    CLRB	0x3,5
  0200    00E1    LD	0x61,A
  0201    30F0    LDIA	0xF0
  0202    0EE1    SWAPR	0x61
  0203    0EE2    SWAPR	0x62
  0204    05E2    ANDR	0x62
  0205    0861    LD	A,0x61
  0206    390F    ANDIA	0xF
  0207    04E2    ORR	0x62
  0208    30F0    LDIA	0xF0
  0209    05E1    ANDR	0x61
  020A    0861    LD	A,0x61
  020B    1683    SETB	0x3,5
  020C    00D4    LD	0x54,A
  020D    1283    CLRB	0x3,5
  020E    0862    LD	A,0x62
  020F    1683    SETB	0x3,5
  0210    00D5    LD	0x55,A
  0211    0853    LD	A,0x53
  0212    1283    CLRB	0x3,5
  0213    00E2    LD	0x62,A
  0214    1683    SETB	0x3,5
  0215    0852    LD	A,0x52
  0216    1283    CLRB	0x3,5
  0217    00E1    LD	0x61,A
  0218    3004    LDIA	0x4
  0219    1003    CLRB	0x3,0
  021A    0CE2    RRCR	0x62
  021B    0CE1    RRCR	0x61
  021C    3EFF    ADDIA	0xFF
  021D    1D03    SNZB	0x3,2
  021E    2A19    JP	0x219
  021F    0861    LD	A,0x61
  0220    1683    SETB	0x3,5
  0221    04D4    ORR	0x54
  0222    1283    CLRB	0x3,5
  0223    0862    LD	A,0x62
  0224    1683    SETB	0x3,5
  0225    04D5    ORR	0x55
187:              		ADsum += ad_temp;
  0226    0854    LD	A,0x54
  0227    1283    CLRB	0x3,5
  0228    00E1    LD	0x61,A
  0229    1683    SETB	0x3,5
  022A    0855    LD	A,0x55
  022B    1283    CLRB	0x3,5
  022C    00E2    LD	0x62,A
  022D    01E3    CLR	0x63
  022E    01E4    CLR	0x64
  022F    0861    LD	A,0x61
  0230    07A0    ADDR	0x20
  0231    0862    LD	A,0x62
  0232    1103    CLRB	0x3,2
  0233    1803    SZB	0x3,0
  0234    3E01    ADDIA	0x1
  0235    1D03    SNZB	0x3,2
  0236    07A1    ADDR	0x21
  0237    0863    LD	A,0x63
  0238    1103    CLRB	0x3,2
  0239    1803    SZB	0x3,0
  023A    3E01    ADDIA	0x1
  023B    1D03    SNZB	0x3,2
  023C    07A2    ADDR	0x22
  023D    0864    LD	A,0x64
  023E    1103    CLRB	0x3,2
  023F    1803    SZB	0x3,0
  0240    3E01    ADDIA	0x1
  0241    1D03    SNZB	0x3,2
  0242    07A3    ADDR	0x23
  0243    300A    LDIA	0xA
188:              		ADcnt++;
  0244    0AC1    INCR	0x41
189:              		if(ADcnt >= 10)
  0245    0241    SUBA	0x41
  0246    1C03    SNZB	0x3,0
  0247    0008    RET
  0248    300A    LDIA	0xA
190:              		{
191:                          ADcnt = 0;	
  0249    01C1    CLR	0x41
192:              			ADsum /=10;
  024A    00D3    LD	0x53,A
  024B    01D4    CLR	0x54
  024C    01D5    CLR	0x55
  024D    01D6    CLR	0x56
  024E    0823    LD	A,0x23
  024F    00DA    LD	0x5A,A
  0250    0822    LD	A,0x22
  0251    00D9    LD	0x59,A
  0252    0821    LD	A,0x21
  0253    00D8    LD	0x58,A
  0254    0820    LD	A,0x20
  0255    00D7    LD	0x57,A
  0256    24FA    CALL	0x4FA
  0257    0856    LD	A,0x56
  0258    00A3    LD	0x23,A
  0259    0855    LD	A,0x55
  025A    00A2    LD	0x22,A
  025B    0854    LD	A,0x54
  025C    00A1    LD	0x21,A
  025D    0853    LD	A,0x53
  025E    00A0    LD	0x20,A
193:                          switch (ADCState)
  025F    2A8D    JP	0x28D
194:                          {
195:                              case 0:
196:                              *Val=ADsum;//内部参考电压
  0260    0860    LD	A,0x60
  0261    0084    LD	0x4,A
  0262    0820    LD	A,0x20
  0263    1383    CLRB	0x3,7
  0264    0080    LD	0x0,A
  0265    0A84    INCR	0x4
  0266    0821    LD	A,0x21
  0267    2A8B    JP	0x28B
197:                              break;
198:              
199:                              case 1:
200:                              *Val=ADsum*1000/(*(Val-1));//电流
  0268    0860    LD	A,0x60
  0269    3EFE    ADDIA	0xFE
  026A    229F    CALL	0x29F
  026B    3003    LDIA	0x3
  026C    01D2    CLR	0x52
  026D    01D1    CLR	0x51
  026E    00D0    LD	0x50,A
  026F    30E8    LDIA	0xE8
  0270    00CF    LD	0x4F,A
  0271    2A7A    JP	0x27A
201:                              break;
202:              
203:                              case 2:
204:                              *Val=ADsum*100/(*(Val-2));//电池电压
  0272    0860    LD	A,0x60
  0273    3EFC    ADDIA	0xFC
  0274    229F    CALL	0x29F
  0275    3064    LDIA	0x64
  0276    00CF    LD	0x4F,A
  0277    01D0    CLR	0x50
  0278    01D1    CLR	0x51
  0279    01D2    CLR	0x52
  027A    25FF    CALL	0x5FF
  027B    084E    LD	A,0x4E
  027C    00DA    LD	0x5A,A
  027D    084D    LD	A,0x4D
  027E    00D9    LD	0x59,A
  027F    084C    LD	A,0x4C
  0280    00D8    LD	0x58,A
  0281    084B    LD	A,0x4B
  0282    00D7    LD	0x57,A
  0283    24FA    CALL	0x4FA
  0284    0860    LD	A,0x60
  0285    0084    LD	0x4,A
  0286    0853    LD	A,0x53
  0287    1383    CLRB	0x3,7
  0288    0080    LD	0x0,A
  0289    0A84    INCR	0x4
  028A    0854    LD	A,0x54
  028B    0080    LD	0x0,A
205:                              break;
  028C    2A95    JP	0x295
  028D    22B5    CALL	0x2B5
  028E    1803    SZB	0x3,0
  028F    2A95    JP	0x295
  0290    3007    LDIA	0x7
  0291    008A    LD	0xA,A
  0292    30DD    LDIA	0xDD
  0293    0704    ADDA	0x4
  0294    0082    LD	0x2,A
  0295    3003    LDIA	0x3
206:                          }
207:              			ADsum = 0;
  0296    01A0    CLR	0x20
  0297    01A1    CLR	0x21
  0298    01A2    CLR	0x22
  0299    01A3    CLR	0x23
208:                          ADCState++;
  029A    0AC2    INCR	0x42
209:                          if(ADCState>=3)
  029B    0242    SUBA	0x42
  029C    1803    SZB	0x3,0
210:                          {
211:                              ADCState=0;
  029D    01C2    CLR	0x42
  029E    0008    RET
212:                          }
213:              		}
214:              	}
215:              }
216:              
217:              /************************************************************
218:              函数名称：ADSample()
219:              函数功能：AD采样函数
220:              入口参数：ADCH,AD通道
221:              出口参数：ADRESH,ADRESL
222:              备    注：采样成功返回1，超时返回0
223:              ************************************************************/
224:              uint8 ADSample(uint8 ch)
  075E    00F7    LD	0x77,A
225:              {
226:              	ADCON1 = 0x00;					//左对齐
  075F    019F    CLR	0x1F
227:              	ADCON0 = 0X41 | ( ch << 2);	//16分频
  0760    00F6    LD	0x76,A
  0761    3001    LDIA	0x1
  0762    1003    CLRB	0x3,0
  0763    0DF6    RLCR	0x76
  0764    3EFF    ADDIA	0xFF
  0765    1003    CLRB	0x3,0
  0766    1D03    SNZB	0x3,2
  0767    2F63    JP	0x763
  0768    0D76    RLCA	0x76
  0769    3841    ORIA	0x41
  076A    1283    CLRB	0x3,5
  076B    009F    LD	0x1F,A
  076C    0000    NOP
  076D    0000    NOP
228:              	asm("nop");
229:              	asm("nop");
230:              	GODONE = 1;						//开始转换
  076E    1283    CLRB	0x3,5
  076F    1303    CLRB	0x3,6
  0770    149F    SETB	0x1F,1
231:              	volatile unsigned char i = 0;
  0771    01F8    CLR	0x78
232:              	while(GODONE)
  0772    1C9F    SNZB	0x1F,1
  0773    3401    RET	0x1
233:              	{
234:              		if(0 == (--i))				//ad等待限时，防止拔插电后出现死循环
  0774    0BF8    SZDECR	0x78
  0775    2F72    JP	0x772
235:              			return 0;
  0776    3400    RET	0x0
236:              	}
237:              	return 1;
238:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  0661    01CC    CLR	0x4C
  0662    01CD    CLR	0x4D
  0663    0876    LD	A,0x76
  0664    0477    ORA	0x77
  0665    1903    SZB	0x3,2
  0666    2E86    JP	0x686
  0667    01CB    CLR	0x4B
  0668    0ACB    INCR	0x4B
  0669    1BF7    SZB	0x77,7
  066A    2E6F    JP	0x66F
  066B    1003    CLRB	0x3,0
  066C    0DF6    RLCR	0x76
  066D    0DF7    RLCR	0x77
  066E    2E68    JP	0x668
  066F    1003    CLRB	0x3,0
  0670    0DCC    RLCR	0x4C
  0671    0DCD    RLCR	0x4D
  0672    0877    LD	A,0x77
  0673    0279    SUBA	0x79
  0674    1D03    SNZB	0x3,2
  0675    2E78    JP	0x678
  0676    0876    LD	A,0x76
  0677    0278    SUBA	0x78
  0678    1C03    SNZB	0x3,0
  0679    2E82    JP	0x682
  067A    0876    LD	A,0x76
  067B    02F8    SUBR	0x78
  067C    0877    LD	A,0x77
  067D    1C03    SNZB	0x3,0
  067E    03F9    DECR	0x79
  067F    02F9    SUBR	0x79
  0680    144C    SETB	0x4C,0
  0681    1003    CLRB	0x3,0
  0682    0CF7    RRCR	0x77
  0683    0CF6    RRCR	0x76
  0684    0BCB    SZDECR	0x4B
  0685    2E6F    JP	0x66F
  0686    084D    LD	A,0x4D
  0687    00F7    LD	0x77,A
  0688    084C    LD	A,0x4C
  0689    00F6    LD	0x76,A
  068A    0008    RET
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\Motor.c ----------------------------------------------------------------------
1:                #include "Motor.h"
2:                
3:                uint16 WorkCnt=0;
4:                uint16 TimeDecCnt=0;
5:                uint16 TimeAddCnt=0;
6:                
7:                void Motor()
8:                {
9:                    if(!WorkFlag)
  03E5    1A71    SZB	0x71,4
  03E6    2BEE    JP	0x3EE
10:                   {
11:                       MotorOff();
  03E7    1185    CLRB	0x5,3
12:                       WorkCnt=0;
  03E8    01A4    CLR	0x24
  03E9    01A5    CLR	0x25
13:                       TimeDecCnt=0;
  03EA    1683    SETB	0x3,5
  03EB    01D8    CLR	0x58
  03EC    01D9    CLR	0x59
14:                   }
  03ED    2C1A    JP	0x41A
15:                   else if(WorkFlag&&!LockSta.LockFlag)
  03EE    1A71    SZB	0x71,4
  03EF    1B2C    SZB	0x2C,6
  03F0    2C1A    JP	0x41A
16:                   {
17:                       MotorOn();
  03F1    1585    SETB	0x5,3
18:                       TimeDecCnt++;
  03F2    1683    SETB	0x3,5
  03F3    0AD8    INCR	0x58
  03F4    1903    SZB	0x3,2
  03F5    0AD9    INCR	0x59
19:                       if(TimeDecCnt>=BatDecTime*100)
  03F6    1283    CLRB	0x3,5
  03F7    086A    LD	A,0x6A
  03F8    2442    CALL	0x442
  03F9    272C    CALL	0x72C
  03FA    0877    LD	A,0x77
  03FB    1683    SETB	0x3,5
  03FC    0259    SUBA	0x59
  03FD    1D03    SNZB	0x3,2
  03FE    2C01    JP	0x401
  03FF    0876    LD	A,0x76
  0400    0258    SUBA	0x58
  0401    1C03    SNZB	0x3,0
  0402    2C09    JP	0x409
20:                       {
21:                           TimeDecCnt=0;
  0403    01D8    CLR	0x58
  0404    01D9    CLR	0x59
22:                           if(BatPercent)
  0405    1283    CLRB	0x3,5
  0406    0844    LD	A,0x44
  0407    1D03    SNZB	0x3,2
23:                           {
24:                               BatPercent--;
  0408    03C4    DECR	0x44
25:                           }
26:                       }
27:                       WorkCnt++;
  0409    1283    CLRB	0x3,5
  040A    0AA4    INCR	0x24
  040B    1903    SZB	0x3,2
  040C    0AA5    INCR	0x25
28:                       if(WorkCnt>=6000)
  040D    3017    LDIA	0x17
  040E    0225    SUBA	0x25
  040F    3070    LDIA	0x70
  0410    1903    SZB	0x3,2
  0411    0224    SUBA	0x24
  0412    1C03    SNZB	0x3,0
  0413    2C1A    JP	0x41A
  0414    3063    LDIA	0x63
29:                       {
30:                           WorkCnt=0;
  0415    01A4    CLR	0x24
  0416    01A5    CLR	0x25
31:                           if(WorkMin<99)
  0417    0243    SUBA	0x43
  0418    1C03    SNZB	0x3,0
32:                           {
33:                               WorkMin++;
  0419    0AC3    INCR	0x43
34:                           }
35:                       }
36:                   }
37:                   if(USBFlag)
  041A    1DF1    SNZB	0x71,3
  041B    2C3E    JP	0x43E
38:                   {
39:                       TimeAddCnt++;
  041C    1683    SETB	0x3,5
  041D    0AD6    INCR	0x56
  041E    1903    SZB	0x3,2
  041F    0AD7    INCR	0x57
40:                       if(TimeAddCnt>BatAddTime*100)
  0420    1283    CLRB	0x3,5
  0421    086B    LD	A,0x6B
  0422    2442    CALL	0x442
  0423    272C    CALL	0x72C
  0424    1683    SETB	0x3,5
  0425    0857    LD	A,0x57
  0426    0277    SUBA	0x77
  0427    1D03    SNZB	0x3,2
  0428    2C2B    JP	0x42B
  0429    0856    LD	A,0x56
  042A    0276    SUBA	0x76
  042B    1803    SZB	0x3,0
  042C    2C34    JP	0x434
  042D    3063    LDIA	0x63
41:                       {
42:                           TimeAddCnt=0;
  042E    01D6    CLR	0x56
  042F    01D7    CLR	0x57
43:                           if(BatPercent<99)
  0430    1283    CLRB	0x3,5
  0431    0244    SUBA	0x44
  0432    1C03    SNZB	0x3,0
44:                           {
45:                               BatPercent++;
  0433    0AC4    INCR	0x44
46:                           }
47:                       }
48:                       if(BatPercent<=BAT_3V0)
  0434    307E    LDIA	0x7E
  0435    1283    CLRB	0x3,5
  0436    0244    SUBA	0x44
  0437    1803    SZB	0x3,0
  0438    2C3B    JP	0x43B
49:                       {
50:                           PIN_EN =false;
  0439    1285    CLRB	0x5,5
51:                       }
  043A    0008    RET
52:                       else
53:                       {
54:                           PIN_EN =true;
  043B    1283    CLRB	0x3,5
  043C    1685    SETB	0x5,5
  043D    0008    RET
55:                       }
56:                   }
57:                   else
58:                   {
59:                       TimeAddCnt=0;
  043E    1683    SETB	0x3,5
  043F    01D6    CLR	0x56
  0440    01D7    CLR	0x57
  0441    2C3B    JP	0x43B
60:                       PIN_EN =true;
61:                   }
62:               }
63:               
64:               
65:               
66:               
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul16.c ----------------------------------------------------------------------
1:                // 16 x 16 bit multiplication with 16 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned int
15:               __wmul(unsigned int multiplier, unsigned int multiplicand)
  072C    01CB    CLR	0x4B
  072D    01CC    CLR	0x4C
  072E    1C76    SNZB	0x76,0
  072F    2F36    JP	0x736
  0730    0878    LD	A,0x78
  0731    07CB    ADDR	0x4B
  0732    1803    SZB	0x3,0
  0733    0ACC    INCR	0x4C
  0734    0879    LD	A,0x79
  0735    07CC    ADDR	0x4C
  0736    1003    CLRB	0x3,0
  0737    0DF8    RLCR	0x78
  0738    0DF9    RLCR	0x79
  0739    1003    CLRB	0x3,0
  073A    0CF7    RRCR	0x77
  073B    0CF6    RRCR	0x76
  073C    0876    LD	A,0x76
  073D    0477    ORA	0x77
  073E    1D03    SNZB	0x3,2
  073F    2F2E    JP	0x72E
  0740    084C    LD	A,0x4C
  0741    00F7    LD	0x77,A
  0742    084B    LD	A,0x4B
  0743    00F6    LD	0x76,A
  0744    0008    RET
16:               {
17:                       unsigned int product;
18:               
19:               #if _Has_hardware_multiply || _Has_large_call_stack
20:               
21:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:               
24:               	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:               /*
26:               a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                      a  b
28:               *      c  d
29:               -----------
30:                    |   bd
31:                    |ad  0
32:                    |bc  0
33:               +  ac| 0  0 (we ignore this intermediate product
34:                            because it does not affect the low 16 bits of the result)
35:               ===========
36:                */
37:                       product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                       product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                       product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:               
41:               #else
42:               
43:               	product = 0;
44:               	do {
45:               		if(multiplier & 1)
46:               			product += multiplicand;
47:               		multiplicand <<= 1;
48:               		multiplier >>= 1;
49:               	} while(multiplier != 0);
50:               
51:               #endif
52:                       return product;
53:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\Key.c ----------------------------------------------------------------------
1:                #include "Key.h"
2:                
3:                bit KeyInBuf=0;
4:                bit KeyPress=0;
5:                uint16 KeyCnt=0;
6:                
7:                bit USBLink=0;
8:                
9:                void KeyScan()
10:               {
11:               	if(!PIN_KEY)
  0030    1283    CLRB	0x3,5
  0031    1303    CLRB	0x3,6
  0032    1B06    SZB	0x6,6
  0033    2836    JP	0x36
12:               	{
13:               		KeyPress=1;
  0034    1471    SETB	0x71,0
14:               	}
  0035    2837    JP	0x37
15:               	else
16:               	{
17:               		KeyPress=0;
  0036    1071    CLRB	0x71,0
18:               	}
19:               	/*按键判断*/
20:               	if(KeyPress&&KeyCnt<10&&KeyInBuf==KeyPress&&(!LowBatFlag||USBFlag)&&!LockSta.LockFlag)//非低电压、非锁定、充电
  0037    1C71    SNZB	0x71,0
  0038    2862    JP	0x62
  0039    3000    LDIA	0x0
  003A    0229    SUBA	0x29
  003B    300A    LDIA	0xA
  003C    1903    SZB	0x3,2
  003D    0228    SUBA	0x28
  003E    1803    SZB	0x3,0
  003F    2862    JP	0x62
  0040    1C71    SNZB	0x71,0
  0041    2844    JP	0x44
  0042    3001    LDIA	0x1
  0043    2845    JP	0x45
  0044    3000    LDIA	0x0
  0045    00F6    LD	0x76,A
  0046    1EF0    SNZB	0x70,5
  0047    284A    JP	0x4A
  0048    3001    LDIA	0x1
  0049    284B    JP	0x4B
  004A    3000    LDIA	0x0
  004B    0676    XORA	0x76
  004C    1D03    SNZB	0x3,2
  004D    2862    JP	0x62
  004E    1FF1    SNZB	0x71,7
  004F    2852    JP	0x52
  0050    1DF1    SNZB	0x71,3
  0051    2862    JP	0x62
  0052    1B2C    SZB	0x2C,6
  0053    2862    JP	0x62
21:               	{
22:               		KeyCnt++;
23:               		if(KeyCnt>=10)
  0054    2116    CALL	0x116
  0055    300A    LDIA	0xA
  0056    1903    SZB	0x3,2
  0057    0228    SUBA	0x28
  0058    1C03    SNZB	0x3,0
  0059    28FA    JP	0xFA
24:               		{
25:               			WorkFlag=~WorkFlag; 
  005A    3010    LDIA	0x10
  005B    06F1    XORR	0x71
26:               			if(WorkFlag)
  005C    1E71    SNZB	0x71,4
  005D    28FA    JP	0xFA
27:               			{
28:               				LEDWorkFlag=1;
  005E    1770    SETB	0x70,6
29:               				OnOffFlag=0;
  005F    13F0    CLRB	0x70,7
30:               				WorkMin=0;
  0060    01C3    CLR	0x43
  0061    28FA    JP	0xFA
31:               			}
32:               		}
33:               	}
34:               	else if(KeyPress&&(KeyCnt>=10||LockSta.LockFlag)&&KeyCnt<250&&KeyInBuf==KeyPress&&!USBFlag)
  0062    1C71    SNZB	0x71,0
  0063    289F    JP	0x9F
  0064    3000    LDIA	0x0
  0065    0229    SUBA	0x29
  0066    300A    LDIA	0xA
  0067    1903    SZB	0x3,2
  0068    0228    SUBA	0x28
  0069    1803    SZB	0x3,0
  006A    286D    JP	0x6D
  006B    1F2C    SNZB	0x2C,6
  006C    289F    JP	0x9F
  006D    3000    LDIA	0x0
  006E    0229    SUBA	0x29
  006F    30FA    LDIA	0xFA
  0070    1903    SZB	0x3,2
  0071    0228    SUBA	0x28
  0072    1803    SZB	0x3,0
  0073    289F    JP	0x9F
  0074    1C71    SNZB	0x71,0
  0075    2878    JP	0x78
  0076    3001    LDIA	0x1
  0077    2879    JP	0x79
  0078    3000    LDIA	0x0
  0079    00F6    LD	0x76,A
  007A    1EF0    SNZB	0x70,5
  007B    287E    JP	0x7E
  007C    3001    LDIA	0x1
  007D    287F    JP	0x7F
  007E    3000    LDIA	0x0
  007F    0676    XORA	0x76
  0080    1903    SZB	0x3,2
  0081    19F1    SZB	0x71,3
  0082    289F    JP	0x9F
35:               	{
36:               		KeyCnt++;
37:               		if(KeyCnt>=250||(LockSta.LockFlag&&KeyCnt>=10))
  0083    2116    CALL	0x116
  0084    30FA    LDIA	0xFA
  0085    1903    SZB	0x3,2
  0086    0228    SUBA	0x28
  0087    1803    SZB	0x3,0
  0088    2892    JP	0x92
  0089    1F2C    SNZB	0x2C,6
  008A    28FA    JP	0xFA
  008B    3000    LDIA	0x0
  008C    0229    SUBA	0x29
  008D    300A    LDIA	0xA
  008E    1903    SZB	0x3,2
  008F    0228    SUBA	0x28
  0090    1C03    SNZB	0x3,0
  0091    28FA    JP	0xFA
38:               		{
39:               			KeyCnt=250;
  0092    30FA    LDIA	0xFA
  0093    00A8    LD	0x28,A
  0094    3002    LDIA	0x2
  0095    01A9    CLR	0x29
40:               			LockNumb=2;
  0096    00BB    LD	0x3B,A
41:               			if(!LockSta.LockFlag)
  0097    1B2C    SZB	0x2C,6
  0098    289C    JP	0x9C
42:               			{
43:               				LockSta.LockStart=1;
  0099    142C    SETB	0x2C,0
44:               				LockSta.UnlockEnd=0;
  009A    12AC    CLRB	0x2C,5
45:               			}
  009B    2860    JP	0x60
46:               			else
47:               			{
48:               				LockSta.UnlockStart=1;
  009C    15AC    SETB	0x2C,3
49:               				LockSta.LockEnd=0;
  009D    112C    CLRB	0x2C,2
  009E    2860    JP	0x60
50:               			}
51:               			WorkMin=0;
52:               		}
53:               	}
54:               	else if(KeyPress&&KeyCnt>=250&&KeyInBuf==KeyPress&&!LockSta.LockEnd&&!LockSta.UnlockEnd)
  009F    1C71    SNZB	0x71,0
  00A0    28DD    JP	0xDD
  00A1    3000    LDIA	0x0
  00A2    0229    SUBA	0x29
  00A3    30FA    LDIA	0xFA
  00A4    1903    SZB	0x3,2
  00A5    0228    SUBA	0x28
  00A6    1C03    SNZB	0x3,0
  00A7    28DD    JP	0xDD
  00A8    1C71    SNZB	0x71,0
  00A9    28AC    JP	0xAC
  00AA    3001    LDIA	0x1
  00AB    28AD    JP	0xAD
  00AC    3000    LDIA	0x0
  00AD    00F6    LD	0x76,A
  00AE    1EF0    SNZB	0x70,5
  00AF    28B2    JP	0xB2
  00B0    3001    LDIA	0x1
  00B1    28B3    JP	0xB3
  00B2    3000    LDIA	0x0
  00B3    0676    XORA	0x76
  00B4    1903    SZB	0x3,2
  00B5    192C    SZB	0x2C,2
  00B6    28DD    JP	0xDD
  00B7    1AAC    SZB	0x2C,5
  00B8    28DD    JP	0xDD
55:               	{
56:               		KeyCnt++;
  00B9    0AA8    INCR	0x28
  00BA    1903    SZB	0x3,2
  00BB    0AA9    INCR	0x29
57:               		if(KeyCnt>=1750)
  00BC    3006    LDIA	0x6
  00BD    0229    SUBA	0x29
  00BE    30D6    LDIA	0xD6
  00BF    1903    SZB	0x3,2
  00C0    0228    SUBA	0x28
  00C1    1C03    SNZB	0x3,0
  00C2    28FA    JP	0xFA
58:               		{
59:               			KeyCnt=1750;
  00C3    30D6    LDIA	0xD6
  00C4    00A8    LD	0x28,A
  00C5    3006    LDIA	0x6
  00C6    00A9    LD	0x29,A
60:               			LockSta.LockFlag=!LockSta.LockFlag;
  00C7    1003    CLRB	0x3,0
  00C8    1F2C    SNZB	0x2C,6
  00C9    1403    SETB	0x3,0
  00CA    1283    CLRB	0x3,5
  00CB    1303    CLRB	0x3,6
  00CC    1C03    SNZB	0x3,0
  00CD    28D0    JP	0xD0
  00CE    172C    SETB	0x2C,6
  00CF    28D1    JP	0xD1
  00D0    132C    CLRB	0x2C,6
61:               			if(LockSta.LockFlag)
  00D1    1F2C    SNZB	0x2C,6
  00D2    28D8    JP	0xD8
62:               			{
63:               				LockSta.LockStart=0;
  00D3    102C    CLRB	0x2C,0
64:               				LockSta.LockEnd=1;
  00D4    152C    SETB	0x2C,2
65:               				WorkFlag=0;
  00D5    1271    CLRB	0x71,4
66:               				LEDWorkFlag=0;
  00D6    1370    CLRB	0x70,6
67:               			}
  00D7    28FA    JP	0xFA
68:               			else
69:               			{
70:               				LockSta.UnlockStart=0;
  00D8    11AC    CLRB	0x2C,3
71:               				LockSta.UnlockEnd=1;
  00D9    16AC    SETB	0x2C,5
72:               				WorkFlag=1;
  00DA    1671    SETB	0x71,4
73:               				LEDWorkFlag=1;
  00DB    1770    SETB	0x70,6
  00DC    28FA    JP	0xFA
74:               			}
75:               		}
76:               	}
77:               	else if(!KeyPress||KeyInBuf!=KeyPress)
  00DD    1C71    SNZB	0x71,0
  00DE    28ED    JP	0xED
  00DF    1C71    SNZB	0x71,0
  00E0    28E3    JP	0xE3
  00E1    3001    LDIA	0x1
  00E2    28E4    JP	0xE4
  00E3    3000    LDIA	0x0
  00E4    00F6    LD	0x76,A
  00E5    1EF0    SNZB	0x70,5
  00E6    28E9    JP	0xE9
  00E7    3001    LDIA	0x1
  00E8    28EA    JP	0xEA
  00E9    3000    LDIA	0x0
  00EA    0676    XORA	0x76
  00EB    1903    SZB	0x3,2
  00EC    28FA    JP	0xFA
78:               	{
79:               		KeyCnt=0;
  00ED    01A8    CLR	0x28
  00EE    01A9    CLR	0x29
80:               		LockSta.UnlockEnd=0;
  00EF    12AC    CLRB	0x2C,5
81:               		if(LockSta.LockEnd)
  00F0    1D2C    SNZB	0x2C,2
  00F1    28F4    JP	0xF4
82:               		{
83:               			LockSta.LockEnd=0;
  00F2    112C    CLRB	0x2C,2
84:               			LockSta.UnlockFail=1;
  00F3    162C    SETB	0x2C,4
85:               		}
86:               		if(LockSta.UnlockStart)
  00F4    1DAC    SNZB	0x2C,3
  00F5    28F8    JP	0xF8
87:               		{
88:               			LockSta.UnlockStart=0;
  00F6    11AC    CLRB	0x2C,3
89:               			LockSta.UnlockFail=1;
  00F7    162C    SETB	0x2C,4
90:               		}
91:               		if(LockSta.LockStart)
  00F8    182C    SZB	0x2C,0
92:               		{
93:               			LockSta.LockStart=0;
  00F9    102C    CLRB	0x2C,0
94:               		}
95:               	}
96:               	KeyInBuf=KeyPress;
  00FA    12F0    CLRB	0x70,5
  00FB    1871    SZB	0x71,0
  00FC    16F0    SETB	0x70,5
97:               
98:               	if(!WorkFlag&&!KeyPress&&WorkMin!=0&&!USBFlag)
  00FD    1E71    SNZB	0x71,4
  00FE    1871    SZB	0x71,0
  00FF    2907    JP	0x107
  0100    1283    CLRB	0x3,5
  0101    1303    CLRB	0x3,6
  0102    0843    LD	A,0x43
  0103    1D03    SNZB	0x3,2
  0104    19F1    SZB	0x71,3
  0105    2907    JP	0x107
99:               	{
100:              		OnOffFlag=1;
  0106    17F0    SETB	0x70,7
101:              	}
102:              
103:              	if(!PIN_USB)
  0107    1283    CLRB	0x3,5
  0108    1303    CLRB	0x3,6
  0109    1B86    SZB	0x6,7
  010A    290D    JP	0x10D
104:              	{
105:              		USBLink=1;
  010B    1670    SETB	0x70,4
106:              	}
  010C    290E    JP	0x10E
107:              	else
108:              	{
109:              		USBLink=0;
  010D    1270    CLRB	0x70,4
110:              	}
111:              	/*USB判断*/
112:              	if(USBLink)
  010E    1E70    SNZB	0x70,4
  010F    2913    JP	0x113
113:              	{
114:              		USBFlag=1;
  0110    15F1    SETB	0x71,3
115:              		LockSta.LockFlag=0;
  0111    132C    CLRB	0x2C,6
116:              	}
  0112    0008    RET
117:              	else if(!USBLink)
  0113    1E70    SNZB	0x70,4
118:              	{
119:              		USBFlag=0;
  0114    11F1    CLRB	0x71,3
  0115    0008    RET
120:              	}
121:              }
122:              
---- C:\Users\Administrator\Desktop\project\K13-01\code\LED.c ----------------------------------------------------------------------
1:                #include "LED.h"
2:                
3:                uint8 NumbArr[10]={0x77,0x24,0x5D,0X6D,0X2E,0X6B,0X7B,0X25,0X7F,0X2F};//数字
4:                //uint8 HideNumbArr[11]={0,0x40,0x70,0x78,0x7E,0x7F,0x3F,0X0F,0x07,0X01,0};//自下往上扫描
5:                uint8 HideNumbArr[7]={0,0x40,0x70,0x78,0x7E,0x7F,0x7F};//自下往上扫描
6:                uint16 OffHideNumbArr[7]={0,0x12,0x5B,0X7F,0x97F,0x2DFF,0x3FFF};
7:                // const uint8 LEDSeg1[16][2]=
8:                // {
9:                //     {1,0},{2,1},{2,0},{3,1},{0,1},{3,0},{4,0},//上到下，左到右排序,左数字
10:               //     {0,2},{1,3},{1,2},{2,3},{0,3},{3,2},{4,2},//上到下，左到右排序,右数字
11:               //     {0,4},{1,4}//感叹号、锁
12:               // };
13:               const uint8 LEDSeg1[16]={1,2,2,3,0,3,4,0,1,1,2,0,3,4,0,1};
14:               uint8 LEDSeg2[16]={0,1,0,1,1,0,0,2,3,2,3,3,2,2,4,4};
15:               uint16 LedIndex=0;
16:               uint8 LEDArrMap[5]={0xff,0xff,0xEf,0xff,0xff};
17:               
18:               void LEDScan()
19:               {
20:                   static uint8 LEDScanIndex=0;
21:               
22:                   Pin_LED1_CFG(IN,0);
  02BA    1683    SETB	0x3,5
  02BB    1686    SETB	0x6,5
  02BC    1295    CLRB	0x15,5
23:                   Pin_LED2_CFG(IN,0);
  02BD    1606    SETB	0x6,4
  02BE    1215    CLRB	0x15,4
24:                   Pin_LED3_CFG(IN,0);
  02BF    1586    SETB	0x6,3
  02C0    1195    CLRB	0x15,3
25:                   Pin_LED4_CFG(IN,0);
  02C1    1587    SETB	0x7,3
  02C2    1703    SETB	0x3,6
  02C3    118F    CLRB	0xF,3
26:                   Pin_LED5_CFG(IN,0);
  02C4    1303    CLRB	0x3,6
  02C5    1507    SETB	0x7,2
  02C6    1703    SETB	0x3,6
  02C7    110F    CLRB	0xF,2
  02C8    0000    NOP
  02C9    0000    NOP
27:                   asm("nop");	asm("nop");
28:               
29:                   switch(LEDScanIndex)
  02CA    2B20    JP	0x320
30:                   {
31:                       case 0:
32:                       if(LEDArrMap[0]&0x02) 
  02CB    1CE5    SNZB	0x65,1
  02CC    2ACE    JP	0x2CE
33:                       {
34:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  02CD    234F    CALL	0x34F
35:                       }
36:               		if(LEDArrMap[0]&0x04)  
  02CE    1D65    SNZB	0x65,2
  02CF    2AD1    JP	0x2D1
37:                       {
38:                           Pin_LED3_CFG(OUT,0);PIN_LED3=L ;
  02D0    2349    CALL	0x349
39:                       }
40:               		if(LEDArrMap[0]&0x08) 
  02D1    1DE5    SNZB	0x65,3
  02D2    2AD4    JP	0x2D4
41:                       {
42:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  02D3    233B    CALL	0x33B
43:                       }
44:               		if(LEDArrMap[0]&0x10) 
  02D4    1E65    SNZB	0x65,4
  02D5    2AD7    JP	0x2D7
45:                       {
46:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  02D6    2333    CALL	0x333
47:                       }
48:               		Pin_LED1_CFG(OUT,0);PIN_LED1=H ;
  02D7    1683    SETB	0x3,5
  02D8    1286    CLRB	0x6,5
  02D9    1295    CLRB	0x15,5
  02DA    1283    CLRB	0x3,5
  02DB    1686    SETB	0x6,5
49:                       break;
  02DC    2B2D    JP	0x32D
50:               
51:                       case 1:
52:                       if(LEDArrMap[1]&0x01)
  02DD    1C66    SNZB	0x66,0
  02DE    2AE0    JP	0x2E0
53:                       {
54:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  02DF    2343    CALL	0x343
55:                       } 
56:                       if(LEDArrMap[1]&0x04) 
  02E0    1D66    SNZB	0x66,2
  02E1    2AE3    JP	0x2E3
57:                       {
58:                           Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  02E2    2349    CALL	0x349
59:                       }
60:                       if(LEDArrMap[1]&0x08) 
  02E3    1DE6    SNZB	0x66,3
  02E4    2AE6    JP	0x2E6
61:                       {
62:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  02E5    233B    CALL	0x33B
63:                       }
64:                       if(LEDArrMap[1]&0x10)
  02E6    1E66    SNZB	0x66,4
  02E7    2AE9    JP	0x2E9
65:                       {
66:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  02E8    2333    CALL	0x333
67:                       } 
68:                       Pin_LED2_CFG(OUT,0); PIN_LED2=H ;
  02E9    1683    SETB	0x3,5
  02EA    1206    CLRB	0x6,4
  02EB    1215    CLRB	0x15,4
  02EC    1283    CLRB	0x3,5
  02ED    1606    SETB	0x6,4
69:                       break;
  02EE    2B2D    JP	0x32D
70:               
71:                       case 2:
72:                       if(LEDArrMap[2]&0x01) 
  02EF    1C67    SNZB	0x67,0
  02F0    2AF2    JP	0x2F2
73:                       {
74:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  02F1    2343    CALL	0x343
75:                       }
76:               		if(LEDArrMap[2]&0x02) 
  02F2    1CE7    SNZB	0x67,1
  02F3    2AF5    JP	0x2F5
77:                       {
78:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  02F4    234F    CALL	0x34F
79:                       }
80:               		if(LEDArrMap[2]&0x08) 
  02F5    1DE7    SNZB	0x67,3
  02F6    2AF8    JP	0x2F8
81:                       {
82:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  02F7    233B    CALL	0x33B
83:                       }
84:               		if(LEDArrMap[2]&0x10) 
  02F8    1E67    SNZB	0x67,4
  02F9    2AFB    JP	0x2FB
85:                       {
86:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  02FA    2333    CALL	0x333
87:                       }
88:               		Pin_LED3_CFG(OUT,0);PIN_LED3=H ;
  02FB    1683    SETB	0x3,5
  02FC    1186    CLRB	0x6,3
  02FD    1195    CLRB	0x15,3
  02FE    1283    CLRB	0x3,5
  02FF    1586    SETB	0x6,3
89:                       break;
  0300    2B2D    JP	0x32D
90:               
91:                       case 3:
92:                       if(LEDArrMap[3]&0x01)
  0301    1C68    SNZB	0x68,0
  0302    2B04    JP	0x304
93:                       {
94:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  0303    2343    CALL	0x343
95:                       }
96:               		if(LEDArrMap[3]&0x02)
  0304    1CE8    SNZB	0x68,1
  0305    2B07    JP	0x307
97:                       {
98:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  0306    234F    CALL	0x34F
99:                       }
100:              		if(LEDArrMap[3]&0x04)
  0307    1D68    SNZB	0x68,2
  0308    2B0A    JP	0x30A
101:                      {
102:                          Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  0309    2349    CALL	0x349
103:                      }
104:              		Pin_LED4_CFG(OUT,0);PIN_LED4=H ;
  030A    1683    SETB	0x3,5
  030B    1187    CLRB	0x7,3
  030C    1703    SETB	0x3,6
  030D    118F    CLRB	0xF,3
  030E    1283    CLRB	0x3,5
  030F    1303    CLRB	0x3,6
  0310    1587    SETB	0x7,3
105:                      break;
  0311    2B2D    JP	0x32D
106:              
107:                      case 4:
108:                      if(LEDArrMap[4]&0x01)
  0312    1C69    SNZB	0x69,0
  0313    2B15    JP	0x315
109:                      {
110:                          Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  0314    2343    CALL	0x343
111:                      }
112:              		if(LEDArrMap[4]&0x04)
  0315    1D69    SNZB	0x69,2
  0316    2B18    JP	0x318
113:                      {
114:                          Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  0317    2349    CALL	0x349
115:                      }
116:                      Pin_LED5_CFG(OUT,0);PIN_LED5=H ;
  0318    1683    SETB	0x3,5
  0319    1107    CLRB	0x7,2
  031A    1703    SETB	0x3,6
  031B    110F    CLRB	0xF,2
  031C    1283    CLRB	0x3,5
  031D    1303    CLRB	0x3,6
  031E    1507    SETB	0x7,2
117:                  }
  031F    2B2D    JP	0x32D
  0320    1283    CLRB	0x3,5
  0321    1303    CLRB	0x3,6
  0322    0839    LD	A,0x39
  0323    0084    LD	0x4,A
  0324    3005    LDIA	0x5
  0325    0204    SUBA	0x4
  0326    1803    SZB	0x3,0
  0327    2B2D    JP	0x32D
  0328    3007    LDIA	0x7
  0329    008A    LD	0xA,A
  032A    30D4    LDIA	0xD4
  032B    0704    ADDA	0x4
  032C    0082    LD	0x2,A
  032D    3005    LDIA	0x5
118:                  LEDScanIndex++;
  032E    0AB9    INCR	0x39
119:                  if(LEDScanIndex>=5)
  032F    0239    SUBA	0x39
  0330    1803    SZB	0x3,0
120:                  {
121:                      LEDScanIndex=0;
  0331    01B9    CLR	0x39
  0332    0008    RET
122:                  }
123:              }
124:              
125:              void DisplayIcon(uint16 index)
126:              {
127:                  uint8 i=0;
128:                  uint16 Mask=0x01;
  05C5    01CB    CLR	0x4B
  05C6    0ACB    INCR	0x4B
  05C7    01CC    CLR	0x4C
129:              
130:                  for(i=0;i<16;i++)
  05C8    01CD    CLR	0x4D
131:                  {
132:                      if(index&Mask)
  05C9    084B    LD	A,0x4B
  05CA    0576    ANDA	0x76
  05CB    00F8    LD	0x78,A
  05CC    084C    LD	A,0x4C
  05CD    0577    ANDA	0x77
  05CE    00F9    LD	0x79,A
  05CF    0478    ORA	0x78
133:                      {
134:                          LEDArrMap[LEDSeg1[i]]|=(1<<LEDSeg2[i]);
  05D0    3001    LDIA	0x1
  05D1    00F8    LD	0x78,A
  05D2    1903    SZB	0x3,2
  05D3    2DDC    JP	0x5DC
  05D4    25ED    CALL	0x5ED
  05D5    25FA    CALL	0x5FA
  05D6    2777    CALL	0x777
  05D7    3E65    ADDIA	0x65
  05D8    0084    LD	0x4,A
  05D9    0879    LD	A,0x79
  05DA    0480    ORR	0x0
135:                      }
  05DB    2DE4    JP	0x5E4
136:                      else
137:                      {
138:                          LEDArrMap[LEDSeg1[i]]&=~(1<<LEDSeg2[i]);
  05DC    25ED    CALL	0x5ED
  05DD    3AFF    XORIA	0xFF
  05DE    25FA    CALL	0x5FA
  05DF    2777    CALL	0x777
  05E0    3E65    ADDIA	0x65
  05E1    0084    LD	0x4,A
  05E2    0879    LD	A,0x79
  05E3    0580    ANDR	0x0
  05E4    3010    LDIA	0x10
139:                      }
140:                      
141:                      Mask<<=1;
  05E5    1003    CLRB	0x3,0
  05E6    0DCB    RLCR	0x4B
  05E7    0DCC    RLCR	0x4C
  05E8    0ACD    INCR	0x4D
  05E9    024D    SUBA	0x4D
  05EA    1803    SZB	0x3,0
  05EB    0008    RET
  05EC    2DC9    JP	0x5C9
142:                  }
143:              }
144:              
145:              void DisplayPro()
146:              {
147:                  LedIndex=0;
  07B8    01A6    CLR	0x26
  07B9    01A7    CLR	0x27
148:                  WorkLedPro();
  07BA    2355    CALL	0x355
149:                  USBLedPro();
  07BB    2448    CALL	0x448
150:                  LockPro();
  07BC    2542    CALL	0x542
151:                  ErrPro();
  07BD    2745    CALL	0x745
152:                  DisplayIcon(LedIndex);
  07BE    0827    LD	A,0x27
  07BF    00F7    LD	0x77,A
  07C0    0826    LD	A,0x26
  07C1    00F6    LD	0x76,A
  07C2    2DC5    JP	0x5C5
153:              }
154:              
155:              void USBLedPro()
156:              {
157:                  static uint8 index=0;
158:                  static uint8 cnt=0;
159:              
160:                  if(USBFlag&&!WorkFlag&&!OnOffFlag)//充电正常
  0448    19F1    SZB	0x71,3
  0449    1A71    SZB	0x71,4
  044A    2C99    JP	0x499
  044B    1BF0    SZB	0x70,7
  044C    2C99    JP	0x499
  044D    3028    LDIA	0x28
161:                  {
162:                      cnt++;
  044E    0AB7    INCR	0x37
163:                      if(cnt>=40)
  044F    0237    SUBA	0x37
  0450    1C03    SNZB	0x3,0
  0451    2C58    JP	0x458
  0452    3007    LDIA	0x7
164:                      {
165:                          cnt=0;
  0453    01B7    CLR	0x37
166:                          index++;
  0454    0AB8    INCR	0x38
167:                          if(index>=7)
  0455    0238    SUBA	0x38
  0456    1803    SZB	0x3,0
168:                          {
169:                              index=0;
  0457    01B8    CLR	0x38
170:                          }
171:                      }
172:                      if(BatPercent<99)
  0458    3063    LDIA	0x63
  0459    0244    SUBA	0x44
173:                      {
174:                          LedIndex|=(NumbArr[BatPercent/10]|(uint16)NumbArr[BatPercent%10]<<7);
  045A    300A    LDIA	0xA
  045B    1803    SZB	0x3,0
  045C    2C88    JP	0x488
  045D    00F6    LD	0x76,A
  045E    0844    LD	A,0x44
  045F    26DA    CALL	0x6DA
  0460    249C    CALL	0x49C
  0461    1003    CLRB	0x3,0
  0462    0DCB    RLCR	0x4B
  0463    0DCC    RLCR	0x4C
  0464    0BFF    SZDECR	0x7F
  0465    2C61    JP	0x461
  0466    300A    LDIA	0xA
  0467    00F6    LD	0x76,A
  0468    0844    LD	A,0x44
  0469    26F6    CALL	0x6F6
  046A    3EBE    ADDIA	0xBE
  046B    0084    LD	0x4,A
  046C    084B    LD	A,0x4B
  046D    1383    CLRB	0x3,7
  046E    24A5    CALL	0x4A5
  046F    04A6    ORR	0x26
  0470    084E    LD	A,0x4E
  0471    04A7    ORR	0x27
175:                          LedIndex&=(HideNumbArr[index]|(uint16)HideNumbArr[index]<<7);
  0472    0838    LD	A,0x38
  0473    3EC8    ADDIA	0xC8
  0474    0084    LD	0x4,A
  0475    0800    LD	A,0x0
  0476    00CB    LD	0x4B,A
  0477    3007    LDIA	0x7
  0478    01CC    CLR	0x4C
  0479    00FF    LD	0x7F,A
  047A    1003    CLRB	0x3,0
  047B    0DCB    RLCR	0x4B
  047C    0DCC    RLCR	0x4C
  047D    0BFF    SZDECR	0x7F
  047E    2C7A    JP	0x47A
  047F    0838    LD	A,0x38
  0480    3EC8    ADDIA	0xC8
  0481    0084    LD	0x4,A
  0482    084B    LD	A,0x4B
  0483    24A5    CALL	0x4A5
  0484    05A6    ANDR	0x26
  0485    084E    LD	A,0x4E
  0486    05A7    ANDR	0x27
176:                      }
  0487    0008    RET
177:                      else
178:                      {
179:                          index=0;
  0488    01B8    CLR	0x38
180:                          LedIndex|=NumbArr[BatPercent/10];
  0489    00F6    LD	0x76,A
  048A    0844    LD	A,0x44
  048B    26F6    CALL	0x6F6
181:                          LedIndex|=NumbArr[BatPercent%10]<<7;
  048C    23D0    CALL	0x3D0
  048D    26DA    CALL	0x6DA
  048E    249C    CALL	0x49C
  048F    1003    CLRB	0x3,0
  0490    0DCB    RLCR	0x4B
  0491    0DCC    RLCR	0x4C
  0492    0BFF    SZDECR	0x7F
  0493    2C8F    JP	0x48F
  0494    084B    LD	A,0x4B
  0495    04A6    ORR	0x26
  0496    084C    LD	A,0x4C
  0497    04A7    ORR	0x27
  0498    0008    RET
182:                      }
183:                  }
184:                  else
185:                  {
186:                      index=0;
  0499    01B8    CLR	0x38
187:                      cnt=0;
  049A    01B7    CLR	0x37
  049B    0008    RET
188:                  }
189:              }
190:              
191:              void WorkLedPro()
192:              {
193:                  static int8 LedSwitchCnt=0;
194:                  static bit LedSwitchFlag=0;
195:                  static int8 index=0;
196:                  static uint8 cnt=0;
197:                  static bit dir=0;
198:                  static uint8 delaycnt=0;
199:                  if(LEDWorkFlag&&!OnOffFlag&&!LockSta.LockFlag&&!LockSta.LockStart&&(!USBFlag||WorkFlag))
  0355    1B70    SZB	0x70,6
  0356    1BF0    SZB	0x70,7
  0357    2B7C    JP	0x37C
  0358    1F2C    SNZB	0x2C,6
  0359    182C    SZB	0x2C,0
  035A    2B7C    JP	0x37C
  035B    1DF1    SNZB	0x71,3
  035C    2B5F    JP	0x35F
  035D    1E71    SNZB	0x71,4
  035E    2B7C    JP	0x37C
200:                  {
201:                      if(BatPercent<=10&&WorkFlag)
  035F    300B    LDIA	0xB
  0360    0244    SUBA	0x44
  0361    1C03    SNZB	0x3,0
  0362    1E71    SNZB	0x71,4
  0363    2B6D    JP	0x36D
  0364    3050    LDIA	0x50
202:                      {
203:                          LedSwitchCnt++;
  0365    0AB6    INCR	0x36
204:                          if(LedSwitchCnt>=80)
  0366    0236    SUBA	0x36
  0367    1C03    SNZB	0x3,0
  0368    2B6F    JP	0x36F
  0369    3008    LDIA	0x8
205:                          {
206:                              LedSwitchCnt=0;
  036A    01B6    CLR	0x36
207:                              LedSwitchFlag=!LedSwitchFlag;
  036B    06F0    XORR	0x70
  036C    2B6F    JP	0x36F
208:                          }
209:                      }
210:                      else
211:                      {
212:                          LedSwitchCnt=0;
  036D    01B6    CLR	0x36
213:                          LedSwitchFlag=1;
  036E    15F0    SETB	0x70,3
214:                      }
215:                      if(LedSwitchFlag)
  036F    1DF0    SNZB	0x70,3
  0370    2B78    JP	0x378
216:                      {
217:                          LedIndex|=NumbArr[BatPercent/10];
  0371    300A    LDIA	0xA
  0372    00F6    LD	0x76,A
  0373    0844    LD	A,0x44
  0374    26F6    CALL	0x6F6
218:                          LedIndex|=(uint16)NumbArr[BatPercent%10]<<7;
  0375    23D0    CALL	0x3D0
  0376    26DA    CALL	0x6DA
  0377    23BE    CALL	0x3BE
219:                      }
220:                      cnt=0;
  0378    01B4    CLR	0x34
221:                      index=0;
  0379    01B5    CLR	0x35
222:                      dir=0;
  037A    1170    CLRB	0x70,2
223:                  }
  037B    0008    RET
224:                  else if(OnOffFlag)
  037C    1FF0    SNZB	0x70,7
  037D    0008    RET
  037E    301E    LDIA	0x1E
225:                  {
226:                      cnt++;
  037F    0AB4    INCR	0x34
227:                      if(cnt>=30)
  0380    0234    SUBA	0x34
  0381    1C03    SNZB	0x3,0
  0382    2B9A    JP	0x39A
  0383    3007    LDIA	0x7
228:                      {
229:                          cnt=0;
  0384    01B4    CLR	0x34
230:                          index++;
  0385    0AB5    INCR	0x35
231:                          if(index>=7)
  0386    0235    SUBA	0x35
  0387    1C03    SNZB	0x3,0
  0388    2B9A    JP	0x39A
232:                          {
233:                              if(dir)
  0389    1D70    SNZB	0x70,2
  038A    2B97    JP	0x397
234:                              {
235:                                  index=6;
  038B    3006    LDIA	0x6
  038C    00B5    LD	0x35,A
  038D    3007    LDIA	0x7
236:                                  delaycnt++;
  038E    0AB3    INCR	0x33
237:                                  if(delaycnt>=7)
  038F    0233    SUBA	0x33
  0390    1C03    SNZB	0x3,0
  0391    2B9A    JP	0x39A
238:                                  {
239:                                      index=0;
  0392    01B5    CLR	0x35
240:                                      delaycnt=0;
  0393    01B3    CLR	0x33
241:                                      OnOffFlag=0;
  0394    13F0    CLRB	0x70,7
242:                                      WorkMin=0;
  0395    01C3    CLR	0x43
  0396    2B7A    JP	0x37A
243:                                      dir=0;
244:                                      return;
245:                                  }
246:                              }
247:                              else
248:                              {
249:                                  dir=!dir;
  0397    3004    LDIA	0x4
  0398    06F0    XORR	0x70
250:                                  index=0;
  0399    01B5    CLR	0x35
251:                              }
252:                              
253:                          }
254:                      }
255:                      if(!dir)
  039A    1970    SZB	0x70,2
  039B    2BA8    JP	0x3A8
256:                      {
257:                          LedIndex|=NumbArr[BatPercent/10];
  039C    300A    LDIA	0xA
  039D    00F6    LD	0x76,A
  039E    0844    LD	A,0x44
  039F    26F6    CALL	0x6F6
258:                          LedIndex|=(uint16)NumbArr[BatPercent%10]<<7;
  03A0    23D0    CALL	0x3D0
  03A1    26DA    CALL	0x6DA
  03A2    23BE    CALL	0x3BE
259:                          LedIndex&=~OffHideNumbArr[index];
  03A3    1003    CLRB	0x3,0
  03A4    0D35    RLCA	0x35
  03A5    3EB0    ADDIA	0xB0
  03A6    0084    LD	0x4,A
260:                      }
  03A7    2BD9    JP	0x3D9
261:                      else
262:                      {
263:                          LedIndex|=NumbArr[WorkMin/10];
  03A8    300A    LDIA	0xA
  03A9    00F6    LD	0x76,A
  03AA    0843    LD	A,0x43
  03AB    26F6    CALL	0x6F6
  03AC    3EBE    ADDIA	0xBE
  03AD    0084    LD	0x4,A
  03AE    1383    CLRB	0x3,7
  03AF    0800    LD	A,0x0
  03B0    04A6    ORR	0x26
264:                          LedIndex|=(uint16)NumbArr[WorkMin%10]<<7;
  03B1    300A    LDIA	0xA
  03B2    00F6    LD	0x76,A
  03B3    0843    LD	A,0x43
  03B4    26DA    CALL	0x6DA
  03B5    23BE    CALL	0x3BE
265:                          LedIndex&=~OffHideNumbArr[6-index];
  03B6    30FE    LDIA	0xFE
  03B7    00F6    LD	0x76,A
  03B8    0835    LD	A,0x35
  03B9    27AA    CALL	0x7AA
  03BA    3EBC    ADDIA	0xBC
  03BB    0084    LD	0x4,A
  03BC    1383    CLRB	0x3,7
  03BD    2BD9    JP	0x3D9
266:                      }
267:                  }
268:              }
269:              
270:              void LockPro()
271:              {
272:                  static uint8 SwitchCnt=0,LockSwitchCnt=0;
273:                  static uint8 Ledcnt=0;
274:                  static bit LedSwitchFlag=0;
275:                  if(!USBFlag)
  0542    19F1    SZB	0x71,3
  0543    0008    RET
276:                  {
277:                      if(LockSta.LockStart||LockSta.UnlockStart)
  0544    182C    SZB	0x2C,0
  0545    2D48    JP	0x548
  0546    1DAC    SNZB	0x2C,3
  0547    2D69    JP	0x569
  0548    3064    LDIA	0x64
278:                      {
279:                          SwitchCnt++;
  0549    0AB2    INCR	0x32
280:                          if(SwitchCnt>=100)
  054A    0232    SUBA	0x32
  054B    1C03    SNZB	0x3,0
  054C    2D52    JP	0x552
281:                          {
282:                              SwitchCnt=0;
  054D    01B2    CLR	0x32
283:                              if(LockNumb>0)
  054E    083B    LD	A,0x3B
  054F    1903    SZB	0x3,2
  0550    2D52    JP	0x552
284:                              {
285:                                  LockNumb--;
  0551    03BB    DECR	0x3B
286:                              }
287:                          }
288:                          LedIndex|=NumbArr[0];
  0552    1683    SETB	0x3,5
  0553    083E    LD	A,0x3E
  0554    1283    CLRB	0x3,5
  0555    04A6    ORR	0x26
289:                          LedIndex|=(uint16)NumbArr[LockNumb+1]<<7;
  0556    083B    LD	A,0x3B
  0557    3EBF    ADDIA	0xBF
  0558    0084    LD	0x4,A
  0559    1383    CLRB	0x3,7
  055A    0800    LD	A,0x0
  055B    00F6    LD	0x76,A
  055C    3007    LDIA	0x7
  055D    01F7    CLR	0x77
  055E    00FF    LD	0x7F,A
  055F    1003    CLRB	0x3,0
  0560    0DF6    RLCR	0x76
  0561    0DF7    RLCR	0x77
  0562    0BFF    SZDECR	0x7F
  0563    2D5F    JP	0x55F
  0564    0876    LD	A,0x76
  0565    04A6    ORR	0x26
  0566    0877    LD	A,0x77
  0567    04A7    ORR	0x27
290:                      }
  0568    2D6A    JP	0x56A
291:                      else
292:                      {
293:                          SwitchCnt=0;
  0569    01B2    CLR	0x32
294:                      }
295:                      if(LockSta.LockEnd||LockSta.UnlockFail||LockSta.UnlockStart)
  056A    1D2C    SNZB	0x2C,2
  056B    1A2C    SZB	0x2C,4
  056C    2D6F    JP	0x56F
  056D    1DAC    SNZB	0x2C,3
  056E    2D82    JP	0x582
  056F    3023    LDIA	0x23
296:                      {
297:                          LockSwitchCnt++;
  0570    0AB1    INCR	0x31
298:                          if(LockSwitchCnt>=35)
  0571    0231    SUBA	0x31
  0572    1C03    SNZB	0x3,0
  0573    2D7F    JP	0x57F
  0574    3002    LDIA	0x2
299:                          {
300:                              LockSwitchCnt=0;
  0575    01B1    CLR	0x31
301:                              LedSwitchFlag=!LedSwitchFlag;
  0576    06F0    XORR	0x70
302:                              if(!LedSwitchFlag&&LockSta.UnlockFail)
  0577    1CF0    SNZB	0x70,1
  0578    1E2C    SNZB	0x2C,4
  0579    2D7F    JP	0x57F
  057A    3003    LDIA	0x3
303:                              {
304:                                  Ledcnt++;
  057B    0AB0    INCR	0x30
305:                                  if(Ledcnt>=3)
  057C    0230    SUBA	0x30
  057D    1803    SZB	0x3,0
306:                                  {
307:                                      LockSta.UnlockFail=0;
  057E    122C    CLRB	0x2C,4
308:                                  }
309:                              }
310:                          }
311:                          if(LedSwitchFlag)
  057F    18F0    SZB	0x70,1
312:                          {
313:                              LedIndex|=iconLock;
  0580    17A7    SETB	0x27,7
  0581    0008    RET
314:                          }
315:                      }
316:                      else
317:                      {
318:                          Ledcnt=0;
  0582    01B0    CLR	0x30
319:                          LockSwitchCnt=0;
  0583    01B1    CLR	0x31
  0584    0008    RET
320:                      }
321:                  }
322:              }
323:              
324:              void ErrPro()
325:              {
326:                  static uint8 cnt=0;
327:                  static uint8 SwitchCnt=0;
328:                  static bit LedSwitchFlag=0;
329:                  if(LedIovFlag)
  0745    1EF1    SNZB	0x71,5
  0746    2F5C    JP	0x75C
  0747    3023    LDIA	0x23
330:                  {
331:                      SwitchCnt++;
  0748    0AAE    INCR	0x2E
332:                      if(SwitchCnt>=35)
  0749    022E    SUBA	0x2E
  074A    1C03    SNZB	0x3,0
  074B    2F59    JP	0x759
  074C    3001    LDIA	0x1
333:                      {
334:                          SwitchCnt=0;
  074D    01AE    CLR	0x2E
335:                          LedSwitchFlag=!LedSwitchFlag;
  074E    06F0    XORR	0x70
336:                          if(!IovFlag&&!LedSwitchFlag)
  074F    1F71    SNZB	0x71,6
  0750    1870    SZB	0x70,0
  0751    2F59    JP	0x759
  0752    3003    LDIA	0x3
337:                          {
338:                              cnt++;
  0753    0AAF    INCR	0x2F
339:                              if(cnt>=3)
  0754    022F    SUBA	0x2F
  0755    1C03    SNZB	0x3,0
  0756    2F59    JP	0x759
340:                              {
341:                                  cnt=0;
  0757    01AF    CLR	0x2F
342:                                  LedIovFlag=0;
  0758    12F1    CLRB	0x71,5
343:                              }
344:                          }
345:                      }
346:                      if(LedSwitchFlag)
  0759    1870    SZB	0x70,0
347:                      {
348:                          LedIndex|=iconErr;
  075A    1727    SETB	0x27,6
  075B    0008    RET
349:                      }
350:                  }
351:                  else
352:                  {
353:                      SwitchCnt=0;
  075C    01AE    CLR	0x2E
  075D    0008    RET
354:                  }
355:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul8.c ----------------------------------------------------------------------
1:                // 8 x 8 bit multiplication with 8 bit result
2:                
3:                unsigned char
4:                __bmul(unsigned char multiplier, unsigned char multiplicand)
  07AA    00F8    LD	0x78,A
  07AB    01F7    CLR	0x77
  07AC    0876    LD	A,0x76
  07AD    1878    SZB	0x78,0
  07AE    07F7    ADDR	0x77
  07AF    1003    CLRB	0x3,0
  07B0    0DF6    RLCR	0x76
  07B1    1003    CLRB	0x3,0
  07B2    0CF8    RRCR	0x78
  07B3    0878    LD	A,0x78
  07B4    1D03    SNZB	0x3,2
  07B5    2FAC    JP	0x7AC
  07B6    0877    LD	A,0x77
  07B7    0008    RET
5:                {
6:                	unsigned char product = 0;
7:                
8:                #if defined(__OPTIMIZE_SPEED__)
9:                
10:               	if(multiplier & 0x01)
11:               		product = (product + multiplicand) & 0xff;
12:               	multiplicand <<= 1;
13:               
14:               	if(multiplier & 0x02)
15:               		product = (product + multiplicand) & 0xff;
16:               	multiplicand <<= 1;
17:               
18:               	if(multiplier & 0x04)
19:               		product = (product + multiplicand) & 0xff;
20:               	multiplicand <<= 1;
21:               
22:               	if(multiplier & 0x08)
23:               		product = (product + multiplicand) & 0xff;
24:               	multiplicand <<= 1;
25:               
26:               	if(multiplier & 0x10)
27:               		product = (product + multiplicand) & 0xff;
28:               	multiplicand <<= 1;
29:               
30:               	if(multiplier & 0x20)
31:               		product = (product + multiplicand) & 0xff;
32:               	multiplicand <<= 1;
33:               
34:               	if(multiplier & 0x40)
35:               		product = (product + multiplicand) & 0xff;
36:               	multiplicand <<= 1;
37:               
38:               	if(multiplier & 0x80)
39:               		product = (product + multiplicand) & 0xff;
40:               
41:               #else
42:               	do {
43:               		if(multiplier & 1)
44:               			product += multiplicand;
45:               		multiplicand <<= 1;
46:               		multiplier >>= 1;
47:               	} while(multiplier != 0);
48:               
49:               #endif
50:               	return product;
51:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  06DA    00F8    LD	0x78,A
  06DB    3008    LDIA	0x8
  06DC    00F9    LD	0x79,A
  06DD    01FA    CLR	0x7A
  06DE    0878    LD	A,0x78
  06DF    00F7    LD	0x77,A
  06E0    3007    LDIA	0x7
  06E1    1003    CLRB	0x3,0
  06E2    0CF7    RRCR	0x77
  06E3    3EFF    ADDIA	0xFF
  06E4    1003    CLRB	0x3,0
  06E5    1D03    SNZB	0x3,2
  06E6    2EE2    JP	0x6E2
  06E7    0D7A    RLCA	0x7A
  06E8    0477    ORA	0x77
  06E9    00FA    LD	0x7A,A
  06EA    1003    CLRB	0x3,0
  06EB    0DF8    RLCR	0x78
  06EC    0876    LD	A,0x76
  06ED    027A    SUBA	0x7A
  06EE    1C03    SNZB	0x3,0
  06EF    2EF2    JP	0x6F2
  06F0    0876    LD	A,0x76
  06F1    02FA    SUBR	0x7A
  06F2    0BF9    SZDECR	0x79
  06F3    2EDE    JP	0x6DE
  06F4    087A    LD	A,0x7A
  06F5    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  06F6    00F7    LD	0x77,A
  06F7    01F9    CLR	0x79
  06F8    0876    LD	A,0x76
  06F9    1903    SZB	0x3,2
  06FA    2F0F    JP	0x70F
  06FB    01F8    CLR	0x78
  06FC    0AF8    INCR	0x78
  06FD    1BF6    SZB	0x76,7
  06FE    2F02    JP	0x702
  06FF    1003    CLRB	0x3,0
  0700    0DF6    RLCR	0x76
  0701    2EFC    JP	0x6FC
  0702    1003    CLRB	0x3,0
  0703    0DF9    RLCR	0x79
  0704    0876    LD	A,0x76
  0705    0277    SUBA	0x77
  0706    1C03    SNZB	0x3,0
  0707    2F0C    JP	0x70C
  0708    0876    LD	A,0x76
  0709    02F7    SUBR	0x77
  070A    1479    SETB	0x79,0
  070B    1003    CLRB	0x3,0
  070C    0CF6    RRCR	0x76
  070D    0BF8    SZDECR	0x78
  070E    2F02    JP	0x702
  070F    0879    LD	A,0x79
  0710    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul32.c ----------------------------------------------------------------------
1:                // 32 x 32 bit multiplication with 32 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned long
15:               __lmul(unsigned long multiplier, unsigned long multiplicand)
  05FF    01F6    CLR	0x76
  0600    01F7    CLR	0x77
  0601    01F8    CLR	0x78
  0602    01F9    CLR	0x79
  0603    1C4B    SNZB	0x4B,0
  0604    2E19    JP	0x619
  0605    084F    LD	A,0x4F
  0606    07F6    ADDR	0x76
  0607    0850    LD	A,0x50
  0608    1103    CLRB	0x3,2
  0609    1803    SZB	0x3,0
  060A    3E01    ADDIA	0x1
  060B    1D03    SNZB	0x3,2
  060C    07F7    ADDR	0x77
  060D    0851    LD	A,0x51
  060E    1103    CLRB	0x3,2
  060F    1803    SZB	0x3,0
  0610    3E01    ADDIA	0x1
  0611    1D03    SNZB	0x3,2
  0612    07F8    ADDR	0x78
  0613    0852    LD	A,0x52
  0614    1103    CLRB	0x3,2
  0615    1803    SZB	0x3,0
  0616    3E01    ADDIA	0x1
  0617    1D03    SNZB	0x3,2
  0618    07F9    ADDR	0x79
  0619    1003    CLRB	0x3,0
  061A    0DCF    RLCR	0x4F
  061B    0DD0    RLCR	0x50
  061C    0DD1    RLCR	0x51
  061D    0DD2    RLCR	0x52
  061E    1003    CLRB	0x3,0
  061F    0CCE    RRCR	0x4E
  0620    0CCD    RRCR	0x4D
  0621    0CCC    RRCR	0x4C
  0622    0CCB    RRCR	0x4B
  0623    084E    LD	A,0x4E
  0624    044D    ORA	0x4D
  0625    044C    ORA	0x4C
  0626    044B    ORA	0x4B
  0627    1D03    SNZB	0x3,2
  0628    2E03    JP	0x603
  0629    0879    LD	A,0x79
  062A    00CE    LD	0x4E,A
  062B    0878    LD	A,0x78
  062C    00CD    LD	0x4D,A
  062D    0877    LD	A,0x77
  062E    00CC    LD	0x4C,A
  062F    0876    LD	A,0x76
  0630    00CB    LD	0x4B,A
  0631    0008    RET
16:               {
17:               	unsigned long product;
18:               
19:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:               #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:               #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:               
24:               #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:               	{
26:               
27:               #define USE_SHRINK
28:               
29:               /*
30:               a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                            a  b  c  d
32:               *            e  f  g  h
33:               -----------------------
34:                          |         dh
35:                          |      ch  0
36:                          |   bh  0  0
37:                          |ah  0  0  0
38:                          |      dg  0
39:                          |   cg  0  0
40:                          |bg  0  0  0
41:                        ag| 0  0  0  0 (we ignore this intermediate product
42:                                        because it does not affect the low 32 bits of the result)
43:                          |   df  0  0
44:                          |cf  0  0  0
45:                        bf| 0  0  0  0 (ignore)
46:                     af  0| 0  0  0  0 (ignore)
47:                          |de  0  0  0
48:                        ce| 0  0  0  0 (ignore)
49:                     be  0| 0  0  0  0 (ignore)
50:               +  ae  0  0| 0  0  0  0 (ignore)
51:               =======================
52:                */
53:               		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:               
55:               #if defined(USE_MASKS)
56:               		product += ((unsigned long)
57:               			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:               			     +
59:               			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:               			<< 8;
61:               
62:               		product += ((unsigned long)
63:               			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:               			    +
65:               			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:               			    +
67:               			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:               			<< 16;
69:               
70:               		/* cast to smaller type to avoid adding high bits just to discard */
71:               		product += ((unsigned long)
72:               			    (unsigned char)
73:               			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:               			    +
75:               			    (unsigned char)
76:               			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:               			    +
78:               			    (unsigned char)
79:               			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:               			    +
81:               			    (unsigned char)
82:               			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:               			<< 24;
84:               
85:               #elif defined(USE_SHRINK)
86:               		/* add direct to upper bytes, rather than shift and add all bytes */
87:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:               			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:               			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:               
92:               
93:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:               			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:               			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:               			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:               
100:              		*(((unsigned char*)&product)+3) +=
101:              			(unsigned char)
102:              			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:              		*(((unsigned char*)&product)+3) +=
104:              			(unsigned char)
105:              			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:              		*(((unsigned char*)&product)+3) +=
107:              			(unsigned char)
108:              			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:              		*(((unsigned char*)&product)+3) +=
110:              			(unsigned char)
111:              			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:              
113:              #else
114:              #error No method chosen
115:              #endif
116:              	}
117:              #else
118:              
119:              	product = 0;
120:              	do {
121:              		if(multiplier & 1)
122:              			product += multiplicand;
123:              		multiplicand <<= 1;
124:              		multiplier >>= 1;
125:              	} while(multiplier != 0);
126:              
127:              #endif
128:              	return product;
129:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lldiv.c ----------------------------------------------------------------------
1:                // long unsigned unsigned division
2:                
3:                unsigned long int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lldiv(unsigned long int divisor, unsigned long int dividend)
  04FA    01DB    CLR	0x5B
  04FB    01DC    CLR	0x5C
  04FC    01DD    CLR	0x5D
  04FD    01DE    CLR	0x5E
  04FE    0856    LD	A,0x56
  04FF    0455    ORA	0x55
  0500    0454    ORA	0x54
  0501    0453    ORA	0x53
  0502    1903    SZB	0x3,2
  0503    2D39    JP	0x539
  0504    01DF    CLR	0x5F
  0505    0ADF    INCR	0x5F
  0506    1BD6    SZB	0x56,7
  0507    2D0E    JP	0x50E
  0508    1003    CLRB	0x3,0
  0509    0DD3    RLCR	0x53
  050A    0DD4    RLCR	0x54
  050B    0DD5    RLCR	0x55
  050C    0DD6    RLCR	0x56
  050D    2D05    JP	0x505
  050E    1003    CLRB	0x3,0
  050F    0DDB    RLCR	0x5B
  0510    0DDC    RLCR	0x5C
  0511    0DDD    RLCR	0x5D
  0512    0DDE    RLCR	0x5E
  0513    0856    LD	A,0x56
  0514    025A    SUBA	0x5A
  0515    1D03    SNZB	0x3,2
  0516    2D21    JP	0x521
  0517    0855    LD	A,0x55
  0518    0259    SUBA	0x59
  0519    1D03    SNZB	0x3,2
  051A    2D21    JP	0x521
  051B    0854    LD	A,0x54
  051C    0258    SUBA	0x58
  051D    1D03    SNZB	0x3,2
  051E    2D21    JP	0x521
  051F    0853    LD	A,0x53
  0520    0257    SUBA	0x57
  0521    1C03    SNZB	0x3,0
  0522    2D33    JP	0x533
  0523    0853    LD	A,0x53
  0524    02D7    SUBR	0x57
  0525    0854    LD	A,0x54
  0526    1C03    SNZB	0x3,0
  0527    0F54    SZINCA	0x54
  0528    02D8    SUBR	0x58
  0529    0855    LD	A,0x55
  052A    1C03    SNZB	0x3,0
  052B    0F55    SZINCA	0x55
  052C    02D9    SUBR	0x59
  052D    0856    LD	A,0x56
  052E    1C03    SNZB	0x3,0
  052F    0F56    SZINCA	0x56
  0530    02DA    SUBR	0x5A
  0531    145B    SETB	0x5B,0
  0532    1003    CLRB	0x3,0
  0533    0CD6    RRCR	0x56
  0534    0CD5    RRCR	0x55
  0535    0CD4    RRCR	0x54
  0536    0CD3    RRCR	0x53
  0537    0BDF    SZDECR	0x5F
  0538    2D0E    JP	0x50E
  0539    085E    LD	A,0x5E
  053A    00D6    LD	0x56,A
  053B    085D    LD	A,0x5D
  053C    00D5    LD	0x55,A
  053D    085C    LD	A,0x5C
  053E    00D4    LD	0x54,A
  053F    085B    LD	A,0x5B
  0540    00D3    LD	0x53,A
  0541    0008    RET
7:                #else
8:                __lldiv(unsigned long int dividend, unsigned long int divisor)
9:                #endif
10:               {
11:               	unsigned long int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x80000000UL) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\even.c ----------------------------------------------------------------------
1:                #include "even.h"
2:                
3:                uint8 cnt2ms=0;
4:                uint8 cnt10ms=0;
5:                bit time2ms=0;
6:                bit time10ms=0;
7:                
8:                void interrupt Isr_Timer()
9:                {
10:                   TMR2IF = 0;
  0711    1283    CLRB	0x3,5
  0712    1303    CLRB	0x3,6
  0713    108C    CLRB	0xC,1
  0714    300A    LDIA	0xA
11:                   cnt2ms++;
  0715    0ABE    INCR	0x3E
12:                   cnt10ms++;
  0716    0ABD    INCR	0x3D
13:                   if(cnt2ms>=10)
  0717    023E    SUBA	0x3E
  0718    1C03    SNZB	0x3,0
  0719    2F1D    JP	0x71D
14:                   {
15:                       LEDScan();
  071A    22BA    CALL	0x2BA
16:                       cnt2ms=0;
  071B    01BE    CLR	0x3E
17:                       time2ms=1;
  071C    1571    SETB	0x71,2
18:                   }
19:                   if(cnt10ms>=50)
  071D    3032    LDIA	0x32
  071E    023D    SUBA	0x3D
  071F    1C03    SNZB	0x3,0
  0720    2F23    JP	0x723
20:                   {
21:                       cnt10ms=0;
  0721    01BD    CLR	0x3D
22:                       time10ms=1;
  0722    14F1    SETB	0x71,1
  0723    0875    LD	A,0x75
  0724    008A    LD	0xA,A
  0725    0874    LD	A,0x74
  0726    0084    LD	0x4,A
  0727    0E73    SWAPA	0x73
  0728    0083    LD	0x3,A
  0729    0EFE    SWAPR	0x7E
  072A    0E7E    SWAPA	0x7E
  072B    0009    RETI
23:                   }
24:               }
25:               
26:               
27:               
28:               
29:               
30:               
31:               
32:               
33:               
34:               
35:               
36:               
---- stringtab ------------------------------------------------------------------
  0777    3007    LDIA	0x7
  0778    008A    LD	0xA,A
  0779    0804    LD	A,0x4
  077A    0A84    INCR	0x4
  077B    0782    ADDR	0x2
  077C    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    30CF    LDIA	0xCF
  000E    1383    CLRB	0x3,7
  000F    00FD    LD	0x7D,A
  0010    3006    LDIA	0x6
  0011    00FE    LD	0x7E,A
  0012    3032    LDIA	0x32
  0013    00FF    LD	0x7F,A
  0014    30A0    LDIA	0xA0
  0015    0084    LD	0x4,A
  0016    2791    CALL	0x791
  0017    30FF    LDIA	0xFF
  0018    00E5    LD	0x65,A
  0019    00E6    LD	0x66,A
  001A    30EF    LDIA	0xEF
  001B    00E7    LD	0x67,A
  001C    30FF    LDIA	0xFF
  001D    00E8    LD	0x68,A
  001E    00E9    LD	0x69,A
  001F    30D2    LDIA	0xD2
  0020    00EA    LD	0x6A,A
  0021    30F0    LDIA	0xF0
  0022    00EB    LD	0x6B,A
  0023    30D6    LDIA	0xD6
  0024    0084    LD	0x4,A
  0025    30DA    LDIA	0xDA
  0026    27CC    CALL	0x7CC
  0027    3020    LDIA	0x20
  0028    0084    LD	0x4,A
  0029    304B    LDIA	0x4B
  002A    27CC    CALL	0x7CC
  002B    01F0    CLR	0x70
  002C    01F1    CLR	0x71
  002D    01F2    CLR	0x72
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F3    LD	0x73,A
  0007    0804    LD	A,0x4
  0008    00F4    LD	0x74,A
  0009    080A    LD	A,0xA
  000A    00F5    LD	0x75,A
  000B    2F11    JP	0x711
---- common_function ------------------------------------------------------------------
  0001    2CAC    JP	0x4AC
  0002    2CB1    JP	0x4B1
  0003    2CB6    JP	0x4B6
  002E    0183    CLR	0x3
  002F    2FD9    JP	0x7D9
  0116    0AA8    INCR	0x28
  0117    1903    SZB	0x3,2
  0118    0AA9    INCR	0x29
  0119    3000    LDIA	0x0
  011A    0229    SUBA	0x29
  011B    0008    RET
  01DC    083F    LD	A,0x3F
  01DD    00CE    LD	0x4E,A
  01DE    01CF    CLR	0x4F
  01DF    084F    LD	A,0x4F
  01E0    0252    SUBA	0x52
  01E1    1D03    SNZB	0x3,2
  01E2    29E5    JP	0x1E5
  01E3    084E    LD	A,0x4E
  01E4    0251    SUBA	0x51
  01E5    083F    LD	A,0x3F
  01E6    0008    RET
  01E7    07D1    ADDR	0x51
  01E8    1803    SZB	0x3,0
  01E9    0AD2    INCR	0x52
  01EA    30FF    LDIA	0xFF
  01EB    07D2    ADDR	0x52
  01EC    0008    RET
  029F    0084    LD	0x4,A
  02A0    1383    CLRB	0x3,7
  02A1    0800    LD	A,0x0
  02A2    00E1    LD	0x61,A
  02A3    0A84    INCR	0x4
  02A4    0800    LD	A,0x0
  02A5    00E2    LD	0x62,A
  02A6    0861    LD	A,0x61
  02A7    00D3    LD	0x53,A
  02A8    0862    LD	A,0x62
  02A9    00D4    LD	0x54,A
  02AA    01D5    CLR	0x55
  02AB    01D6    CLR	0x56
  02AC    0823    LD	A,0x23
  02AD    00CE    LD	0x4E,A
  02AE    0822    LD	A,0x22
  02AF    00CD    LD	0x4D,A
  02B0    0821    LD	A,0x21
  02B1    00CC    LD	0x4C,A
  02B2    0820    LD	A,0x20
  02B3    00CB    LD	0x4B,A
  02B4    0008    RET
  02B5    0842    LD	A,0x42
  02B6    0084    LD	0x4,A
  02B7    3003    LDIA	0x3
  02B8    0204    SUBA	0x4
  02B9    0008    RET
  0333    1683    SETB	0x3,5
  0334    1107    CLRB	0x7,2
  0335    1703    SETB	0x3,6
  0336    110F    CLRB	0xF,2
  0337    1283    CLRB	0x3,5
  0338    1303    CLRB	0x3,6
  0339    1107    CLRB	0x7,2
  033A    0008    RET
  033B    1683    SETB	0x3,5
  033C    1187    CLRB	0x7,3
  033D    1703    SETB	0x3,6
  033E    118F    CLRB	0xF,3
  033F    1283    CLRB	0x3,5
  0340    1303    CLRB	0x3,6
  0341    1187    CLRB	0x7,3
  0342    0008    RET
  0343    1683    SETB	0x3,5
  0344    1286    CLRB	0x6,5
  0345    1295    CLRB	0x15,5
  0346    1283    CLRB	0x3,5
  0347    1286    CLRB	0x6,5
  0348    0008    RET
  0349    1683    SETB	0x3,5
  034A    1186    CLRB	0x6,3
  034B    1195    CLRB	0x15,3
  034C    1283    CLRB	0x3,5
  034D    1186    CLRB	0x6,3
  034E    0008    RET
  034F    1683    SETB	0x3,5
  0350    1206    CLRB	0x6,4
  0351    1215    CLRB	0x15,4
  0352    1283    CLRB	0x3,5
  0353    1206    CLRB	0x6,4
  0354    0008    RET
  03BE    3EBE    ADDIA	0xBE
  03BF    0084    LD	0x4,A
  03C0    1383    CLRB	0x3,7
  03C1    0800    LD	A,0x0
  03C2    00CB    LD	0x4B,A
  03C3    3007    LDIA	0x7
  03C4    01CC    CLR	0x4C
  03C5    00FF    LD	0x7F,A
  03C6    1003    CLRB	0x3,0
  03C7    0DCB    RLCR	0x4B
  03C8    0DCC    RLCR	0x4C
  03C9    0BFF    SZDECR	0x7F
  03CA    2BC6    JP	0x3C6
  03CB    084B    LD	A,0x4B
  03CC    04A6    ORR	0x26
  03CD    084C    LD	A,0x4C
  03CE    04A7    ORR	0x27
  03CF    0008    RET
  03D0    3EBE    ADDIA	0xBE
  03D1    0084    LD	0x4,A
  03D2    1383    CLRB	0x3,7
  03D3    0800    LD	A,0x0
  03D4    04A6    ORR	0x26
  03D5    300A    LDIA	0xA
  03D6    00F6    LD	0x76,A
  03D7    0844    LD	A,0x44
  03D8    0008    RET
  03D9    0800    LD	A,0x0
  03DA    00CB    LD	0x4B,A
  03DB    0A84    INCR	0x4
  03DC    0800    LD	A,0x0
  03DD    00CC    LD	0x4C,A
  03DE    09CB    COMR	0x4B
  03DF    09CC    COMR	0x4C
  03E0    084B    LD	A,0x4B
  03E1    05A6    ANDR	0x26
  03E2    084C    LD	A,0x4C
  03E3    05A7    ANDR	0x27
  03E4    0008    RET
  0442    00F6    LD	0x76,A
  0443    3064    LDIA	0x64
  0444    01F7    CLR	0x77
  0445    00F8    LD	0x78,A
  0446    01F9    CLR	0x79
  0447    0008    RET
  049C    3EBE    ADDIA	0xBE
  049D    0084    LD	0x4,A
  049E    1383    CLRB	0x3,7
  049F    0800    LD	A,0x0
  04A0    00CB    LD	0x4B,A
  04A1    3007    LDIA	0x7
  04A2    01CC    CLR	0x4C
  04A3    00FF    LD	0x7F,A
  04A4    0008    RET
  04A5    0400    ORA	0x0
  04A6    00CD    LD	0x4D,A
  04A7    084C    LD	A,0x4C
  04A8    00CE    LD	0x4E,A
  04A9    084D    LD	A,0x4D
  04AA    0008    RET
  05ED    084D    LD	A,0x4D
  05EE    3EA0    ADDIA	0xA0
  05EF    0084    LD	0x4,A
  05F0    1383    CLRB	0x3,7
  05F1    0A00    INCA	0x0
  05F2    2DF5    JP	0x5F5
  05F3    1003    CLRB	0x3,0
  05F4    0DF8    RLCR	0x78
  05F5    3EFF    ADDIA	0xFF
  05F6    1D03    SNZB	0x3,2
  05F7    2DF3    JP	0x5F3
  05F8    0878    LD	A,0x78
  05F9    0008    RET
  05FA    00F9    LD	0x79,A
  05FB    084D    LD	A,0x4D
  05FC    3E01    ADDIA	0x1
  05FD    0084    LD	0x4,A
  05FE    0008    RET
  0632    3400    RET	0x0
  0633    3401    RET	0x1
  0634    3400    RET	0x0
  0635    3401    RET	0x1
  0636    3401    RET	0x1
  0637    3400    RET	0x0
  0638    3400    RET	0x0
  0639    3402    RET	0x2
  063A    3403    RET	0x3
  063B    3402    RET	0x2
  063C    3403    RET	0x3
  063D    3403    RET	0x3
  063E    3402    RET	0x2
  063F    3402    RET	0x2
  0640    3404    RET	0x4
  0641    3404    RET	0x4
  0642    3400    RET	0x0
  0643    3400    RET	0x0
  0644    3412    RET	0x12
  0645    3400    RET	0x0
  0646    345B    RET	0x5B
  0647    3400    RET	0x0
  0648    347F    RET	0x7F
  0649    3400    RET	0x0
  064A    347F    RET	0x7F
  064B    3409    RET	0x9
  064C    34FF    RET	0xFF
  064D    342D    RET	0x2D
  064E    34FF    RET	0xFF
  064F    343F    RET	0x3F
  0650    3477    RET	0x77
  0651    3424    RET	0x24
  0652    345D    RET	0x5D
  0653    346D    RET	0x6D
  0654    342E    RET	0x2E
  0655    346B    RET	0x6B
  0656    347B    RET	0x7B
  0657    3425    RET	0x25
  0658    347F    RET	0x7F
  0659    342F    RET	0x2F
  065A    3400    RET	0x0
  065B    3440    RET	0x40
  065C    3470    RET	0x70
  065D    3478    RET	0x78
  065E    347E    RET	0x7E
  065F    347F    RET	0x7F
  0660    347F    RET	0x7F
  06AF    3064    LDIA	0x64
  06B0    1283    CLRB	0x3,5
  06B1    1303    CLRB	0x3,6
  06B2    023C    SUBA	0x3C
  06B3    0008    RET
  06CF    0185    CLR	0x5
  06D0    0186    CLR	0x6
  06D1    0187    CLR	0x7
  06D2    30FF    LDIA	0xFF
  06D3    1703    SETB	0x3,6
  06D4    008E    LD	0xE,A
  06D5    1303    CLRB	0x3,6
  06D6    0095    LD	0x15,A
  06D7    1703    SETB	0x3,6
  06D8    008F    LD	0xF,A
  06D9    0008    RET
  077D    3401    RET	0x1
  077E    3402    RET	0x2
  077F    3402    RET	0x2
  0780    3403    RET	0x3
  0781    3400    RET	0x0
  0782    3403    RET	0x3
  0783    3404    RET	0x4
  0784    3400    RET	0x0
  0785    3401    RET	0x1
  0786    3401    RET	0x1
  0787    3402    RET	0x2
  0788    3400    RET	0x0
  0789    3403    RET	0x3
  078A    3404    RET	0x4
  078B    3400    RET	0x0
  078C    3401    RET	0x1
  078D    087E    LD	A,0x7E
  078E    008A    LD	0xA,A
  078F    087F    LD	A,0x7F
  0790    0082    LD	0x2,A
  0791    278D    CALL	0x78D
  0792    0080    LD	0x0,A
  0793    0A84    INCR	0x4
  0794    0804    LD	A,0x4
  0795    067D    XORA	0x7D
  0796    1903    SZB	0x3,2
  0797    3400    RET	0x0
  0798    0AFF    INCR	0x7F
  0799    1903    SZB	0x3,2
  079A    0AFE    INCR	0x7E
  079B    2F91    JP	0x791
  07CC    0064    CLRWDT
  07CD    0180    CLR	0x0
  07CE    0A84    INCR	0x4
  07CF    0604    XORA	0x4
  07D0    1903    SZB	0x3,2
  07D1    3400    RET	0x0
  07D2    0604    XORA	0x4
  07D3    2FCD    JP	0x7CD
  07D4    2ACB    JP	0x2CB
  07D5    2ADD    JP	0x2DD
  07D6    2AEF    JP	0x2EF
  07D7    2B01    JP	0x301
  07D8    2B12    JP	0x312
  07DD    2A60    JP	0x260
  07DE    2A68    JP	0x268
  07DF    2A72    JP	0x272
