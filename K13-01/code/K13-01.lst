---- C:\Users\Administrator\Desktop\project\K13-01\code\main.c ----------------------------------------------------------------------
1:                #include "K13-01.h"
2:                
3:                void main()
4:                {
5:                    SystemInit();
  07C6    27B0    CALL	0x7B0
6:                    while (1)
7:                    {
8:                        Apply();
  07C7    26A1    CALL	0x6A1
  07C8    0064    CLRWDT
  07C9    2FC7    JP	0x7C7
9:                        asm("clrwdt");
10:                   }
11:               }
12:               
---- C:\Users\Administrator\Desktop\project\K13-01\code\K13-01.c ----------------------------------------------------------------------
1:                #include "K13-01.h"
2:                
3:                bit SystemONFlag=0;
4:                uint8 VarPowerUpCount=0;
5:                
6:                uint8 BatPercent=0;
7:                
8:                uint8 WorkMin=0;
9:                
10:               uint8 LockNumb=0;
11:               
12:               TYPE_UNION_LockSta LockSta;
13:               
14:               bit OnOffFlag=0;
15:               bit WorkFlag=0;
16:               bit IovFlag=0;
17:               bit LowBatFlag=0;
18:               bit USBFlag=0;
19:               
20:               uint8 Sec1sCnt=0;
21:               uint8 BatAddTime=0;
22:               uint8 BatDecTime=0;
23:               
24:               void Apply()
25:               {
26:                   if(time2ms)
  06A1    1CF1    SNZB	0x71,1
  06A2    2EA7    JP	0x6A7
27:                   {
28:                       time2ms=0;
  06A3    10F1    CLRB	0x71,1
29:                       if(SystemONFlag)
  06A4    1EF1    SNZB	0x71,5
  06A5    2EA7    JP	0x6A7
30:                       {
31:                           KeyScan();
  06A6    213A    CALL	0x13A
32:                       }
33:                   }
34:                   if(time10ms)
  06A7    1C71    SNZB	0x71,0
  06A8    0008    RET
35:                   {
36:                       time10ms=0;
  06A9    1071    CLRB	0x71,0
37:                       if(SystemONFlag==0&&VarPowerUpCount<100)
  06AA    1AF1    SZB	0x71,5
  06AB    2EB2    JP	0x6B2
  06AC    26C3    CALL	0x6C3
  06AD    1803    SZB	0x3,0
  06AE    2EB2    JP	0x6B2
38:                       {
39:                           VarPowerUpCount++;
  06AF    0ABD    INCR	0x3D
40:                           ADCPro();
  06B0    256C    CALL	0x56C
41:                       }
  06B1    2EB7    JP	0x6B7
42:                       else if(VarPowerUpCount>=100)
  06B2    26C3    CALL	0x6C3
  06B3    1C03    SNZB	0x3,0
  06B4    2EB7    JP	0x6B7
43:                       {
44:                           SystemONFlag=1;
  06B5    16F1    SETB	0x71,5
45:                           VarPowerUpCount=0;
  06B6    01BD    CLR	0x3D
46:                       }
47:                       /*上电完成*/
48:                       if(SystemONFlag)
  06B7    1EF1    SNZB	0x71,5
  06B8    2EBC    JP	0x6BC
49:                       {
50:                           ADCPro();
  06B9    256C    CALL	0x56C
51:                           Motor();
  06BA    2476    CALL	0x476
52:                           DisplayPro();
  06BB    27A3    CALL	0x7A3
  06BC    3064    LDIA	0x64
53:                           //SystemSleep();
54:                       }
55:                       Sec1sCnt++;
  06BD    0ABB    INCR	0x3B
56:                       if(Sec1sCnt>=100)
  06BE    023B    SUBA	0x3B
  06BF    1C03    SNZB	0x3,0
  06C0    0008    RET
57:                       {
58:                           Sec1sCnt=0;
  06C1    01BB    CLR	0x3B
59:                           Sec1sPro();
  06C2    2A11    JP	0x211
60:                       }
61:                       
62:                   }
63:               }
64:               
65:               void SystemSleep()
66:               {
67:                   static uint8 SleepCnt=0;
68:                   if(WorkFlag||OnOffFlag||LowBatFlag||USBFlag||IovFlag)
69:                   {
70:                       SleepCnt=0;
71:                   }
72:                   else
73:                   {
74:                       SleepCnt++;
75:                       if(SleepCnt>=200)
76:                       {
77:                           SleepCnt=0;
78:                           asm("clrwdt");
79:                           INTCON=0;
80:                           PIE1 = 0;
81:                           PIE2 = 0;	
82:                           PIR1 = 0;
83:                           ADCON0	= 0;
84:               
85:                           TRISA =0X00;
86:               	        TRISB =0X00;
87:                           WPUA = 0xFF;
88:                           WPUB = 0xFF;
89:                           WPUC = 0xFF;
90:                           PORTA =	0;			//初始端口配置为输出低；
91:                           PORTB = 0;
92:                           PORTC = 0;
93:                           PIN_BAT=H;
94:                           PIN_IOV=H;
95:                           PIN_GND=H;
96:                           PIN_EN =L;
97:                           Pin_KEY_CFG(1,1);
98:                           Pin_USB_CFG(1,1);
99:               
100:                          WDT_OFF();
101:                          RBIE=1;
102:                          IOCB=0xC0;
103:                          OSCCON=0X01;
104:                          RBIF = 0;
105:                          PORTB;
106:                          asm("sleep");
107:              		    asm("nop");
108:                          SystemInit();
109:                      }
110:                  }
111:              }
112:              
113:              void SystemInit()
  07B0    0000    NOP
  07B1    0064    CLRWDT
114:              {
115:                  asm("nop");
116:              	asm("clrwdt");
117:                  GPIOInit();
  07B2    2679    CALL	0x679
118:                  TimerInit();
  07B3    2787    CALL	0x787
119:                  WDT_ON();
  07B4    3001    LDIA	0x1
  07B5    1283    CLRB	0x3,5
  07B6    1703    SETB	0x3,6
  07B7    0085    LD	0x5,A
  07B8    0008    RET
120:              }
121:              
122:              void GPIOInit()
123:              {
124:                  RBPU=0;
  0679    1683    SETB	0x3,5
  067A    1303    CLRB	0x3,6
  067B    1381    CLRB	0x1,7
125:              	/*全配置成输出*/
126:              	TRISA =0X00;
  067C    0185    CLR	0x5
127:              	TRISB =0X00;
  067D    0186    CLR	0x6
128:              	TRISC =0X00;
  067E    0187    CLR	0x7
129:              	//TRISE =0X00; 
130:              
131:                  /*全部设置上拉，输出会自动断开上拉*/
132:              	WPUA  =0XFF;
  067F    30FF    LDIA	0xFF
  0680    1703    SETB	0x3,6
  0681    008E    LD	0xE,A
133:              	WPUB  =0XFF;
  0682    1303    CLRB	0x3,6
  0683    0095    LD	0x15,A
134:              	WPUC  =0XFF;
  0684    1703    SETB	0x3,6
  0685    008F    LD	0xF,A
135:              	//WPUE  =0XFF;
136:              
137:                  /*默认输出0*/
138:              	PORTA =	0X80;
  0686    3080    LDIA	0x80
  0687    1283    CLRB	0x3,5
  0688    1303    CLRB	0x3,6
  0689    0085    LD	0x5,A
139:              	PORTB = 0X80;
  068A    0086    LD	0x6,A
140:              	PORTC = 0;
  068B    0187    CLR	0x7
141:              	//PORTE = 0;
142:              
143:              	PIN_EN =true;
  068C    1685    SETB	0x5,5
144:                  RBPU=0;
  068D    1683    SETB	0x3,5
  068E    1381    CLRB	0x1,7
145:                  Pin_KEY_CFG(IN,1);
  068F    1705    SETB	0x5,6
  0690    1703    SETB	0x3,6
  0691    170E    SETB	0xE,6
146:                  Pin_USB_CFG(IN,1);
  0692    1303    CLRB	0x3,6
  0693    1785    SETB	0x5,7
  0694    1703    SETB	0x3,6
  0695    178E    SETB	0xE,7
147:              	
148:              	Pin_BAT_CFG(1,0); ANS1=1; //AN1配置为模拟输入；
  0696    1303    CLRB	0x3,6
  0697    1485    SETB	0x5,1
  0698    1703    SETB	0x3,6
  0699    108E    CLRB	0xE,1
  069A    1488    SETB	0x8,1
149:              	Pin_IOV_CFG(1,0); ANS2=1; //AN2配置为模拟输入；
  069B    1303    CLRB	0x3,6
  069C    1505    SETB	0x5,2
  069D    1703    SETB	0x3,6
  069E    110E    CLRB	0xE,2
  069F    1508    SETB	0x8,2
  06A0    0008    RET
150:                  //Pin_Vin_CFG(1,0); ANS9=1;//AN9配置为模拟输入；
151:              }
152:              
153:              void TimerInit()
154:              {
155:                  // OSCCON=0X71;		//晶振配置为8M,内部
156:              	// INTCON=0B11000000;	//使能全局中断，外设中断
157:              	// PIE1=0B00000001;	//TIMER1溢出中断
158:                  // TMR1IF = 0;
159:              	// TMR1IE = 1;	
160:                  // TMR1H=0xFC;
161:                  // TMR1L=0x18;         //设置定时器1计时1ms
162:                  // T1CON = 0X01; //预分配4倍,使能定时器1
163:              
164:              	OSCCON=0X61;		//晶振配置为4M,内部
  0787    3061    LDIA	0x61
  0788    1303    CLRB	0x3,6
  0789    008F    LD	0xF,A
165:              	INTCON=0B11000000;	//使能全局中断，外设中断
  078A    30C0    LDIA	0xC0
  078B    008B    LD	0xB,A
166:              	PIE1=0B00000010;	//TIMER2匹配中断
  078C    3002    LDIA	0x2
  078D    008C    LD	0xC,A
167:              	T2CON=0B00000100;	//使能TIMER2
  078E    3004    LDIA	0x4
  078F    1283    CLRB	0x3,5
  0790    0092    LD	0x12,A
168:              	PR2	= 200;			//TIMER时钟为Fosc/4; 200us进一次中断
  0791    30C8    LDIA	0xC8
  0792    1683    SETB	0x3,5
  0793    0092    LD	0x12,A
  0794    0008    RET
169:              }
---- C:\Users\Administrator\Desktop\project\K13-01\code\ADC.c ----------------------------------------------------------------------
1:                #include "ADC.h"
2:                
3:                uint8 ADCState=0;
4:                uint16 ADCVal[3]={0};//bg、current、Vbat
5:                uint16 ADCMax=0,ADCMin=0;
6:                uint32 ADsum=0;
7:                uint8 ADcnt=0;
8:                
9:                uint8 CurrentCnt=0;
10:               
11:               void ADCPro()
12:               {
13:                   switch (ADCState)
  056C    2D7C    JP	0x57C
14:                   {
15:                       case 0://内部参考电压采样
16:                       ADCRead(AD_BG,ADCVal);
  056D    3047    LDIA	0x47
  056E    00E2    LD	0x62,A
  056F    300F    LDIA	0xF
  0570    2024    CALL	0x24
17:                       break;
  0571    2D84    JP	0x584
18:               
19:                       case 1://过流采样
20:                       ADCRead(AD_AN2,ADCVal+1);
  0572    3049    LDIA	0x49
  0573    00E2    LD	0x62,A
  0574    3002    LDIA	0x2
  0575    2024    CALL	0x24
21:                       break;
  0576    2D84    JP	0x584
22:               
23:                       case 2://电池电压采样
24:                       ADCRead(AD_AN1,ADCVal+2);
  0577    304B    LDIA	0x4B
  0578    00E2    LD	0x62,A
  0579    3001    LDIA	0x1
  057A    2024    CALL	0x24
25:                       break;
  057B    2D84    JP	0x584
  057C    2135    CALL	0x135
  057D    1803    SZB	0x3,0
  057E    2D84    JP	0x584
  057F    3000    LDIA	0x0
  0580    008A    LD	0xA,A
  0581    3001    LDIA	0x1
  0582    0704    ADDA	0x4
  0583    0082    LD	0x2,A
26:                   }
27:                   if(SystemONFlag==0)
  0584    1AF1    SZB	0x71,5
  0585    2D9B    JP	0x59B
28:                   {
29:                       if(ADCVal[2]<BAT_3V2) 
  0586    3001    LDIA	0x1
  0587    024C    SUBA	0x4C
  0588    300B    LDIA	0xB
  0589    1903    SZB	0x3,2
  058A    024B    SUBA	0x4B
  058B    1803    SZB	0x3,0
  058C    2D8F    JP	0x58F
30:                       {
31:                           BatPercent=0; 
  058D    01C6    CLR	0x46
32:                       }
  058E    2D9B    JP	0x59B
33:                       else if(ADCVal[2]>BAT_4V2)
  058F    3001    LDIA	0x1
  0590    024C    SUBA	0x4C
  0591    305F    LDIA	0x5F
  0592    1903    SZB	0x3,2
  0593    024B    SUBA	0x4B
  0594    1C03    SNZB	0x3,0
  0595    2D98    JP	0x598
34:                       {
35:                           BatPercent=99; 
  0596    3063    LDIA	0x63
  0597    2D9A    JP	0x59A
36:                       }
37:                       else
38:                       {
39:                           BatPercent=ADCVal[2]-BAT_3V0;
  0598    084B    LD	A,0x4B
  0599    3E06    ADDIA	0x6
  059A    00C6    LD	0x46,A
40:                       }
41:                   }
42:                   if(ADCVal[2]<BAT_3V0)
43:                   {
44:                       LowBatFlag=1;
45:                   }
46:                   else
47:                   {
48:                       LowBatFlag=0;
49:                   }
50:                   if(ADCVal[1]>VOLTAGE07V)
  059B    3000    LDIA	0x0
  059C    024A    SUBA	0x4A
  059D    303B    LDIA	0x3B
  059E    1903    SZB	0x3,2
  059F    0249    SUBA	0x49
  05A0    1C03    SNZB	0x3,0
  05A1    2DAB    JP	0x5AB
  05A2    30C8    LDIA	0xC8
51:                   {
52:                       CurrentCnt++;
  05A3    0AC1    INCR	0x41
53:                       if(CurrentCnt>=200)
  05A4    0241    SUBA	0x41
  05A5    1C03    SNZB	0x3,0
  05A6    0008    RET
54:                       {
55:                           CurrentCnt=200;
  05A7    30C8    LDIA	0xC8
  05A8    00C1    LD	0x41,A
56:                           IovFlag=1;
  05A9    1671    SETB	0x71,4
  05AA    0008    RET
57:                       }
58:                   }
59:                   else
60:                   {
61:                       CurrentCnt=0;
  05AB    01C1    CLR	0x41
62:                       IovFlag=0;
  05AC    1271    CLRB	0x71,4
  05AD    0008    RET
63:                   }
64:               }
65:               
66:               void Sec1sPro()
67:               {
68:                   static uint8 ActualPercent=0;
69:                   uint8 PercentErr=0;
70:                   uint16 TempPercent=0;
  0211    01D3    CLR	0x53
  0212    01D4    CLR	0x54
71:               
72:                   /*充电数字增加时间*/
73:                   if(USBFlag)
  0213    1DF1    SNZB	0x71,3
  0214    2A70    JP	0x270
74:                   {
75:                       if(ADCVal[2]<BAT_3V3) 
  0215    3001    LDIA	0x1
  0216    024C    SUBA	0x4C
  0217    3013    LDIA	0x13
  0218    1903    SZB	0x3,2
  0219    024B    SUBA	0x4B
  021A    1803    SZB	0x3,0
  021B    2A1E    JP	0x21E
76:                       {
77:                           TempPercent=0; 
  021C    01D3    CLR	0x53
  021D    2A27    JP	0x227
78:                       }
79:                       else if(ADCVal[2]>BAT_4V2)
  021E    3001    LDIA	0x1
  021F    024C    SUBA	0x4C
  0220    305F    LDIA	0x5F
  0221    1903    SZB	0x3,2
  0222    024B    SUBA	0x4B
  0223    1C03    SNZB	0x3,0
  0224    2A29    JP	0x229
80:                       {
81:                           TempPercent=99; 
  0225    3063    LDIA	0x63
  0226    00D3    LD	0x53,A
  0227    01D4    CLR	0x54
82:                       }
  0228    2A45    JP	0x245
83:                       else
84:                       {
85:                           TempPercent=ADCVal[2]-BAT_3V3;
  0229    084C    LD	A,0x4C
  022A    00D4    LD	0x54,A
  022B    084B    LD	A,0x4B
  022C    00D3    LD	0x53,A
  022D    30ED    LDIA	0xED
  022E    22DC    CALL	0x2DC
86:                           TempPercent=TempPercent*4/3;
  022F    3003    LDIA	0x3
  0230    00F5    LD	0x75,A
  0231    01F6    CLR	0x76
  0232    0854    LD	A,0x54
  0233    00D1    LD	0x51,A
  0234    0853    LD	A,0x53
  0235    00D0    LD	0x50,A
  0236    1003    CLRB	0x3,0
  0237    0DD0    RLCR	0x50
  0238    0DD1    RLCR	0x51
  0239    1003    CLRB	0x3,0
  023A    0DD0    RLCR	0x50
  023B    0DD1    RLCR	0x51
  023C    0850    LD	A,0x50
  023D    00F7    LD	0x77,A
  023E    0851    LD	A,0x51
  023F    00F8    LD	0x78,A
  0240    264F    CALL	0x64F
  0241    0876    LD	A,0x76
  0242    00D4    LD	0x54,A
  0243    0875    LD	A,0x75
  0244    00D3    LD	0x53,A
87:                       }
88:                       if(ActualPercent>TempPercent)
89:                       {
90:                           if(ActualPercent)
  0245    22D1    CALL	0x2D1
  0246    1803    SZB	0x3,0
  0247    2A4C    JP	0x24C
  0248    1903    SZB	0x3,2
  0249    2A5B    JP	0x25B
91:                           {
92:                               ActualPercent--;
  024A    03C0    DECR	0x40
  024B    2A5B    JP	0x25B
93:                           }
94:                       }
95:                       else if(ActualPercent<TempPercent)
  024C    00D0    LD	0x50,A
  024D    01D1    CLR	0x51
  024E    0854    LD	A,0x54
  024F    0251    SUBA	0x51
  0250    1D03    SNZB	0x3,2
  0251    2A54    JP	0x254
  0252    0853    LD	A,0x53
  0253    0250    SUBA	0x50
  0254    1803    SZB	0x3,0
  0255    2A5B    JP	0x25B
96:                       {
97:                           if(ActualPercent<99)
  0256    3063    LDIA	0x63
  0257    0240    SUBA	0x40
  0258    1803    SZB	0x3,0
  0259    2A5B    JP	0x25B
98:                           {
99:                               ActualPercent++;
  025A    0AC0    INCR	0x40
100:                          }
101:                      }
102:                      if(ActualPercent>BatPercent)
  025B    0840    LD	A,0x40
  025C    0246    SUBA	0x46
  025D    1803    SZB	0x3,0
  025E    2A6E    JP	0x26E
103:                      {
104:                          PercentErr=ActualPercent-BatPercent;
  025F    0846    LD	A,0x46
  0260    0240    SUBA	0x40
  0261    00D2    LD	0x52,A
105:                          if(PercentErr<5)
  0262    3005    LDIA	0x5
  0263    0252    SUBA	0x52
  0264    1803    SZB	0x3,0
  0265    2A6C    JP	0x26C
106:                          {
107:                              BatAddTime=90-15*PercentErr;
  0266    30F1    LDIA	0xF1
  0267    00F5    LD	0x75,A
  0268    0852    LD	A,0x52
  0269    2795    CALL	0x795
  026A    3E5A    ADDIA	0x5A
  026B    2A6F    JP	0x26F
108:                          }
109:                          else
110:                          {
111:                              BatAddTime=15;
  026C    300F    LDIA	0xF
  026D    2A6F    JP	0x26F
112:                          }
113:                      }
114:                      else
115:                      {
116:                          BatAddTime=240;
  026E    30F0    LDIA	0xF0
  026F    00C5    LD	0x45,A
117:                      }
118:                  }
119:              
120:                  /*工作数字减少时间*/
121:                  if(WorkFlag)
  0270    1D71    SNZB	0x71,2
  0271    2ACE    JP	0x2CE
122:                  {
123:                      if(ADCVal[2]<BAT_3V2) 
  0272    3001    LDIA	0x1
  0273    024C    SUBA	0x4C
  0274    300B    LDIA	0xB
  0275    1903    SZB	0x3,2
  0276    024B    SUBA	0x4B
  0277    1803    SZB	0x3,0
  0278    2A7B    JP	0x27B
124:                      {
125:                          TempPercent=0; 
  0279    01D3    CLR	0x53
  027A    2A84    JP	0x284
126:                      }
127:                      else if(ADCVal[2]>BAT_4V0)
  027B    3001    LDIA	0x1
  027C    024C    SUBA	0x4C
  027D    304E    LDIA	0x4E
  027E    1903    SZB	0x3,2
  027F    024B    SUBA	0x4B
  0280    1C03    SNZB	0x3,0
  0281    2A86    JP	0x286
128:                      {
129:                          TempPercent=99; 
  0282    3063    LDIA	0x63
  0283    00D3    LD	0x53,A
  0284    01D4    CLR	0x54
130:                      }
  0285    2A8C    JP	0x28C
131:                      else
132:                      {
133:                          TempPercent=ADCVal[2]-BAT_3V2;
  0286    084C    LD	A,0x4C
  0287    00D4    LD	0x54,A
  0288    084B    LD	A,0x4B
  0289    00D3    LD	0x53,A
  028A    30F5    LDIA	0xF5
  028B    22DC    CALL	0x2DC
134:                      }
135:                      if(TempPercent>=33)
  028C    3000    LDIA	0x0
  028D    0254    SUBA	0x54
  028E    3021    LDIA	0x21
  028F    1903    SZB	0x3,2
  0290    0253    SUBA	0x53
  0291    1C03    SNZB	0x3,0
  0292    2AA0    JP	0x2A0
136:                      {
137:                          TempPercent=33+(ADCVal[2]-BAT_3V6)*2; 
  0293    084C    LD	A,0x4C
  0294    00D4    LD	0x54,A
  0295    084B    LD	A,0x4B
  0296    00D3    LD	0x53,A
  0297    30C9    LDIA	0xC9
  0298    1003    CLRB	0x3,0
  0299    0DD3    RLCR	0x53
  029A    0DD4    RLCR	0x54
  029B    07D3    ADDR	0x53
  029C    1803    SZB	0x3,0
  029D    0AD4    INCR	0x54
  029E    30FD    LDIA	0xFD
  029F    07D4    ADDR	0x54
138:                      }
139:                      if(ActualPercent>TempPercent)
140:                      {
141:                          if(ActualPercent)
  02A0    22D1    CALL	0x2D1
  02A1    1803    SZB	0x3,0
  02A2    2AA7    JP	0x2A7
  02A3    1903    SZB	0x3,2
  02A4    2AB6    JP	0x2B6
142:                          {
143:                              ActualPercent--;
  02A5    03C0    DECR	0x40
  02A6    2AB6    JP	0x2B6
144:                          }
145:                      }
146:                      else if(ActualPercent<TempPercent)
  02A7    00D0    LD	0x50,A
  02A8    01D1    CLR	0x51
  02A9    0854    LD	A,0x54
  02AA    0251    SUBA	0x51
  02AB    1D03    SNZB	0x3,2
  02AC    2AAF    JP	0x2AF
  02AD    0853    LD	A,0x53
  02AE    0250    SUBA	0x50
  02AF    1803    SZB	0x3,0
  02B0    2AB6    JP	0x2B6
147:                      {
148:                          if(ActualPercent<99)
  02B1    3063    LDIA	0x63
  02B2    0240    SUBA	0x40
  02B3    1803    SZB	0x3,0
  02B4    2AB6    JP	0x2B6
149:                          {
150:                              ActualPercent++;
  02B5    0AC0    INCR	0x40
151:                          }
152:                      }
153:                      if(ActualPercent<BatPercent)
  02B6    0846    LD	A,0x46
  02B7    0240    SUBA	0x40
  02B8    1803    SZB	0x3,0
  02B9    2ACE    JP	0x2CE
154:                      {
155:                          PercentErr=BatPercent-ActualPercent;
  02BA    0840    LD	A,0x40
  02BB    0246    SUBA	0x46
  02BC    00D2    LD	0x52,A
156:                          if(PercentErr<5&&ActualPercent)
  02BD    3005    LDIA	0x5
  02BE    0252    SUBA	0x52
  02BF    1803    SZB	0x3,0
  02C0    2ACB    JP	0x2CB
  02C1    0840    LD	A,0x40
  02C2    1903    SZB	0x3,2
  02C3    2ACB    JP	0x2CB
157:                          {
158:                              BatDecTime=75-15*PercentErr;
  02C4    30F1    LDIA	0xF1
  02C5    00F5    LD	0x75,A
  02C6    0852    LD	A,0x52
  02C7    2795    CALL	0x795
  02C8    3E4B    ADDIA	0x4B
  02C9    00C4    LD	0x44,A
159:                          }
  02CA    0008    RET
160:                          else
161:                          {
162:                              BatDecTime=8;
  02CB    3008    LDIA	0x8
  02CC    00C4    LD	0x44,A
  02CD    0008    RET
163:                          }
164:                      }
165:                      else
166:                      {
167:                          BatDecTime=210;
  02CE    30D2    LDIA	0xD2
  02CF    00C4    LD	0x44,A
  02D0    0008    RET
168:                      }
169:                  }
170:                  else
171:                  {
172:                      BatDecTime=210;
173:                  }
174:              }
175:              
176:              void ADCRead(uint8 ch,uint16 *Val)
  0024    1683    SETB	0x3,5
  0025    00DB    LD	0x5B,A
177:              {
178:              	uint16 ad_temp,AD_H,AD_L;
179:              
180:              	if(ADSample(ch))
  0026    2733    CALL	0x733
  0027    3A00    XORIA	0x0
  0028    1903    SZB	0x3,2
  0029    0008    RET
181:              	{
182:                      AD_H=ADRESH;
  002A    081E    LD	A,0x1E
  002B    1683    SETB	0x3,5
  002C    00DC    LD	0x5C,A
  002D    01DD    CLR	0x5D
183:                      AD_L=ADRESL;
  002E    081E    LD	A,0x1E
  002F    00DE    LD	0x5E,A
  0030    01DF    CLR	0x5F
184:              		ad_temp=(AD_H<<4)|(AD_L>>4);  //12位ad
  0031    085D    LD	A,0x5D
  0032    1283    CLRB	0x3,5
  0033    00E4    LD	0x64,A
  0034    1683    SETB	0x3,5
  0035    085C    LD	A,0x5C
  0036    1283    CLRB	0x3,5
  0037    00E3    LD	0x63,A
  0038    30F0    LDIA	0xF0
  0039    0EE3    SWAPR	0x63
  003A    0EE4    SWAPR	0x64
  003B    05E4    ANDR	0x64
  003C    0863    LD	A,0x63
  003D    390F    ANDIA	0xF
  003E    04E4    ORR	0x64
  003F    30F0    LDIA	0xF0
  0040    05E3    ANDR	0x63
  0041    0863    LD	A,0x63
  0042    1683    SETB	0x3,5
  0043    00E0    LD	0x60,A
  0044    1283    CLRB	0x3,5
  0045    0864    LD	A,0x64
  0046    1683    SETB	0x3,5
  0047    00E1    LD	0x61,A
  0048    085F    LD	A,0x5F
  0049    1283    CLRB	0x3,5
  004A    00E4    LD	0x64,A
  004B    1683    SETB	0x3,5
  004C    085E    LD	A,0x5E
  004D    1283    CLRB	0x3,5
  004E    00E3    LD	0x63,A
  004F    3004    LDIA	0x4
  0050    1003    CLRB	0x3,0
  0051    0CE4    RRCR	0x64
  0052    0CE3    RRCR	0x63
  0053    3EFF    ADDIA	0xFF
  0054    1D03    SNZB	0x3,2
  0055    2850    JP	0x50
  0056    0863    LD	A,0x63
  0057    1683    SETB	0x3,5
  0058    04E0    ORR	0x60
  0059    1283    CLRB	0x3,5
  005A    0864    LD	A,0x64
  005B    1683    SETB	0x3,5
  005C    04E1    ORR	0x61
185:                      if(ad_temp>ADCMax)
  005D    0861    LD	A,0x61
  005E    1283    CLRB	0x3,5
  005F    0230    SUBA	0x30
  0060    1D03    SNZB	0x3,2
  0061    2866    JP	0x66
  0062    1683    SETB	0x3,5
  0063    0860    LD	A,0x60
  0064    1283    CLRB	0x3,5
  0065    022F    SUBA	0x2F
  0066    1803    SZB	0x3,0
  0067    2870    JP	0x70
186:                      {
187:                          ADCMax=ad_temp;
  0068    1683    SETB	0x3,5
  0069    0861    LD	A,0x61
  006A    1283    CLRB	0x3,5
  006B    00B0    LD	0x30,A
  006C    1683    SETB	0x3,5
  006D    0860    LD	A,0x60
  006E    1283    CLRB	0x3,5
  006F    00AF    LD	0x2F,A
188:                      }
189:                      if(ad_temp<ADCMin)
  0070    082E    LD	A,0x2E
  0071    1683    SETB	0x3,5
  0072    0261    SUBA	0x61
  0073    1D03    SNZB	0x3,2
  0074    2879    JP	0x79
  0075    1283    CLRB	0x3,5
  0076    082D    LD	A,0x2D
  0077    1683    SETB	0x3,5
  0078    0260    SUBA	0x60
  0079    1803    SZB	0x3,0
  007A    2882    JP	0x82
190:                      {
191:                          ADCMin=ad_temp;
  007B    0861    LD	A,0x61
  007C    1283    CLRB	0x3,5
  007D    00AE    LD	0x2E,A
  007E    1683    SETB	0x3,5
  007F    0860    LD	A,0x60
  0080    1283    CLRB	0x3,5
  0081    00AD    LD	0x2D,A
192:                      }
193:              		ADsum += ad_temp;
  0082    1683    SETB	0x3,5
  0083    0860    LD	A,0x60
  0084    1283    CLRB	0x3,5
  0085    00E3    LD	0x63,A
  0086    1683    SETB	0x3,5
  0087    0861    LD	A,0x61
  0088    1283    CLRB	0x3,5
  0089    00E4    LD	0x64,A
  008A    01E5    CLR	0x65
  008B    01E6    CLR	0x66
  008C    2124    CALL	0x124
  008D    1803    SZB	0x3,0
  008E    3E01    ADDIA	0x1
  008F    1D03    SNZB	0x3,2
  0090    07A8    ADDR	0x28
  0091    300A    LDIA	0xA
194:              		ADcnt++;
  0092    0AC2    INCR	0x42
195:              		if(ADcnt >= 10)
  0093    0242    SUBA	0x42
  0094    1C03    SNZB	0x3,0
  0095    0008    RET
196:              		{
197:                          ADcnt = 0;	
  0096    01C2    CLR	0x42
198:                          ADsum=  ADsum-ADCMax-ADCMin;
  0097    082D    LD	A,0x2D
  0098    00E3    LD	0x63,A
  0099    082E    LD	A,0x2E
  009A    00E4    LD	0x64,A
  009B    01E5    CLR	0x65
  009C    01E6    CLR	0x66
  009D    082F    LD	A,0x2F
  009E    00E7    LD	0x67,A
  009F    0830    LD	A,0x30
  00A0    00E8    LD	0x68,A
  00A1    01E9    CLR	0x69
  00A2    01EA    CLR	0x6A
  00A3    0867    LD	A,0x67
  00A4    07E3    ADDR	0x63
  00A5    0868    LD	A,0x68
  00A6    1803    SZB	0x3,0
  00A7    0F68    SZINCA	0x68
  00A8    07E4    ADDR	0x64
  00A9    0869    LD	A,0x69
  00AA    1803    SZB	0x3,0
  00AB    0F69    SZINCA	0x69
  00AC    07E5    ADDR	0x65
  00AD    086A    LD	A,0x6A
  00AE    1803    SZB	0x3,0
  00AF    0A6A    INCA	0x6A
  00B0    07E6    ADDR	0x66
  00B1    09E3    COMR	0x63
  00B2    09E4    COMR	0x64
  00B3    09E5    COMR	0x65
  00B4    09E6    COMR	0x66
  00B5    0AE3    INCR	0x63
  00B6    1903    SZB	0x3,2
  00B7    0AE4    INCR	0x64
  00B8    1903    SZB	0x3,2
  00B9    0AE5    INCR	0x65
  00BA    1903    SZB	0x3,2
  00BB    0AE6    INCR	0x66
  00BC    2124    CALL	0x124
  00BD    1803    SZB	0x3,0
  00BE    3E01    ADDIA	0x1
  00BF    1D03    SNZB	0x3,2
  00C0    07A8    ADDR	0x28
199:              			ADsum = ADsum >> 3;
  00C1    3003    LDIA	0x3
  00C2    1003    CLRB	0x3,0
  00C3    0CA8    RRCR	0x28
  00C4    0CA7    RRCR	0x27
  00C5    0CA6    RRCR	0x26
  00C6    0CA5    RRCR	0x25
  00C7    3EFF    ADDIA	0xFF
  00C8    1D03    SNZB	0x3,2
  00C9    28C2    JP	0xC2
200:                          switch (ADCState)
  00CA    28F7    JP	0xF7
201:                          {
202:                              case 0:
203:                              *Val=ADsum;//内部参考电压
  00CB    0862    LD	A,0x62
  00CC    0084    LD	0x4,A
  00CD    0825    LD	A,0x25
  00CE    1383    CLRB	0x3,7
  00CF    0080    LD	0x0,A
  00D0    0A84    INCR	0x4
  00D1    0826    LD	A,0x26
  00D2    28F5    JP	0xF5
204:                              break;
205:              
206:                              case 1:
207:                              *Val=ADsum*1000/(*(Val-1));//电流
  00D3    0862    LD	A,0x62
  00D4    3EFE    ADDIA	0xFE
  00D5    210E    CALL	0x10E
  00D6    3003    LDIA	0x3
  00D7    01D4    CLR	0x54
  00D8    01D3    CLR	0x53
  00D9    00D2    LD	0x52,A
  00DA    30E8    LDIA	0xE8
  00DB    00D1    LD	0x51,A
  00DC    28E5    JP	0xE5
208:                              break;
209:              
210:                              case 2:
211:                              *Val=ADsum*100/(*(Val-2));//电池电压
  00DD    0862    LD	A,0x62
  00DE    3EFC    ADDIA	0xFC
  00DF    210E    CALL	0x10E
  00E0    3064    LDIA	0x64
  00E1    00D1    LD	0x51,A
  00E2    01D2    CLR	0x52
  00E3    01D3    CLR	0x53
  00E4    01D4    CLR	0x54
  00E5    261C    CALL	0x61C
  00E6    0850    LD	A,0x50
  00E7    00DC    LD	0x5C,A
  00E8    084F    LD	A,0x4F
  00E9    00DB    LD	0x5B,A
  00EA    084E    LD	A,0x4E
  00EB    00DA    LD	0x5A,A
  00EC    084D    LD	A,0x4D
  00ED    00D9    LD	0x59,A
  00EE    2524    CALL	0x524
  00EF    0862    LD	A,0x62
  00F0    0084    LD	0x4,A
  00F1    0855    LD	A,0x55
  00F2    0080    LD	0x0,A
  00F3    0A84    INCR	0x4
  00F4    0856    LD	A,0x56
  00F5    0080    LD	0x0,A
212:                              break;
  00F6    28FF    JP	0xFF
  00F7    2135    CALL	0x135
  00F8    1803    SZB	0x3,0
  00F9    28FF    JP	0xFF
  00FA    3007    LDIA	0x7
  00FB    008A    LD	0xA,A
  00FC    30CA    LDIA	0xCA
  00FD    0704    ADDA	0x4
  00FE    0082    LD	0x2,A
  00FF    30FF    LDIA	0xFF
213:                          }
214:                          ADCMax=0;
  0100    01AF    CLR	0x2F
  0101    01B0    CLR	0x30
215:                          ADCMin=0xFFFF;
  0102    00AD    LD	0x2D,A
  0103    00AE    LD	0x2E,A
  0104    3003    LDIA	0x3
216:              			ADsum = 0;
  0105    01A5    CLR	0x25
  0106    01A6    CLR	0x26
  0107    01A7    CLR	0x27
  0108    01A8    CLR	0x28
217:                          ADCState++;
  0109    0AC3    INCR	0x43
218:                          if(ADCState>=3)
  010A    0243    SUBA	0x43
  010B    1803    SZB	0x3,0
219:                          {
220:                              ADCState=0;
  010C    01C3    CLR	0x43
  010D    0008    RET
221:                          }
222:              		}
223:              	}
224:              }
225:              
226:              /************************************************************
227:              函数名称：ADSample()
228:              函数功能：AD采样函数
229:              入口参数：ADCH,AD通道
230:              出口参数：ADRESH,ADRESL
231:              备    注：采样成功返回1，超时返回0
232:              ************************************************************/
233:              uint8 ADSample(uint8 ch)
  0733    00F6    LD	0x76,A
234:              {
235:              	ADCON1 = 0x00;					//左对齐
  0734    019F    CLR	0x1F
236:              	ADCON0 = 0X41 | ( ch << 2);	//16分频
  0735    00F5    LD	0x75,A
  0736    3001    LDIA	0x1
  0737    1003    CLRB	0x3,0
  0738    0DF5    RLCR	0x75
  0739    3EFF    ADDIA	0xFF
  073A    1003    CLRB	0x3,0
  073B    1D03    SNZB	0x3,2
  073C    2F38    JP	0x738
  073D    0D75    RLCA	0x75
  073E    3841    ORIA	0x41
  073F    1283    CLRB	0x3,5
  0740    009F    LD	0x1F,A
  0741    0000    NOP
  0742    0000    NOP
237:              	asm("nop");
238:              	asm("nop");
239:              	GODONE = 1;						//开始转换
  0743    1283    CLRB	0x3,5
  0744    1303    CLRB	0x3,6
  0745    149F    SETB	0x1F,1
240:              	volatile unsigned char i = 0;
  0746    01F7    CLR	0x77
241:              	while(GODONE)
  0747    1C9F    SNZB	0x1F,1
  0748    3401    RET	0x1
242:              	{
243:              		if(0 == (--i))				//ad等待限时，防止拔插电后出现死循环
  0749    0BF7    SZDECR	0x77
  074A    2F47    JP	0x747
244:              			return 0;
  074B    3400    RET	0x0
245:              	}
246:              	return 1;
247:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  064F    01CE    CLR	0x4E
  0650    01CF    CLR	0x4F
  0651    0875    LD	A,0x75
  0652    0476    ORA	0x76
  0653    1903    SZB	0x3,2
  0654    2E74    JP	0x674
  0655    01CD    CLR	0x4D
  0656    0ACD    INCR	0x4D
  0657    1BF6    SZB	0x76,7
  0658    2E5D    JP	0x65D
  0659    1003    CLRB	0x3,0
  065A    0DF5    RLCR	0x75
  065B    0DF6    RLCR	0x76
  065C    2E56    JP	0x656
  065D    1003    CLRB	0x3,0
  065E    0DCE    RLCR	0x4E
  065F    0DCF    RLCR	0x4F
  0660    0876    LD	A,0x76
  0661    0278    SUBA	0x78
  0662    1D03    SNZB	0x3,2
  0663    2E66    JP	0x666
  0664    0875    LD	A,0x75
  0665    0277    SUBA	0x77
  0666    1C03    SNZB	0x3,0
  0667    2E70    JP	0x670
  0668    0875    LD	A,0x75
  0669    02F7    SUBR	0x77
  066A    0876    LD	A,0x76
  066B    1C03    SNZB	0x3,0
  066C    03F8    DECR	0x78
  066D    02F8    SUBR	0x78
  066E    144E    SETB	0x4E,0
  066F    1003    CLRB	0x3,0
  0670    0CF6    RRCR	0x76
  0671    0CF5    RRCR	0x75
  0672    0BCD    SZDECR	0x4D
  0673    2E5D    JP	0x65D
  0674    084F    LD	A,0x4F
  0675    00F6    LD	0x76,A
  0676    084E    LD	A,0x4E
  0677    00F5    LD	0x75,A
  0678    0008    RET
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\Motor.c ----------------------------------------------------------------------
1:                #include "Motor.h"
2:                
3:                uint16 WorkCnt=0;
4:                uint16 TimeDecCnt=0;
5:                uint16 TimeAddCnt=0;
6:                
7:                void Motor()
8:                {
9:                    if(!WorkFlag)
  0476    1971    SZB	0x71,2
  0477    2C7E    JP	0x47E
10:                   {
11:                       //MotorOff();
12:                       WorkCnt=0;
  0478    1683    SETB	0x3,5
  0479    01D7    CLR	0x57
  047A    01D8    CLR	0x58
13:                       TimeDecCnt=0;
  047B    01D5    CLR	0x55
  047C    01D6    CLR	0x56
14:                   }
  047D    2CA9    JP	0x4A9
15:                   else if(WorkFlag&&!LockSta.LockFlag)
  047E    1971    SZB	0x71,2
  047F    1B2B    SZB	0x2B,6
  0480    2CA9    JP	0x4A9
16:                   {
17:                       //MotorOn();
18:                       TimeDecCnt++;
  0481    1683    SETB	0x3,5
  0482    0AD5    INCR	0x55
  0483    1903    SZB	0x3,2
  0484    0AD6    INCR	0x56
19:                       if(TimeDecCnt>=BatDecTime*100)
  0485    1283    CLRB	0x3,5
  0486    0844    LD	A,0x44
  0487    24D1    CALL	0x4D1
  0488    271A    CALL	0x71A
  0489    0876    LD	A,0x76
  048A    1683    SETB	0x3,5
  048B    0256    SUBA	0x56
  048C    1D03    SNZB	0x3,2
  048D    2C90    JP	0x490
  048E    0875    LD	A,0x75
  048F    0255    SUBA	0x55
  0490    1C03    SNZB	0x3,0
  0491    2C98    JP	0x498
20:                       {
21:                           TimeDecCnt=0;
  0492    01D5    CLR	0x55
  0493    01D6    CLR	0x56
22:                           if(BatPercent)
  0494    1283    CLRB	0x3,5
  0495    0846    LD	A,0x46
  0496    1D03    SNZB	0x3,2
23:                           {
24:                               BatPercent--;
  0497    03C6    DECR	0x46
25:                           }
26:                       }
27:                       WorkCnt++;
  0498    1683    SETB	0x3,5
  0499    0AD7    INCR	0x57
  049A    1903    SZB	0x3,2
  049B    0AD8    INCR	0x58
28:                       if(WorkCnt>=6000)
  049C    3017    LDIA	0x17
  049D    0258    SUBA	0x58
  049E    3070    LDIA	0x70
  049F    1903    SZB	0x3,2
  04A0    0257    SUBA	0x57
  04A1    1C03    SNZB	0x3,0
  04A2    2CA9    JP	0x4A9
  04A3    3063    LDIA	0x63
29:                       {
30:                           WorkCnt=0;
  04A4    01D7    CLR	0x57
  04A5    01D8    CLR	0x58
31:                           if(WorkMin<99)
  04A6    027A    SUBA	0x7A
  04A7    1C03    SNZB	0x3,0
32:                           {
33:                               WorkMin++;
  04A8    0AFA    INCR	0x7A
34:                           }
35:                       }
36:                   }
37:                   if(USBFlag)
  04A9    1DF1    SNZB	0x71,3
  04AA    2CCD    JP	0x4CD
38:                   {
39:                       TimeAddCnt++;
  04AB    1683    SETB	0x3,5
  04AC    0AD3    INCR	0x53
  04AD    1903    SZB	0x3,2
  04AE    0AD4    INCR	0x54
40:                       if(TimeAddCnt>BatAddTime*100)
  04AF    1283    CLRB	0x3,5
  04B0    0845    LD	A,0x45
  04B1    24D1    CALL	0x4D1
  04B2    271A    CALL	0x71A
  04B3    1683    SETB	0x3,5
  04B4    0854    LD	A,0x54
  04B5    0276    SUBA	0x76
  04B6    1D03    SNZB	0x3,2
  04B7    2CBA    JP	0x4BA
  04B8    0853    LD	A,0x53
  04B9    0275    SUBA	0x75
  04BA    1803    SZB	0x3,0
  04BB    2CC3    JP	0x4C3
  04BC    3063    LDIA	0x63
41:                       {
42:                           TimeAddCnt=0;
  04BD    01D3    CLR	0x53
  04BE    01D4    CLR	0x54
43:                           if(BatPercent<99)
  04BF    1283    CLRB	0x3,5
  04C0    0246    SUBA	0x46
  04C1    1C03    SNZB	0x3,0
44:                           {
45:                               BatPercent++;
  04C2    0AC6    INCR	0x46
46:                           }
47:                       }
48:                       if(BatPercent<=BAT_3V0)
  04C3    30FB    LDIA	0xFB
  04C4    1283    CLRB	0x3,5
  04C5    0246    SUBA	0x46
  04C6    1803    SZB	0x3,0
  04C7    2CCA    JP	0x4CA
49:                       {
50:                           PIN_EN =false;
  04C8    1285    CLRB	0x5,5
51:                       }
  04C9    0008    RET
52:                       else
53:                       {
54:                           PIN_EN =true;
  04CA    1283    CLRB	0x3,5
  04CB    1685    SETB	0x5,5
  04CC    0008    RET
55:                       }
56:                   }
57:                   else
58:                   {
59:                       TimeAddCnt=0;
  04CD    1683    SETB	0x3,5
  04CE    01D3    CLR	0x53
  04CF    01D4    CLR	0x54
  04D0    2CCA    JP	0x4CA
60:                       PIN_EN =true;
61:                   }
62:               }
63:               
64:               
65:               
66:               
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul16.c ----------------------------------------------------------------------
1:                // 16 x 16 bit multiplication with 16 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned int
15:               __wmul(unsigned int multiplier, unsigned int multiplicand)
  071A    01CD    CLR	0x4D
  071B    01CE    CLR	0x4E
  071C    1C75    SNZB	0x75,0
  071D    2F24    JP	0x724
  071E    0877    LD	A,0x77
  071F    07CD    ADDR	0x4D
  0720    1803    SZB	0x3,0
  0721    0ACE    INCR	0x4E
  0722    0878    LD	A,0x78
  0723    07CE    ADDR	0x4E
  0724    1003    CLRB	0x3,0
  0725    0DF7    RLCR	0x77
  0726    0DF8    RLCR	0x78
  0727    1003    CLRB	0x3,0
  0728    0CF6    RRCR	0x76
  0729    0CF5    RRCR	0x75
  072A    0875    LD	A,0x75
  072B    0476    ORA	0x76
  072C    1D03    SNZB	0x3,2
  072D    2F1C    JP	0x71C
  072E    084E    LD	A,0x4E
  072F    00F6    LD	0x76,A
  0730    084D    LD	A,0x4D
  0731    00F5    LD	0x75,A
  0732    0008    RET
16:               {
17:                       unsigned int product;
18:               
19:               #if _Has_hardware_multiply || _Has_large_call_stack
20:               
21:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:               
24:               	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:               /*
26:               a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                      a  b
28:               *      c  d
29:               -----------
30:                    |   bd
31:                    |ad  0
32:                    |bc  0
33:               +  ac| 0  0 (we ignore this intermediate product
34:                            because it does not affect the low 16 bits of the result)
35:               ===========
36:                */
37:                       product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                       product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                       product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:               
41:               #else
42:               
43:               	product = 0;
44:               	do {
45:               		if(multiplier & 1)
46:               			product += multiplicand;
47:               		multiplicand <<= 1;
48:               		multiplier >>= 1;
49:               	} while(multiplier != 0);
50:               
51:               #endif
52:                       return product;
53:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\Key.c ----------------------------------------------------------------------
1:                #include "Key.h"
2:                
3:                bit KeyInBuf=0;
4:                bit KeyPress=0;
5:                uint16 KeyCnt=0;
6:                
7:                bit USBLink=0;
8:                
9:                void KeyScan()
10:               {
11:               	if(!PIN_KEY)
  013A    1283    CLRB	0x3,5
  013B    1303    CLRB	0x3,6
  013C    1B05    SZB	0x5,6
  013D    2940    JP	0x140
12:               	{
13:               		KeyPress=1;
  013E    16F0    SETB	0x70,5
14:               	}
  013F    2941    JP	0x141
15:               	else
16:               	{
17:               		KeyPress=0;
  0140    12F0    CLRB	0x70,5
18:               	}
19:               	/*按键判断*/
20:               	if(KeyPress&&KeyCnt<10&&KeyInBuf==KeyPress&&!IovFlag)
  0141    1EF0    SNZB	0x70,5
  0142    296E    JP	0x16E
  0143    3000    LDIA	0x0
  0144    022A    SUBA	0x2A
  0145    300A    LDIA	0xA
  0146    1903    SZB	0x3,2
  0147    0229    SUBA	0x29
  0148    1803    SZB	0x3,0
  0149    296E    JP	0x16E
  014A    1EF0    SNZB	0x70,5
  014B    294E    JP	0x14E
  014C    3001    LDIA	0x1
  014D    294F    JP	0x14F
  014E    3000    LDIA	0x0
  014F    00F5    LD	0x75,A
  0150    1F70    SNZB	0x70,6
  0151    2954    JP	0x154
  0152    3001    LDIA	0x1
  0153    2955    JP	0x155
  0154    3000    LDIA	0x0
  0155    0675    XORA	0x75
  0156    1903    SZB	0x3,2
  0157    1A71    SZB	0x71,4
  0158    296E    JP	0x16E
21:               	{
22:               		KeyCnt++;
23:               		if(KeyCnt>=10)
  0159    220B    CALL	0x20B
  015A    300A    LDIA	0xA
  015B    1903    SZB	0x3,2
  015C    0229    SUBA	0x29
  015D    1C03    SNZB	0x3,0
  015E    29F8    JP	0x1F8
24:               		{
25:               			WorkFlag=~WorkFlag; 
  015F    3004    LDIA	0x4
  0160    06F1    XORR	0x71
26:               			if(!WorkFlag&&WorkMin&&!USBFlag&&!LockSta.LockFlag)
  0161    1971    SZB	0x71,2
  0162    296B    JP	0x16B
  0163    087A    LD	A,0x7A
  0164    1D03    SNZB	0x3,2
  0165    19F1    SZB	0x71,3
  0166    296B    JP	0x16B
  0167    1B2B    SZB	0x2B,6
  0168    296B    JP	0x16B
27:               			{
28:               				OnOffFlag=1;
  0169    17F0    SETB	0x70,7
29:               			}
  016A    29F8    JP	0x1F8
30:               			else
31:               			{
32:               				OnOffFlag=0;
  016B    13F0    CLRB	0x70,7
33:               				WorkMin=0;
  016C    01FA    CLR	0x7A
  016D    29F8    JP	0x1F8
34:               			}
35:               		}
36:               	}
37:               	else if(KeyPress&&KeyCnt>=10&&KeyCnt<250&&KeyInBuf==KeyPress&&!USBFlag)
  016E    1EF0    SNZB	0x70,5
  016F    299E    JP	0x19E
  0170    3000    LDIA	0x0
  0171    022A    SUBA	0x2A
  0172    300A    LDIA	0xA
  0173    1903    SZB	0x3,2
  0174    0229    SUBA	0x29
  0175    1C03    SNZB	0x3,0
  0176    299E    JP	0x19E
  0177    3000    LDIA	0x0
  0178    022A    SUBA	0x2A
  0179    30FA    LDIA	0xFA
  017A    1903    SZB	0x3,2
  017B    0229    SUBA	0x29
  017C    1803    SZB	0x3,0
  017D    299E    JP	0x19E
  017E    1EF0    SNZB	0x70,5
  017F    2982    JP	0x182
  0180    3001    LDIA	0x1
  0181    2983    JP	0x183
  0182    3000    LDIA	0x0
  0183    00F5    LD	0x75,A
  0184    1F70    SNZB	0x70,6
  0185    2988    JP	0x188
  0186    3001    LDIA	0x1
  0187    2989    JP	0x189
  0188    3000    LDIA	0x0
  0189    0675    XORA	0x75
  018A    1903    SZB	0x3,2
  018B    19F1    SZB	0x71,3
  018C    299E    JP	0x19E
38:               	{
39:               		KeyCnt++;
40:               		if(KeyCnt>=250)
  018D    220B    CALL	0x20B
  018E    30FA    LDIA	0xFA
  018F    1903    SZB	0x3,2
  0190    0229    SUBA	0x29
  0191    1C03    SNZB	0x3,0
  0192    29F8    JP	0x1F8
41:               		{
42:               			LockNumb=2;
  0193    3002    LDIA	0x2
  0194    00BC    LD	0x3C,A
43:               			if(!LockSta.LockFlag)
  0195    1B2B    SZB	0x2B,6
  0196    299A    JP	0x19A
44:               			{
45:               				LockSta.LockStart=1;
  0197    142B    SETB	0x2B,0
46:               				LockSta.UnlockEnd=0;
  0198    12AB    CLRB	0x2B,5
47:               			}
  0199    299C    JP	0x19C
48:               			else
49:               			{
50:               				LockSta.UnlockStart=1;
  019A    15AB    SETB	0x2B,3
51:               				LockSta.LockEnd=0;
  019B    112B    CLRB	0x2B,2
52:               			}
53:               			OnOffFlag=0;
  019C    13F0    CLRB	0x70,7
  019D    29F8    JP	0x1F8
54:               		}
55:               	}
56:               	else if(KeyPress&&KeyCnt>=250&&KeyInBuf==KeyPress&&!LockSta.LockEnd&&!LockSta.UnlockEnd)
  019E    1EF0    SNZB	0x70,5
  019F    29DA    JP	0x1DA
  01A0    3000    LDIA	0x0
  01A1    022A    SUBA	0x2A
  01A2    30FA    LDIA	0xFA
  01A3    1903    SZB	0x3,2
  01A4    0229    SUBA	0x29
  01A5    1C03    SNZB	0x3,0
  01A6    29DA    JP	0x1DA
  01A7    1EF0    SNZB	0x70,5
  01A8    29AB    JP	0x1AB
  01A9    3001    LDIA	0x1
  01AA    29AC    JP	0x1AC
  01AB    3000    LDIA	0x0
  01AC    00F5    LD	0x75,A
  01AD    1F70    SNZB	0x70,6
  01AE    29B1    JP	0x1B1
  01AF    3001    LDIA	0x1
  01B0    29B2    JP	0x1B2
  01B1    3000    LDIA	0x0
  01B2    0675    XORA	0x75
  01B3    1903    SZB	0x3,2
  01B4    192B    SZB	0x2B,2
  01B5    29DA    JP	0x1DA
  01B6    1AAB    SZB	0x2B,5
  01B7    29DA    JP	0x1DA
57:               	{
58:               		KeyCnt++;
  01B8    0AA9    INCR	0x29
  01B9    1903    SZB	0x3,2
  01BA    0AAA    INCR	0x2A
59:               		if(KeyCnt>=1750)
  01BB    3006    LDIA	0x6
  01BC    022A    SUBA	0x2A
  01BD    30D6    LDIA	0xD6
  01BE    1903    SZB	0x3,2
  01BF    0229    SUBA	0x29
  01C0    1C03    SNZB	0x3,0
  01C1    29F8    JP	0x1F8
60:               		{
61:               			KeyCnt=1750;
  01C2    30D6    LDIA	0xD6
  01C3    00A9    LD	0x29,A
  01C4    3006    LDIA	0x6
  01C5    00AA    LD	0x2A,A
62:               			LockSta.LockFlag=!LockSta.LockFlag;
  01C6    1003    CLRB	0x3,0
  01C7    1F2B    SNZB	0x2B,6
  01C8    1403    SETB	0x3,0
  01C9    1283    CLRB	0x3,5
  01CA    1303    CLRB	0x3,6
  01CB    1C03    SNZB	0x3,0
  01CC    29CF    JP	0x1CF
  01CD    172B    SETB	0x2B,6
  01CE    29D0    JP	0x1D0
  01CF    132B    CLRB	0x2B,6
63:               			if(LockSta.LockFlag)
  01D0    1F2B    SNZB	0x2B,6
  01D1    29D6    JP	0x1D6
64:               			{
65:               				LockSta.LockStart=0;
  01D2    102B    CLRB	0x2B,0
66:               				LockSta.LockEnd=1;
  01D3    152B    SETB	0x2B,2
67:               				WorkFlag=0;
  01D4    1171    CLRB	0x71,2
68:               			}
  01D5    29F8    JP	0x1F8
69:               			else
70:               			{
71:               				LockSta.UnlockStart=0;
  01D6    11AB    CLRB	0x2B,3
72:               				LockSta.UnlockEnd=1;
  01D7    16AB    SETB	0x2B,5
73:               				WorkFlag=1;
  01D8    1571    SETB	0x71,2
  01D9    29F8    JP	0x1F8
74:               			}
75:               		}
76:               	}
77:               	else if(!KeyPress||KeyInBuf!=KeyPress)
  01DA    1EF0    SNZB	0x70,5
  01DB    29EA    JP	0x1EA
  01DC    1EF0    SNZB	0x70,5
  01DD    29E0    JP	0x1E0
  01DE    3001    LDIA	0x1
  01DF    29E1    JP	0x1E1
  01E0    3000    LDIA	0x0
  01E1    00F5    LD	0x75,A
  01E2    1F70    SNZB	0x70,6
  01E3    29E6    JP	0x1E6
  01E4    3001    LDIA	0x1
  01E5    29E7    JP	0x1E7
  01E6    3000    LDIA	0x0
  01E7    0675    XORA	0x75
  01E8    1903    SZB	0x3,2
  01E9    29F8    JP	0x1F8
78:               	{
79:               		KeyCnt=0;
  01EA    01A9    CLR	0x29
  01EB    01AA    CLR	0x2A
80:               		LockSta.UnlockEnd=0;
  01EC    12AB    CLRB	0x2B,5
81:               		if((LockSta.LockFlag&&WorkFlag)||LockSta.UnlockStart)
  01ED    1F2B    SNZB	0x2B,6
  01EE    29F1    JP	0x1F1
  01EF    1971    SZB	0x71,2
  01F0    29F3    JP	0x1F3
  01F1    1DAB    SNZB	0x2B,3
  01F2    29F6    JP	0x1F6
82:               		{
83:               			LockSta.UnlockStart=0;
  01F3    11AB    CLRB	0x2B,3
84:               			LockSta.UnlockFail=1;
  01F4    162B    SETB	0x2B,4
85:               			WorkFlag=0;
  01F5    1171    CLRB	0x71,2
86:               		}
87:               		if(LockSta.LockStart)
  01F6    182B    SZB	0x2B,0
88:               		{
89:               			LockSta.LockStart=0;
  01F7    102B    CLRB	0x2B,0
90:               		}
91:               	}
92:               	KeyInBuf=KeyPress;
  01F8    1370    CLRB	0x70,6
  01F9    1AF0    SZB	0x70,5
  01FA    1770    SETB	0x70,6
93:               
94:               	if(!PIN_USB)
  01FB    1283    CLRB	0x3,5
  01FC    1303    CLRB	0x3,6
  01FD    1B85    SZB	0x5,7
  01FE    2A01    JP	0x201
95:               	{
96:               		USBLink=1;
  01FF    1670    SETB	0x70,4
97:               	}
  0200    2A02    JP	0x202
98:               	else
99:               	{
100:              		USBLink=0;
  0201    1270    CLRB	0x70,4
101:              	}
102:              	/*USB判断*/
103:              	if(USBLink&&!IovFlag)
  0202    1A70    SZB	0x70,4
  0203    1A71    SZB	0x71,4
  0204    2A08    JP	0x208
104:              	{
105:              		USBFlag=1;
  0205    15F1    SETB	0x71,3
106:              		LockSta.LockFlag=0;
  0206    132B    CLRB	0x2B,6
107:              	}
  0207    0008    RET
108:              	else if(!USBLink)
  0208    1E70    SNZB	0x70,4
109:              	{
110:              		USBFlag=0;
  0209    11F1    CLRB	0x71,3
  020A    0008    RET
111:              	}
112:              }
113:              
---- C:\Users\Administrator\Desktop\project\K13-01\code\LED.c ----------------------------------------------------------------------
1:                #include "LED.h"
2:                
3:                uint8 NumbArr[10]={0x77,0x24,0x5D,0X6D,0X2E,0X6B,0X7B,0X25,0X7F,0X2F};//数字
4:                uint8 HideNumbArr[11]={0,0x40,0x70,0x78,0x7E,0x7F,0x3F,0X0F,0x07,0X01,0};//自下往上扫描
5:                uint16 OffHideNumbArr[7]={0,0x12,0x5B,0X7F,0x97F,0x2DFF,0x3FFF};
6:                // const uint8 LEDSeg1[16][2]=
7:                // {
8:                //     {1,0},{2,1},{2,0},{3,1},{0,1},{3,0},{4,0},//上到下，左到右排序,左数字
9:                //     {0,2},{1,3},{1,2},{2,3},{0,3},{3,2},{4,2},//上到下，左到右排序,右数字
10:               //     {0,4},{1,4}//感叹号、锁
11:               // };
12:               const uint8 LEDSeg1[16]={1,2,2,3,0,3,4,0,1,1,2,0,3,4,0,1};
13:               uint8 LEDSeg2[16]={0,1,0,1,1,0,0,2,3,2,3,3,2,2,4,4};
14:               uint16 LedIndex=0;
15:               uint8 LEDArrMap[5]={0};
16:               
17:               void LEDScan()
18:               {
19:                   static uint8 LEDScanIndex=0;
20:               
21:                   Pin_LED1_CFG(IN,0);
  02E2    1683    SETB	0x3,5
  02E3    1686    SETB	0x6,5
  02E4    1295    CLRB	0x15,5
22:                   Pin_LED2_CFG(IN,0);
  02E5    1606    SETB	0x6,4
  02E6    1215    CLRB	0x15,4
23:                   Pin_LED3_CFG(IN,0);
  02E7    1586    SETB	0x6,3
  02E8    1195    CLRB	0x15,3
24:                   Pin_LED4_CFG(IN,0);
  02E9    1587    SETB	0x7,3
  02EA    1703    SETB	0x3,6
  02EB    118F    CLRB	0xF,3
25:                   Pin_LED5_CFG(IN,0);
  02EC    1303    CLRB	0x3,6
  02ED    1507    SETB	0x7,2
  02EE    1703    SETB	0x3,6
  02EF    110F    CLRB	0xF,2
  02F0    0000    NOP
  02F1    0000    NOP
26:                   asm("nop");	asm("nop");
27:               
28:                   switch(LEDScanIndex)
  02F2    2B48    JP	0x348
29:                   {
30:                       case 0:
31:                       if(LEDArrMap[0]&0x02) 
  02F3    1CA0    SNZB	0x20,1
  02F4    2AF6    JP	0x2F6
32:                       {
33:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  02F5    2377    CALL	0x377
34:                       }
35:               		if(LEDArrMap[0]&0x04)  
  02F6    1D20    SNZB	0x20,2
  02F7    2AF9    JP	0x2F9
36:                       {
37:                           Pin_LED3_CFG(OUT,0);PIN_LED3=L ;
  02F8    2371    CALL	0x371
38:                       }
39:               		if(LEDArrMap[0]&0x08) 
  02F9    1DA0    SNZB	0x20,3
  02FA    2AFC    JP	0x2FC
40:                       {
41:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  02FB    2363    CALL	0x363
42:                       }
43:               		if(LEDArrMap[0]&0x10) 
  02FC    1E20    SNZB	0x20,4
  02FD    2AFF    JP	0x2FF
44:                       {
45:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  02FE    235B    CALL	0x35B
46:                       }
47:               		Pin_LED1_CFG(OUT,0);PIN_LED1=H ;
  02FF    1683    SETB	0x3,5
  0300    1286    CLRB	0x6,5
  0301    1295    CLRB	0x15,5
  0302    1283    CLRB	0x3,5
  0303    1686    SETB	0x6,5
48:                       break;
  0304    2B55    JP	0x355
49:               
50:                       case 1:
51:                       if(LEDArrMap[1]&0x01)
  0305    1C21    SNZB	0x21,0
  0306    2B08    JP	0x308
52:                       {
53:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  0307    236B    CALL	0x36B
54:                       } 
55:                       if(LEDArrMap[1]&0x04) 
  0308    1D21    SNZB	0x21,2
  0309    2B0B    JP	0x30B
56:                       {
57:                           Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  030A    2371    CALL	0x371
58:                       }
59:                       if(LEDArrMap[1]&0x08) 
  030B    1DA1    SNZB	0x21,3
  030C    2B0E    JP	0x30E
60:                       {
61:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  030D    2363    CALL	0x363
62:                       }
63:                       if(LEDArrMap[1]&0x10)
  030E    1E21    SNZB	0x21,4
  030F    2B11    JP	0x311
64:                       {
65:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  0310    235B    CALL	0x35B
66:                       } 
67:                       Pin_LED2_CFG(OUT,0); PIN_LED2=H ;
  0311    1683    SETB	0x3,5
  0312    1206    CLRB	0x6,4
  0313    1215    CLRB	0x15,4
  0314    1283    CLRB	0x3,5
  0315    1606    SETB	0x6,4
68:                       break;
  0316    2B55    JP	0x355
69:               
70:                       case 2:
71:                       if(LEDArrMap[2]&0x01) 
  0317    1C22    SNZB	0x22,0
  0318    2B1A    JP	0x31A
72:                       {
73:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  0319    236B    CALL	0x36B
74:                       }
75:               		if(LEDArrMap[2]&0x02) 
  031A    1CA2    SNZB	0x22,1
  031B    2B1D    JP	0x31D
76:                       {
77:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  031C    2377    CALL	0x377
78:                       }
79:               		if(LEDArrMap[2]&0x08) 
  031D    1DA2    SNZB	0x22,3
  031E    2B20    JP	0x320
80:                       {
81:                           Pin_LED4_CFG(OUT,0);PIN_LED4=L ;
  031F    2363    CALL	0x363
82:                       }
83:               		if(LEDArrMap[2]&0x10) 
  0320    1E22    SNZB	0x22,4
  0321    2B23    JP	0x323
84:                       {
85:                           Pin_LED5_CFG(OUT,0);PIN_LED5=L ;
  0322    235B    CALL	0x35B
86:                       }
87:               		Pin_LED3_CFG(OUT,0);PIN_LED3=H ;
  0323    1683    SETB	0x3,5
  0324    1186    CLRB	0x6,3
  0325    1195    CLRB	0x15,3
  0326    1283    CLRB	0x3,5
  0327    1586    SETB	0x6,3
88:                       break;
  0328    2B55    JP	0x355
89:               
90:                       case 3:
91:                       if(LEDArrMap[3]&0x01)
  0329    1C23    SNZB	0x23,0
  032A    2B2C    JP	0x32C
92:                       {
93:                           Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  032B    236B    CALL	0x36B
94:                       }
95:               		if(LEDArrMap[3]&0x02)
  032C    1CA3    SNZB	0x23,1
  032D    2B2F    JP	0x32F
96:                       {
97:                           Pin_LED2_CFG(OUT,0);PIN_LED2=L ;
  032E    2377    CALL	0x377
98:                       }
99:               		if(LEDArrMap[3]&0x04)
  032F    1D23    SNZB	0x23,2
  0330    2B32    JP	0x332
100:                      {
101:                          Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  0331    2371    CALL	0x371
102:                      }
103:              		Pin_LED4_CFG(OUT,0);PIN_LED4=H ;
  0332    1683    SETB	0x3,5
  0333    1187    CLRB	0x7,3
  0334    1703    SETB	0x3,6
  0335    118F    CLRB	0xF,3
  0336    1283    CLRB	0x3,5
  0337    1303    CLRB	0x3,6
  0338    1587    SETB	0x7,3
104:                      break;
  0339    2B55    JP	0x355
105:              
106:                      case 4:
107:                      if(LEDArrMap[4]&0x01)
  033A    1C24    SNZB	0x24,0
  033B    2B3D    JP	0x33D
108:                      {
109:                          Pin_LED1_CFG(OUT,0);PIN_LED1=L ;
  033C    236B    CALL	0x36B
110:                      }
111:              		if(LEDArrMap[4]&0x04)
  033D    1D24    SNZB	0x24,2
  033E    2B40    JP	0x340
112:                      {
113:                          Pin_LED3_CFG(OUT,0);PIN_LED3=L ; 
  033F    2371    CALL	0x371
114:                      }
115:                      Pin_LED5_CFG(OUT,0);PIN_LED5=H ;
  0340    1683    SETB	0x3,5
  0341    1107    CLRB	0x7,2
  0342    1703    SETB	0x3,6
  0343    110F    CLRB	0xF,2
  0344    1283    CLRB	0x3,5
  0345    1303    CLRB	0x3,6
  0346    1507    SETB	0x7,2
116:                  }
  0347    2B55    JP	0x355
  0348    1283    CLRB	0x3,5
  0349    1303    CLRB	0x3,6
  034A    083A    LD	A,0x3A
  034B    0084    LD	0x4,A
  034C    3005    LDIA	0x5
  034D    0204    SUBA	0x4
  034E    1803    SZB	0x3,0
  034F    2B55    JP	0x355
  0350    3007    LDIA	0x7
  0351    008A    LD	0xA,A
  0352    30C1    LDIA	0xC1
  0353    0704    ADDA	0x4
  0354    0082    LD	0x2,A
  0355    3005    LDIA	0x5
117:                  LEDScanIndex++;
  0356    0ABA    INCR	0x3A
118:                  if(LEDScanIndex>=5)
  0357    023A    SUBA	0x3A
  0358    1803    SZB	0x3,0
119:                  {
120:                      LEDScanIndex=0;
  0359    01BA    CLR	0x3A
  035A    0008    RET
121:                  }
122:              }
123:              
124:              void DisplayIcon(uint16 index)
125:              {
126:                  uint8 i=0;
127:                  uint16 Mask=0x01;
  05AE    1283    CLRB	0x3,5
  05AF    01CD    CLR	0x4D
  05B0    0ACD    INCR	0x4D
  05B1    01CE    CLR	0x4E
128:              
129:                  for(i=0;i<16;i++)
  05B2    01CF    CLR	0x4F
130:                  {
131:                      if(index&Mask)
  05B3    084D    LD	A,0x4D
  05B4    0575    ANDA	0x75
  05B5    00F7    LD	0x77,A
  05B6    084E    LD	A,0x4E
  05B7    0576    ANDA	0x76
  05B8    00F8    LD	0x78,A
  05B9    0477    ORA	0x77
132:                      {
133:                          LEDArrMap[LEDSeg1[i]]|=(1<<LEDSeg2[i]);
  05BA    3001    LDIA	0x1
  05BB    00F7    LD	0x77,A
  05BC    1903    SZB	0x3,2
  05BD    2DC6    JP	0x5C6
  05BE    25D7    CALL	0x5D7
  05BF    25E4    CALL	0x5E4
  05C0    274C    CALL	0x74C
  05C1    3E20    ADDIA	0x20
  05C2    0084    LD	0x4,A
  05C3    0878    LD	A,0x78
  05C4    0480    ORR	0x0
134:                      }
  05C5    2DCE    JP	0x5CE
135:                      else
136:                      {
137:                          LEDArrMap[LEDSeg1[i]]&=~(1<<LEDSeg2[i]);
  05C6    25D7    CALL	0x5D7
  05C7    3AFF    XORIA	0xFF
  05C8    25E4    CALL	0x5E4
  05C9    274C    CALL	0x74C
  05CA    3E20    ADDIA	0x20
  05CB    0084    LD	0x4,A
  05CC    0878    LD	A,0x78
  05CD    0580    ANDR	0x0
  05CE    3010    LDIA	0x10
138:                      }
139:                      
140:                      Mask<<=1;
  05CF    1003    CLRB	0x3,0
  05D0    0DCD    RLCR	0x4D
  05D1    0DCE    RLCR	0x4E
  05D2    0ACF    INCR	0x4F
  05D3    024F    SUBA	0x4F
  05D4    1803    SZB	0x3,0
  05D5    0008    RET
  05D6    2DB3    JP	0x5B3
141:                  }
142:              }
143:              
144:              void DisplayPro()
145:              {
146:                  LedIndex=0;
  07A3    1683    SETB	0x3,5
  07A4    01D9    CLR	0x59
  07A5    01DA    CLR	0x5A
147:                  WorkLedPro();
  07A6    237D    CALL	0x37D
148:                  USBLedPro();
  07A7    2409    CALL	0x409
149:                  LockPro();
  07A8    24D7    CALL	0x4D7
150:                  ErrPro();
  07A9    2762    CALL	0x762
151:                  DisplayIcon(LedIndex);
  07AA    1683    SETB	0x3,5
  07AB    085A    LD	A,0x5A
  07AC    00F6    LD	0x76,A
  07AD    0859    LD	A,0x59
  07AE    00F5    LD	0x75,A
  07AF    2DAE    JP	0x5AE
152:              }
153:              
154:              void USBLedPro()
155:              {
156:                  static uint8 index=0;
157:                  static uint8 cnt=0;
158:              
159:                  if(USBFlag&&!WorkFlag&&!OnOffFlag)//充电正常
  0409    19F1    SZB	0x71,3
  040A    1971    SZB	0x71,2
  040B    2C60    JP	0x460
  040C    1BF0    SZB	0x70,7
  040D    2C60    JP	0x460
  040E    3028    LDIA	0x28
160:                  {
161:                      cnt++;
  040F    1283    CLRB	0x3,5
  0410    0AB8    INCR	0x38
162:                      if(cnt>=40)
  0411    0238    SUBA	0x38
  0412    1C03    SNZB	0x3,0
  0413    2C1A    JP	0x41A
  0414    300B    LDIA	0xB
163:                      {
164:                          cnt=0;
  0415    01B8    CLR	0x38
165:                          index++;
  0416    0AB9    INCR	0x39
166:                          if(index>=11)
  0417    0239    SUBA	0x39
  0418    1803    SZB	0x3,0
167:                          {
168:                              index=0;
  0419    01B9    CLR	0x39
169:                          }
170:                      }
171:                      if(BatPercent<99)
  041A    3063    LDIA	0x63
  041B    0246    SUBA	0x46
172:                      {
173:                          LedIndex=NumbArr[BatPercent/10];
  041C    300A    LDIA	0xA
  041D    1803    SZB	0x3,0
  041E    2C49    JP	0x449
  041F    00F5    LD	0x75,A
  0420    0846    LD	A,0x46
  0421    26E4    CALL	0x6E4
174:                          LedIndex|=((uint16)NumbArr[BatPercent%10]&~HideNumbArr[index])<<7;
  0422    2464    CALL	0x464
  0423    26C8    CALL	0x6C8
  0424    2470    CALL	0x470
  0425    0839    LD	A,0x39
  0426    3EBE    ADDIA	0xBE
  0427    0084    LD	0x4,A
  0428    0900    COMA	0x0
  0429    054D    ANDA	0x4D
  042A    00CE    LD	0x4E,A
  042B    3007    LDIA	0x7
  042C    01CF    CLR	0x4F
  042D    00FF    LD	0x7F,A
  042E    1003    CLRB	0x3,0
  042F    0DCE    RLCR	0x4E
  0430    0DCF    RLCR	0x4F
  0431    0BFF    SZDECR	0x7F
  0432    2C2E    JP	0x42E
  0433    084E    LD	A,0x4E
  0434    1683    SETB	0x3,5
  0435    04D9    ORR	0x59
  0436    1283    CLRB	0x3,5
  0437    084F    LD	A,0x4F
  0438    1683    SETB	0x3,5
  0439    04DA    ORR	0x5A
175:                          LedIndex&=~HideNumbArr[index];
  043A    1283    CLRB	0x3,5
  043B    0839    LD	A,0x39
  043C    3EBE    ADDIA	0xBE
  043D    0084    LD	0x4,A
  043E    0900    COMA	0x0
  043F    00CD    LD	0x4D,A
  0440    01CE    CLR	0x4E
  0441    09CE    COMR	0x4E
  0442    1683    SETB	0x3,5
  0443    05D9    ANDR	0x59
  0444    1283    CLRB	0x3,5
  0445    084E    LD	A,0x4E
  0446    1683    SETB	0x3,5
  0447    05DA    ANDR	0x5A
176:                      }
  0448    0008    RET
177:                      else
178:                      {
179:                          index=0;
  0449    01B9    CLR	0x39
180:                          LedIndex=NumbArr[BatPercent/10];
  044A    00F5    LD	0x75,A
  044B    0846    LD	A,0x46
  044C    26E4    CALL	0x6E4
181:                          LedIndex|=NumbArr[BatPercent%10]<<7;
  044D    2464    CALL	0x464
  044E    26C8    CALL	0x6C8
  044F    2470    CALL	0x470
  0450    3007    LDIA	0x7
  0451    01CE    CLR	0x4E
  0452    00FF    LD	0x7F,A
  0453    1003    CLRB	0x3,0
  0454    0DCD    RLCR	0x4D
  0455    0DCE    RLCR	0x4E
  0456    0BFF    SZDECR	0x7F
  0457    2C53    JP	0x453
  0458    084D    LD	A,0x4D
  0459    1683    SETB	0x3,5
  045A    04D9    ORR	0x59
  045B    1283    CLRB	0x3,5
  045C    084E    LD	A,0x4E
  045D    1683    SETB	0x3,5
  045E    04DA    ORR	0x5A
  045F    0008    RET
182:                      }
183:                      
184:                  }
185:                  else
186:                  {
187:                      index=0;
  0460    1283    CLRB	0x3,5
  0461    01B9    CLR	0x39
188:                      cnt=0;
  0462    01B8    CLR	0x38
  0463    0008    RET
189:                  }
190:              }
191:              
192:              void WorkLedPro()
193:              {
194:                  static int8 LedSwitchCnt=0;
195:                  static bit LedSwitchFlag=0;
196:                  static int8 index=0;
197:                  static uint8 cnt=0;
198:                  static bit dir=0;
199:                  if(WorkFlag&&!LockSta.LockStart&&!OnOffFlag&&!LockSta.LockFlag)
  037D    1D71    SNZB	0x71,2
  037E    2BA7    JP	0x3A7
  037F    1283    CLRB	0x3,5
  0380    1C2B    SNZB	0x2B,0
  0381    1BF0    SZB	0x70,7
  0382    2BA7    JP	0x3A7
  0383    1B2B    SZB	0x2B,6
  0384    2BA7    JP	0x3A7
200:                  {
201:                      if(BatPercent<=10)
  0385    300B    LDIA	0xB
  0386    0246    SUBA	0x46
  0387    1803    SZB	0x3,0
  0388    2B92    JP	0x392
  0389    3028    LDIA	0x28
202:                      {
203:                          LedSwitchCnt++;
  038A    0AB7    INCR	0x37
204:                          if(LedSwitchCnt>=40)
  038B    0237    SUBA	0x37
  038C    1C03    SNZB	0x3,0
  038D    2B94    JP	0x394
  038E    3008    LDIA	0x8
205:                          {
206:                              LedSwitchCnt=0;
  038F    01B7    CLR	0x37
207:                              LedSwitchFlag=!LedSwitchFlag;
  0390    06F0    XORR	0x70
  0391    2B94    JP	0x394
208:                          }
209:                      }
210:                      else
211:                      {
212:                          LedSwitchCnt=0;
  0392    01B7    CLR	0x37
213:                          LedSwitchFlag=1;
  0393    15F0    SETB	0x70,3
214:                      }
215:                      if(LedSwitchFlag)
  0394    1DF0    SNZB	0x70,3
  0395    0008    RET
216:                      {
217:                          LedIndex|=NumbArr[BatPercent/10];
  0396    300A    LDIA	0xA
  0397    00F5    LD	0x75,A
  0398    0846    LD	A,0x46
  0399    26E4    CALL	0x6E4
  039A    3EC9    ADDIA	0xC9
  039B    0084    LD	0x4,A
  039C    1383    CLRB	0x3,7
  039D    0800    LD	A,0x0
  039E    1683    SETB	0x3,5
  039F    04D9    ORR	0x59
218:                          LedIndex|=(uint16)NumbArr[BatPercent%10]<<7;
  03A0    300A    LDIA	0xA
  03A1    00F5    LD	0x75,A
  03A2    1283    CLRB	0x3,5
  03A3    0846    LD	A,0x46
  03A4    26C8    CALL	0x6C8
  03A5    23E5    CALL	0x3E5
  03A6    0008    RET
219:                      }
220:                  }
221:                  else if(OnOffFlag)
  03A7    1FF0    SNZB	0x70,7
  03A8    0008    RET
  03A9    3028    LDIA	0x28
222:                  {
223:                      cnt++;
  03AA    1283    CLRB	0x3,5
  03AB    0AB5    INCR	0x35
224:                      if(cnt>=40)
  03AC    0235    SUBA	0x35
  03AD    1C03    SNZB	0x3,0
  03AE    2BBD    JP	0x3BD
  03AF    3007    LDIA	0x7
225:                      {
226:                          cnt=0;
  03B0    01B5    CLR	0x35
227:                          index++;
  03B1    0AB6    INCR	0x36
228:                          if(index>=7)
  03B2    0236    SUBA	0x36
  03B3    1C03    SNZB	0x3,0
  03B4    2BBD    JP	0x3BD
229:                          {
230:                              if(dir)
  03B5    1D70    SNZB	0x70,2
  03B6    2BBA    JP	0x3BA
231:                              {
232:                                  OnOffFlag=0;
  03B7    13F0    CLRB	0x70,7
233:                                  WorkMin=0;
  03B8    01FA    CLR	0x7A
  03B9    0008    RET
234:                                  return;
235:                              }
236:                              dir=!dir;
  03BA    3004    LDIA	0x4
  03BB    06F0    XORR	0x70
237:                              index=0;
  03BC    01B6    CLR	0x36
238:                          }
239:                      }
240:                      if(!dir)
  03BD    1970    SZB	0x70,2
  03BE    2BCC    JP	0x3CC
241:                      {
242:                          LedIndex=NumbArr[BatPercent/10];
  03BF    300A    LDIA	0xA
  03C0    00F5    LD	0x75,A
  03C1    0846    LD	A,0x46
  03C2    26E4    CALL	0x6E4
243:                          LedIndex|=(uint16)NumbArr[BatPercent%10]<<7;
  03C3    2464    CALL	0x464
  03C4    26C8    CALL	0x6C8
  03C5    23E5    CALL	0x3E5
244:                          LedIndex&=~OffHideNumbArr[index];
  03C6    1283    CLRB	0x3,5
  03C7    1003    CLRB	0x3,0
  03C8    0D36    RLCA	0x36
  03C9    3EB0    ADDIA	0xB0
  03CA    0084    LD	0x4,A
245:                      }
  03CB    2BFA    JP	0x3FA
246:                      else
247:                      {
248:                          LedIndex=NumbArr[WorkMin/10];
  03CC    300A    LDIA	0xA
  03CD    00F5    LD	0x75,A
  03CE    087A    LD	A,0x7A
  03CF    26E4    CALL	0x6E4
  03D0    3EC9    ADDIA	0xC9
  03D1    0084    LD	0x4,A
  03D2    1383    CLRB	0x3,7
  03D3    0800    LD	A,0x0
  03D4    1683    SETB	0x3,5
  03D5    00D9    LD	0x59,A
  03D6    300A    LDIA	0xA
  03D7    01DA    CLR	0x5A
249:                          LedIndex|=(uint16)NumbArr[WorkMin%10]<<7;
  03D8    00F5    LD	0x75,A
  03D9    087A    LD	A,0x7A
  03DA    26C8    CALL	0x6C8
  03DB    23E5    CALL	0x3E5
250:                          LedIndex&=~OffHideNumbArr[6-index];
  03DC    30FE    LDIA	0xFE
  03DD    00F5    LD	0x75,A
  03DE    1283    CLRB	0x3,5
  03DF    0836    LD	A,0x36
  03E0    2795    CALL	0x795
  03E1    3EBC    ADDIA	0xBC
  03E2    0084    LD	0x4,A
  03E3    1383    CLRB	0x3,7
  03E4    2BFA    JP	0x3FA
251:                      }
252:                  }
253:              }
254:              
255:              void LockPro()
256:              {
257:                  static uint8 SwitchCnt=0,LockSwitchCnt=0;
258:                  static uint8 Ledcnt=0;
259:                  static bit LedSwitchFlag=0;
260:                  if(!USBFlag)
  04D7    19F1    SZB	0x71,3
  04D8    0008    RET
261:                  {
262:                      if(LockSta.LockStart||LockSta.UnlockStart)
  04D9    1283    CLRB	0x3,5
  04DA    182B    SZB	0x2B,0
  04DB    2CDE    JP	0x4DE
  04DC    1DAB    SNZB	0x2B,3
  04DD    2D06    JP	0x506
  04DE    3064    LDIA	0x64
263:                      {
264:                          SwitchCnt++;
  04DF    0AB4    INCR	0x34
265:                          if(SwitchCnt>=100)
  04E0    0234    SUBA	0x34
  04E1    1C03    SNZB	0x3,0
  04E2    2CE8    JP	0x4E8
266:                          {
267:                              SwitchCnt=0;
  04E3    01B4    CLR	0x34
268:                              if(LockNumb>0)
  04E4    083C    LD	A,0x3C
  04E5    1903    SZB	0x3,2
  04E6    2CE8    JP	0x4E8
269:                              {
270:                                  LockNumb--;
  04E7    03BC    DECR	0x3C
271:                              }
272:                          }
273:                          LedIndex=NumbArr[0];
  04E8    1683    SETB	0x3,5
  04E9    0849    LD	A,0x49
  04EA    00D9    LD	0x59,A
  04EB    01DA    CLR	0x5A
274:                          LedIndex|=(uint16)NumbArr[LockNumb+1]<<7;
  04EC    1283    CLRB	0x3,5
  04ED    083C    LD	A,0x3C
  04EE    3ECA    ADDIA	0xCA
  04EF    0084    LD	0x4,A
  04F0    1383    CLRB	0x3,7
  04F1    0800    LD	A,0x0
  04F2    00F5    LD	0x75,A
  04F3    3007    LDIA	0x7
  04F4    01F6    CLR	0x76
  04F5    00FF    LD	0x7F,A
  04F6    1003    CLRB	0x3,0
  04F7    0DF5    RLCR	0x75
  04F8    0DF6    RLCR	0x76
  04F9    0BFF    SZDECR	0x7F
  04FA    2CF6    JP	0x4F6
  04FB    0875    LD	A,0x75
  04FC    1683    SETB	0x3,5
  04FD    04D9    ORR	0x59
  04FE    0876    LD	A,0x76
  04FF    04DA    ORR	0x5A
275:                          if(LockSta.UnlockStart)
  0500    1283    CLRB	0x3,5
  0501    1DAB    SNZB	0x2B,3
  0502    2D07    JP	0x507
276:                          {
277:                              LedIndex|=iconLock;
  0503    1683    SETB	0x3,5
  0504    17DA    SETB	0x5A,7
  0505    2D07    JP	0x507
278:                          }
279:                      }
280:                      else
281:                      {
282:                          SwitchCnt=0;
  0506    01B4    CLR	0x34
283:                      }
284:                      if(LockSta.LockEnd||LockSta.UnlockFail)
  0507    1283    CLRB	0x3,5
  0508    192B    SZB	0x2B,2
  0509    2D0C    JP	0x50C
  050A    1E2B    SNZB	0x2B,4
  050B    2D21    JP	0x521
  050C    3023    LDIA	0x23
285:                      {
286:                          LockSwitchCnt++;
  050D    0AB3    INCR	0x33
287:                          if(LockSwitchCnt>=35)
  050E    0233    SUBA	0x33
  050F    1C03    SNZB	0x3,0
  0510    2D1D    JP	0x51D
  0511    3002    LDIA	0x2
288:                          {
289:                              LockSwitchCnt=0;
  0512    01B3    CLR	0x33
290:                              LedSwitchFlag=!LedSwitchFlag;
  0513    06F0    XORR	0x70
291:                              if(!LedSwitchFlag)
  0514    18F0    SZB	0x70,1
  0515    2D1D    JP	0x51D
  0516    3004    LDIA	0x4
292:                              {
293:                                  Ledcnt++;
  0517    0AB2    INCR	0x32
294:                                  if(Ledcnt>=4)
  0518    0232    SUBA	0x32
  0519    1C03    SNZB	0x3,0
  051A    2D1D    JP	0x51D
295:                                  {
296:                                      LockSta.LockEnd=0;
  051B    112B    CLRB	0x2B,2
297:                                      LockSta.UnlockFail=0;
  051C    122B    CLRB	0x2B,4
298:                                  }
299:                              }
300:                          }
301:                          if(LedSwitchFlag)
  051D    1CF0    SNZB	0x70,1
  051E    0008    RET
302:                          {
303:                              LedIndex=iconLock;
  051F    3080    LDIA	0x80
  0520    2F74    JP	0x774
304:                          }
305:                      }
306:                      else
307:                      {
308:                          Ledcnt=0;
  0521    01B2    CLR	0x32
309:                          LockSwitchCnt=0;
  0522    01B3    CLR	0x33
  0523    0008    RET
310:                      }
311:                  }
312:              }
313:              
314:              void ErrPro()
315:              {
316:                  static uint8 SwitchCnt=0;
317:                  static bit LedSwitchFlag=0;
318:                  if(IovFlag)
  0762    1E71    SNZB	0x71,4
  0763    2F71    JP	0x771
  0764    3023    LDIA	0x23
319:                  {
320:                      SwitchCnt++;
  0765    1283    CLRB	0x3,5
  0766    0AB1    INCR	0x31
321:                      if(SwitchCnt>=35)
  0767    0231    SUBA	0x31
  0768    1C03    SNZB	0x3,0
  0769    2F6D    JP	0x76D
  076A    3001    LDIA	0x1
322:                      {
323:                          SwitchCnt=0;
  076B    01B1    CLR	0x31
324:                          LedSwitchFlag=!LedSwitchFlag;
  076C    06F0    XORR	0x70
325:              
326:                      }
327:                      if(LedSwitchFlag)
  076D    1C70    SNZB	0x70,0
  076E    0008    RET
328:                      {
329:                          LedIndex=iconErr;
  076F    3040    LDIA	0x40
  0770    2F74    JP	0x774
330:                      }
331:                  }
332:                  else
333:                  {
334:                      SwitchCnt=0;
  0771    1283    CLRB	0x3,5
  0772    01B1    CLR	0x31
  0773    0008    RET
335:                  }
336:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul8.c ----------------------------------------------------------------------
1:                // 8 x 8 bit multiplication with 8 bit result
2:                
3:                unsigned char
4:                __bmul(unsigned char multiplier, unsigned char multiplicand)
  0795    00F7    LD	0x77,A
  0796    01F6    CLR	0x76
  0797    0875    LD	A,0x75
  0798    1877    SZB	0x77,0
  0799    07F6    ADDR	0x76
  079A    1003    CLRB	0x3,0
  079B    0DF5    RLCR	0x75
  079C    1003    CLRB	0x3,0
  079D    0CF7    RRCR	0x77
  079E    0877    LD	A,0x77
  079F    1D03    SNZB	0x3,2
  07A0    2F97    JP	0x797
  07A1    0876    LD	A,0x76
  07A2    0008    RET
5:                {
6:                	unsigned char product = 0;
7:                
8:                #if defined(__OPTIMIZE_SPEED__)
9:                
10:               	if(multiplier & 0x01)
11:               		product = (product + multiplicand) & 0xff;
12:               	multiplicand <<= 1;
13:               
14:               	if(multiplier & 0x02)
15:               		product = (product + multiplicand) & 0xff;
16:               	multiplicand <<= 1;
17:               
18:               	if(multiplier & 0x04)
19:               		product = (product + multiplicand) & 0xff;
20:               	multiplicand <<= 1;
21:               
22:               	if(multiplier & 0x08)
23:               		product = (product + multiplicand) & 0xff;
24:               	multiplicand <<= 1;
25:               
26:               	if(multiplier & 0x10)
27:               		product = (product + multiplicand) & 0xff;
28:               	multiplicand <<= 1;
29:               
30:               	if(multiplier & 0x20)
31:               		product = (product + multiplicand) & 0xff;
32:               	multiplicand <<= 1;
33:               
34:               	if(multiplier & 0x40)
35:               		product = (product + multiplicand) & 0xff;
36:               	multiplicand <<= 1;
37:               
38:               	if(multiplier & 0x80)
39:               		product = (product + multiplicand) & 0xff;
40:               
41:               #else
42:               	do {
43:               		if(multiplier & 1)
44:               			product += multiplicand;
45:               		multiplicand <<= 1;
46:               		multiplier >>= 1;
47:               	} while(multiplier != 0);
48:               
49:               #endif
50:               	return product;
51:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  06C8    00F7    LD	0x77,A
  06C9    3008    LDIA	0x8
  06CA    00F8    LD	0x78,A
  06CB    01F9    CLR	0x79
  06CC    0877    LD	A,0x77
  06CD    00F6    LD	0x76,A
  06CE    3007    LDIA	0x7
  06CF    1003    CLRB	0x3,0
  06D0    0CF6    RRCR	0x76
  06D1    3EFF    ADDIA	0xFF
  06D2    1003    CLRB	0x3,0
  06D3    1D03    SNZB	0x3,2
  06D4    2ED0    JP	0x6D0
  06D5    0D79    RLCA	0x79
  06D6    0476    ORA	0x76
  06D7    00F9    LD	0x79,A
  06D8    1003    CLRB	0x3,0
  06D9    0DF7    RLCR	0x77
  06DA    0875    LD	A,0x75
  06DB    0279    SUBA	0x79
  06DC    1C03    SNZB	0x3,0
  06DD    2EE0    JP	0x6E0
  06DE    0875    LD	A,0x75
  06DF    02F9    SUBR	0x79
  06E0    0BF8    SZDECR	0x78
  06E1    2ECC    JP	0x6CC
  06E2    0879    LD	A,0x79
  06E3    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  06E4    00F6    LD	0x76,A
  06E5    01F8    CLR	0x78
  06E6    0875    LD	A,0x75
  06E7    1903    SZB	0x3,2
  06E8    2EFD    JP	0x6FD
  06E9    01F7    CLR	0x77
  06EA    0AF7    INCR	0x77
  06EB    1BF5    SZB	0x75,7
  06EC    2EF0    JP	0x6F0
  06ED    1003    CLRB	0x3,0
  06EE    0DF5    RLCR	0x75
  06EF    2EEA    JP	0x6EA
  06F0    1003    CLRB	0x3,0
  06F1    0DF8    RLCR	0x78
  06F2    0875    LD	A,0x75
  06F3    0276    SUBA	0x76
  06F4    1C03    SNZB	0x3,0
  06F5    2EFA    JP	0x6FA
  06F6    0875    LD	A,0x75
  06F7    02F6    SUBR	0x76
  06F8    1478    SETB	0x78,0
  06F9    1003    CLRB	0x3,0
  06FA    0CF5    RRCR	0x75
  06FB    0BF7    SZDECR	0x77
  06FC    2EF0    JP	0x6F0
  06FD    0878    LD	A,0x78
  06FE    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\Umul32.c ----------------------------------------------------------------------
1:                // 32 x 32 bit multiplication with 32 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned long
15:               __lmul(unsigned long multiplier, unsigned long multiplicand)
  061C    01F5    CLR	0x75
  061D    01F6    CLR	0x76
  061E    01F7    CLR	0x77
  061F    01F8    CLR	0x78
  0620    1C4D    SNZB	0x4D,0
  0621    2E36    JP	0x636
  0622    0851    LD	A,0x51
  0623    07F5    ADDR	0x75
  0624    0852    LD	A,0x52
  0625    1103    CLRB	0x3,2
  0626    1803    SZB	0x3,0
  0627    3E01    ADDIA	0x1
  0628    1D03    SNZB	0x3,2
  0629    07F6    ADDR	0x76
  062A    0853    LD	A,0x53
  062B    1103    CLRB	0x3,2
  062C    1803    SZB	0x3,0
  062D    3E01    ADDIA	0x1
  062E    1D03    SNZB	0x3,2
  062F    07F7    ADDR	0x77
  0630    0854    LD	A,0x54
  0631    1103    CLRB	0x3,2
  0632    1803    SZB	0x3,0
  0633    3E01    ADDIA	0x1
  0634    1D03    SNZB	0x3,2
  0635    07F8    ADDR	0x78
  0636    1003    CLRB	0x3,0
  0637    0DD1    RLCR	0x51
  0638    0DD2    RLCR	0x52
  0639    0DD3    RLCR	0x53
  063A    0DD4    RLCR	0x54
  063B    1003    CLRB	0x3,0
  063C    0CD0    RRCR	0x50
  063D    0CCF    RRCR	0x4F
  063E    0CCE    RRCR	0x4E
  063F    0CCD    RRCR	0x4D
  0640    0850    LD	A,0x50
  0641    044F    ORA	0x4F
  0642    044E    ORA	0x4E
  0643    044D    ORA	0x4D
  0644    1D03    SNZB	0x3,2
  0645    2E20    JP	0x620
  0646    0878    LD	A,0x78
  0647    00D0    LD	0x50,A
  0648    0877    LD	A,0x77
  0649    00CF    LD	0x4F,A
  064A    0876    LD	A,0x76
  064B    00CE    LD	0x4E,A
  064C    0875    LD	A,0x75
  064D    00CD    LD	0x4D,A
  064E    0008    RET
16:               {
17:               	unsigned long product;
18:               
19:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:               #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:               #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:               
24:               #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:               	{
26:               
27:               #define USE_SHRINK
28:               
29:               /*
30:               a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                            a  b  c  d
32:               *            e  f  g  h
33:               -----------------------
34:                          |         dh
35:                          |      ch  0
36:                          |   bh  0  0
37:                          |ah  0  0  0
38:                          |      dg  0
39:                          |   cg  0  0
40:                          |bg  0  0  0
41:                        ag| 0  0  0  0 (we ignore this intermediate product
42:                                        because it does not affect the low 32 bits of the result)
43:                          |   df  0  0
44:                          |cf  0  0  0
45:                        bf| 0  0  0  0 (ignore)
46:                     af  0| 0  0  0  0 (ignore)
47:                          |de  0  0  0
48:                        ce| 0  0  0  0 (ignore)
49:                     be  0| 0  0  0  0 (ignore)
50:               +  ae  0  0| 0  0  0  0 (ignore)
51:               =======================
52:                */
53:               		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:               
55:               #if defined(USE_MASKS)
56:               		product += ((unsigned long)
57:               			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:               			     +
59:               			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:               			<< 8;
61:               
62:               		product += ((unsigned long)
63:               			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:               			    +
65:               			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:               			    +
67:               			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:               			<< 16;
69:               
70:               		/* cast to smaller type to avoid adding high bits just to discard */
71:               		product += ((unsigned long)
72:               			    (unsigned char)
73:               			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:               			    +
75:               			    (unsigned char)
76:               			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:               			    +
78:               			    (unsigned char)
79:               			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:               			    +
81:               			    (unsigned char)
82:               			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:               			<< 24;
84:               
85:               #elif defined(USE_SHRINK)
86:               		/* add direct to upper bytes, rather than shift and add all bytes */
87:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:               			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:               			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:               
92:               
93:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:               			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:               			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:               			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:               
100:              		*(((unsigned char*)&product)+3) +=
101:              			(unsigned char)
102:              			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:              		*(((unsigned char*)&product)+3) +=
104:              			(unsigned char)
105:              			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:              		*(((unsigned char*)&product)+3) +=
107:              			(unsigned char)
108:              			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:              		*(((unsigned char*)&product)+3) +=
110:              			(unsigned char)
111:              			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:              
113:              #else
114:              #error No method chosen
115:              #endif
116:              	}
117:              #else
118:              
119:              	product = 0;
120:              	do {
121:              		if(multiplier & 1)
122:              			product += multiplicand;
123:              		multiplicand <<= 1;
124:              		multiplier >>= 1;
125:              	} while(multiplier != 0);
126:              
127:              #endif
128:              	return product;
129:              }
---- E:\SCMCU_IDE_V2.00.08_Beta9\data\sources\common\lldiv.c ----------------------------------------------------------------------
1:                // long unsigned unsigned division
2:                
3:                unsigned long int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lldiv(unsigned long int divisor, unsigned long int dividend)
  0524    01DD    CLR	0x5D
  0525    01DE    CLR	0x5E
  0526    01DF    CLR	0x5F
  0527    01E0    CLR	0x60
  0528    0858    LD	A,0x58
  0529    0457    ORA	0x57
  052A    0456    ORA	0x56
  052B    0455    ORA	0x55
  052C    1903    SZB	0x3,2
  052D    2D63    JP	0x563
  052E    01E1    CLR	0x61
  052F    0AE1    INCR	0x61
  0530    1BD8    SZB	0x58,7
  0531    2D38    JP	0x538
  0532    1003    CLRB	0x3,0
  0533    0DD5    RLCR	0x55
  0534    0DD6    RLCR	0x56
  0535    0DD7    RLCR	0x57
  0536    0DD8    RLCR	0x58
  0537    2D2F    JP	0x52F
  0538    1003    CLRB	0x3,0
  0539    0DDD    RLCR	0x5D
  053A    0DDE    RLCR	0x5E
  053B    0DDF    RLCR	0x5F
  053C    0DE0    RLCR	0x60
  053D    0858    LD	A,0x58
  053E    025C    SUBA	0x5C
  053F    1D03    SNZB	0x3,2
  0540    2D4B    JP	0x54B
  0541    0857    LD	A,0x57
  0542    025B    SUBA	0x5B
  0543    1D03    SNZB	0x3,2
  0544    2D4B    JP	0x54B
  0545    0856    LD	A,0x56
  0546    025A    SUBA	0x5A
  0547    1D03    SNZB	0x3,2
  0548    2D4B    JP	0x54B
  0549    0855    LD	A,0x55
  054A    0259    SUBA	0x59
  054B    1C03    SNZB	0x3,0
  054C    2D5D    JP	0x55D
  054D    0855    LD	A,0x55
  054E    02D9    SUBR	0x59
  054F    0856    LD	A,0x56
  0550    1C03    SNZB	0x3,0
  0551    0F56    SZINCA	0x56
  0552    02DA    SUBR	0x5A
  0553    0857    LD	A,0x57
  0554    1C03    SNZB	0x3,0
  0555    0F57    SZINCA	0x57
  0556    02DB    SUBR	0x5B
  0557    0858    LD	A,0x58
  0558    1C03    SNZB	0x3,0
  0559    0F58    SZINCA	0x58
  055A    02DC    SUBR	0x5C
  055B    145D    SETB	0x5D,0
  055C    1003    CLRB	0x3,0
  055D    0CD8    RRCR	0x58
  055E    0CD7    RRCR	0x57
  055F    0CD6    RRCR	0x56
  0560    0CD5    RRCR	0x55
  0561    0BE1    SZDECR	0x61
  0562    2D38    JP	0x538
  0563    0860    LD	A,0x60
  0564    00D8    LD	0x58,A
  0565    085F    LD	A,0x5F
  0566    00D7    LD	0x57,A
  0567    085E    LD	A,0x5E
  0568    00D6    LD	0x56,A
  0569    085D    LD	A,0x5D
  056A    00D5    LD	0x55,A
  056B    0008    RET
7:                #else
8:                __lldiv(unsigned long int dividend, unsigned long int divisor)
9:                #endif
10:               {
11:               	unsigned long int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x80000000UL) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\Users\Administrator\Desktop\project\K13-01\code\even.c ----------------------------------------------------------------------
1:                #include "even.h"
2:                
3:                uint8 cnt2ms=0;
4:                uint8 cnt10ms=0;
5:                bit time2ms=0;
6:                bit time10ms=0;
7:                
8:                void interrupt Isr_Timer()
9:                {
10:                   TMR2IF = 0;
  06FF    1283    CLRB	0x3,5
  0700    1303    CLRB	0x3,6
  0701    108C    CLRB	0xC,1
  0702    300A    LDIA	0xA
11:                   cnt2ms++;
  0703    0ABF    INCR	0x3F
12:                   cnt10ms++;
  0704    0ABE    INCR	0x3E
13:                   if(cnt2ms>=10)
  0705    023F    SUBA	0x3F
  0706    1C03    SNZB	0x3,0
  0707    2F0B    JP	0x70B
14:                   {
15:                       LEDScan();
  0708    22E2    CALL	0x2E2
16:                       cnt2ms=0;
  0709    01BF    CLR	0x3F
17:                       time2ms=1;
  070A    14F1    SETB	0x71,1
18:                   }
19:                   if(cnt10ms>=50)
  070B    3032    LDIA	0x32
  070C    023E    SUBA	0x3E
  070D    1C03    SNZB	0x3,0
  070E    2F11    JP	0x711
20:                   {
21:                       cnt10ms=0;
  070F    01BE    CLR	0x3E
22:                       time10ms=1;
  0710    1471    SETB	0x71,0
  0711    0874    LD	A,0x74
  0712    008A    LD	0xA,A
  0713    0873    LD	A,0x73
  0714    0084    LD	0x4,A
  0715    0E72    SWAPA	0x72
  0716    0083    LD	0x3,A
  0717    0EFE    SWAPR	0x7E
  0718    0E7E    SWAPA	0x7E
  0719    0009    RETI
23:                   }
24:               }
25:               
26:               
27:               
28:               
29:               
30:               
31:               
32:               
33:               
34:               
35:               
36:               
---- stringtab ------------------------------------------------------------------
  074C    3007    LDIA	0x7
  074D    008A    LD	0xA,A
  074E    0804    LD	A,0x4
  074F    0A84    INCR	0x4
  0750    0782    ADDR	0x2
  0751    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    30D3    LDIA	0xD3
  000E    1383    CLRB	0x3,7
  000F    00FD    LD	0x7D,A
  0010    3005    LDIA	0x5
  0011    00FE    LD	0x7E,A
  0012    30E9    LDIA	0xE9
  0013    00FF    LD	0x7F,A
  0014    30A0    LDIA	0xA0
  0015    0084    LD	0x4,A
  0016    277C    CALL	0x77C
  0017    30D3    LDIA	0xD3
  0018    0084    LD	0x4,A
  0019    30DB    LDIA	0xDB
  001A    27B9    CALL	0x7B9
  001B    3020    LDIA	0x20
  001C    0084    LD	0x4,A
  001D    304D    LDIA	0x4D
  001E    27B9    CALL	0x7B9
  001F    01FA    CLR	0x7A
  0020    01F0    CLR	0x70
  0021    01F1    CLR	0x71
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F2    LD	0x72,A
  0007    0804    LD	A,0x4
  0008    00F3    LD	0x73,A
  0009    080A    LD	A,0xA
  000A    00F4    LD	0x74,A
  000B    2EFF    JP	0x6FF
---- common_function ------------------------------------------------------------------
  0001    2D6D    JP	0x56D
  0002    2D72    JP	0x572
  0003    2D77    JP	0x577
  0022    0183    CLR	0x3
  0023    2FC6    JP	0x7C6
  010E    0084    LD	0x4,A
  010F    1383    CLRB	0x3,7
  0110    0800    LD	A,0x0
  0111    00E3    LD	0x63,A
  0112    0A84    INCR	0x4
  0113    0800    LD	A,0x0
  0114    00E4    LD	0x64,A
  0115    0863    LD	A,0x63
  0116    00D5    LD	0x55,A
  0117    0864    LD	A,0x64
  0118    00D6    LD	0x56,A
  0119    01D7    CLR	0x57
  011A    01D8    CLR	0x58
  011B    0828    LD	A,0x28
  011C    00D0    LD	0x50,A
  011D    0827    LD	A,0x27
  011E    00CF    LD	0x4F,A
  011F    0826    LD	A,0x26
  0120    00CE    LD	0x4E,A
  0121    0825    LD	A,0x25
  0122    00CD    LD	0x4D,A
  0123    0008    RET
  0124    0863    LD	A,0x63
  0125    07A5    ADDR	0x25
  0126    0864    LD	A,0x64
  0127    1103    CLRB	0x3,2
  0128    1803    SZB	0x3,0
  0129    3E01    ADDIA	0x1
  012A    1D03    SNZB	0x3,2
  012B    07A6    ADDR	0x26
  012C    0865    LD	A,0x65
  012D    1103    CLRB	0x3,2
  012E    1803    SZB	0x3,0
  012F    3E01    ADDIA	0x1
  0130    1D03    SNZB	0x3,2
  0131    07A7    ADDR	0x27
  0132    0866    LD	A,0x66
  0133    1103    CLRB	0x3,2
  0134    0008    RET
  0135    0843    LD	A,0x43
  0136    0084    LD	0x4,A
  0137    3003    LDIA	0x3
  0138    0204    SUBA	0x4
  0139    0008    RET
  020B    0AA9    INCR	0x29
  020C    1903    SZB	0x3,2
  020D    0AAA    INCR	0x2A
  020E    3000    LDIA	0x0
  020F    022A    SUBA	0x2A
  0210    0008    RET
  02D1    0840    LD	A,0x40
  02D2    00D0    LD	0x50,A
  02D3    01D1    CLR	0x51
  02D4    0851    LD	A,0x51
  02D5    0254    SUBA	0x54
  02D6    1D03    SNZB	0x3,2
  02D7    2ADA    JP	0x2DA
  02D8    0850    LD	A,0x50
  02D9    0253    SUBA	0x53
  02DA    0840    LD	A,0x40
  02DB    0008    RET
  02DC    07D3    ADDR	0x53
  02DD    1803    SZB	0x3,0
  02DE    0AD4    INCR	0x54
  02DF    30FE    LDIA	0xFE
  02E0    07D4    ADDR	0x54
  02E1    0008    RET
  035B    1683    SETB	0x3,5
  035C    1107    CLRB	0x7,2
  035D    1703    SETB	0x3,6
  035E    110F    CLRB	0xF,2
  035F    1283    CLRB	0x3,5
  0360    1303    CLRB	0x3,6
  0361    1107    CLRB	0x7,2
  0362    0008    RET
  0363    1683    SETB	0x3,5
  0364    1187    CLRB	0x7,3
  0365    1703    SETB	0x3,6
  0366    118F    CLRB	0xF,3
  0367    1283    CLRB	0x3,5
  0368    1303    CLRB	0x3,6
  0369    1187    CLRB	0x7,3
  036A    0008    RET
  036B    1683    SETB	0x3,5
  036C    1286    CLRB	0x6,5
  036D    1295    CLRB	0x15,5
  036E    1283    CLRB	0x3,5
  036F    1286    CLRB	0x6,5
  0370    0008    RET
  0371    1683    SETB	0x3,5
  0372    1186    CLRB	0x6,3
  0373    1195    CLRB	0x15,3
  0374    1283    CLRB	0x3,5
  0375    1186    CLRB	0x6,3
  0376    0008    RET
  0377    1683    SETB	0x3,5
  0378    1206    CLRB	0x6,4
  0379    1215    CLRB	0x15,4
  037A    1283    CLRB	0x3,5
  037B    1206    CLRB	0x6,4
  037C    0008    RET
  03E5    3EC9    ADDIA	0xC9
  03E6    0084    LD	0x4,A
  03E7    0800    LD	A,0x0
  03E8    1283    CLRB	0x3,5
  03E9    00CD    LD	0x4D,A
  03EA    3007    LDIA	0x7
  03EB    01CE    CLR	0x4E
  03EC    00FF    LD	0x7F,A
  03ED    1003    CLRB	0x3,0
  03EE    0DCD    RLCR	0x4D
  03EF    0DCE    RLCR	0x4E
  03F0    0BFF    SZDECR	0x7F
  03F1    2BED    JP	0x3ED
  03F2    084D    LD	A,0x4D
  03F3    1683    SETB	0x3,5
  03F4    04D9    ORR	0x59
  03F5    1283    CLRB	0x3,5
  03F6    084E    LD	A,0x4E
  03F7    1683    SETB	0x3,5
  03F8    04DA    ORR	0x5A
  03F9    0008    RET
  03FA    0800    LD	A,0x0
  03FB    00CD    LD	0x4D,A
  03FC    0A84    INCR	0x4
  03FD    0800    LD	A,0x0
  03FE    00CE    LD	0x4E,A
  03FF    09CD    COMR	0x4D
  0400    09CE    COMR	0x4E
  0401    084D    LD	A,0x4D
  0402    1683    SETB	0x3,5
  0403    05D9    ANDR	0x59
  0404    1283    CLRB	0x3,5
  0405    084E    LD	A,0x4E
  0406    1683    SETB	0x3,5
  0407    05DA    ANDR	0x5A
  0408    0008    RET
  0464    3EC9    ADDIA	0xC9
  0465    0084    LD	0x4,A
  0466    1383    CLRB	0x3,7
  0467    0800    LD	A,0x0
  0468    1683    SETB	0x3,5
  0469    00D9    LD	0x59,A
  046A    300A    LDIA	0xA
  046B    01DA    CLR	0x5A
  046C    00F5    LD	0x75,A
  046D    1283    CLRB	0x3,5
  046E    0846    LD	A,0x46
  046F    0008    RET
  0470    3EC9    ADDIA	0xC9
  0471    0084    LD	0x4,A
  0472    0800    LD	A,0x0
  0473    1283    CLRB	0x3,5
  0474    00CD    LD	0x4D,A
  0475    0008    RET
  04D1    00F5    LD	0x75,A
  04D2    3064    LDIA	0x64
  04D3    01F6    CLR	0x76
  04D4    00F7    LD	0x77,A
  04D5    01F8    CLR	0x78
  04D6    0008    RET
  05D7    084F    LD	A,0x4F
  05D8    3EA0    ADDIA	0xA0
  05D9    0084    LD	0x4,A
  05DA    1383    CLRB	0x3,7
  05DB    0A00    INCA	0x0
  05DC    2DDF    JP	0x5DF
  05DD    1003    CLRB	0x3,0
  05DE    0DF7    RLCR	0x77
  05DF    3EFF    ADDIA	0xFF
  05E0    1D03    SNZB	0x3,2
  05E1    2DDD    JP	0x5DD
  05E2    0877    LD	A,0x77
  05E3    0008    RET
  05E4    00F8    LD	0x78,A
  05E5    084F    LD	A,0x4F
  05E6    3E01    ADDIA	0x1
  05E7    0084    LD	0x4,A
  05E8    0008    RET
  05E9    3400    RET	0x0
  05EA    3401    RET	0x1
  05EB    3400    RET	0x0
  05EC    3401    RET	0x1
  05ED    3401    RET	0x1
  05EE    3400    RET	0x0
  05EF    3400    RET	0x0
  05F0    3402    RET	0x2
  05F1    3403    RET	0x3
  05F2    3402    RET	0x2
  05F3    3403    RET	0x3
  05F4    3403    RET	0x3
  05F5    3402    RET	0x2
  05F6    3402    RET	0x2
  05F7    3404    RET	0x4
  05F8    3404    RET	0x4
  05F9    3400    RET	0x0
  05FA    3400    RET	0x0
  05FB    3412    RET	0x12
  05FC    3400    RET	0x0
  05FD    345B    RET	0x5B
  05FE    3400    RET	0x0
  05FF    347F    RET	0x7F
  0600    3400    RET	0x0
  0601    347F    RET	0x7F
  0602    3409    RET	0x9
  0603    34FF    RET	0xFF
  0604    342D    RET	0x2D
  0605    34FF    RET	0xFF
  0606    343F    RET	0x3F
  0607    3400    RET	0x0
  0608    3440    RET	0x40
  0609    3470    RET	0x70
  060A    3478    RET	0x78
  060B    347E    RET	0x7E
  060C    347F    RET	0x7F
  060D    343F    RET	0x3F
  060E    340F    RET	0xF
  060F    3407    RET	0x7
  0610    3401    RET	0x1
  0611    3400    RET	0x0
  0612    3477    RET	0x77
  0613    3424    RET	0x24
  0614    345D    RET	0x5D
  0615    346D    RET	0x6D
  0616    342E    RET	0x2E
  0617    346B    RET	0x6B
  0618    347B    RET	0x7B
  0619    3425    RET	0x25
  061A    347F    RET	0x7F
  061B    342F    RET	0x2F
  06C3    3064    LDIA	0x64
  06C4    1283    CLRB	0x3,5
  06C5    1303    CLRB	0x3,6
  06C6    023D    SUBA	0x3D
  06C7    0008    RET
  0752    3401    RET	0x1
  0753    3402    RET	0x2
  0754    3402    RET	0x2
  0755    3403    RET	0x3
  0756    3400    RET	0x0
  0757    3403    RET	0x3
  0758    3404    RET	0x4
  0759    3400    RET	0x0
  075A    3401    RET	0x1
  075B    3401    RET	0x1
  075C    3402    RET	0x2
  075D    3400    RET	0x0
  075E    3403    RET	0x3
  075F    3404    RET	0x4
  0760    3400    RET	0x0
  0761    3401    RET	0x1
  0774    1683    SETB	0x3,5
  0775    01D9    CLR	0x59
  0776    00DA    LD	0x5A,A
  0777    0008    RET
  0778    087E    LD	A,0x7E
  0779    008A    LD	0xA,A
  077A    087F    LD	A,0x7F
  077B    0082    LD	0x2,A
  077C    2778    CALL	0x778
  077D    0080    LD	0x0,A
  077E    0A84    INCR	0x4
  077F    0804    LD	A,0x4
  0780    067D    XORA	0x7D
  0781    1903    SZB	0x3,2
  0782    3400    RET	0x0
  0783    0AFF    INCR	0x7F
  0784    1903    SZB	0x3,2
  0785    0AFE    INCR	0x7E
  0786    2F7C    JP	0x77C
  07B9    0064    CLRWDT
  07BA    0180    CLR	0x0
  07BB    0A84    INCR	0x4
  07BC    0604    XORA	0x4
  07BD    1903    SZB	0x3,2
  07BE    3400    RET	0x0
  07BF    0604    XORA	0x4
  07C0    2FBA    JP	0x7BA
  07C1    2AF3    JP	0x2F3
  07C2    2B05    JP	0x305
  07C3    2B17    JP	0x317
  07C4    2B29    JP	0x329
  07C5    2B3A    JP	0x33A
  07CA    28CB    JP	0xCB
  07CB    28D3    JP	0xD3
  07CC    28DD    JP	0xDD
